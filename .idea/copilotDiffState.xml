<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/game/GameScreenActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/game/GameScreenActivity.kt" />
              <option name="originalContent" value="package com.example.game&#10;&#10;import android.os.Bundle&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.TopBarComponent.TopBarUI&#10;import com.example.game.core.*&#10;import com.example.game.ui.PlaneUI&#10;import com.example.game.ui.MonsterUI&#10;import com.example.game.ui.WallUI&#10;import com.example.game.ui.SoundControlButton&#10;import com.example.game.ui.BagCoinAnimatedView&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.roundToInt&#10;import kotlin.random.Random&#10;&#10;class GameScreenActivity : BaseGameActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        initAudio()&#10;&#10;        // Initialize AI Avoidance Helper for smart bullet dodging&#10;        AIAvoidanceHelper.init(this)&#10;&#10;        setContent {&#10;            val density = LocalDensity.current&#10;            val screenWidthPx = with(density) { LocalConfiguration.current.screenWidthDp.dp.toPx() }&#10;            val screenHeightPx = with(density) { LocalConfiguration.current.screenHeightDp.dp.toPx() }&#10;&#10;            GameScreen(&#10;                screenWidthPx = screenWidthPx,&#10;                screenHeightPx = screenHeightPx,&#10;                soundPool = soundPool,&#10;                shootSoundId = shootSoundId,&#10;                hitSoundId = hitSoundId,&#10;                onExit = { finish() }&#10;            )&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        AIAvoidanceHelper.release()&#10;    }&#10;}&#10;&#10;@Composable&#10;fun GameScreen(&#10;    screenWidthPx: Float,&#10;    screenHeightPx: Float,&#10;    soundPool: android.media.SoundPool,&#10;    shootSoundId: Int,&#10;    hitSoundId: Int,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val playerName = PrefManager.getPlayerName(context)&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // --- State ---&#10;    var totalScore by remember { mutableStateOf(0) }&#10;    var currentSessionScore by remember { mutableStateOf(0) }&#10;    var planeHp by remember { mutableStateOf(100) } // 0..100&#10;&#10;    var shieldActive by remember { mutableStateOf(false) }&#10;    var wallActive by remember { mutableStateOf(false) }&#10;    var timeActive by remember { mutableStateOf(false) }&#10;&#10;    var isGameOver by remember { mutableStateOf(false) }&#10;    var isLevelClear by remember { mutableStateOf(false) }&#10;    var showGameEndDialog by remember { mutableStateOf(false) }&#10;&#10;    // Show dialog when game ends instead of navigating to new activity&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        if (isGameOver || isLevelClear) {&#10;            delay(500)&#10;            showGameEndDialog = true&#10;        }&#10;    }&#10;&#10;    // --- Plane ---&#10;    var planeX by remember { mutableStateOf(screenWidthPx / 2 - 50f) }&#10;    val planeY = screenHeightPx - 250f&#10;    val planeWidth = 100f&#10;    val planeHeight = 100f&#10;&#10;    // --- Background (2 images loop) ---&#10;    var bg1Y by remember { mutableStateOf(0f) }&#10;    var bg2Y by remember { mutableStateOf(-screenHeightPx) }&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bg1Y += 4f&#10;            bg2Y += 4f&#10;&#10;            // Fix: When an image scrolls completely off screen, place it right above the other one&#10;            if (bg1Y &gt;= screenHeightPx) {&#10;                bg1Y = bg2Y - screenHeightPx&#10;            }&#10;            if (bg2Y &gt;= screenHeightPx) {&#10;                bg2Y = bg1Y - screenHeightPx&#10;            }&#10;&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Entities ---&#10;    val monsters = remember {&#10;        List(10) {&#10;            BaseMonster(&#10;                x = Random.nextFloat() * (screenWidthPx - 100f),&#10;                // Spawn monsters at different Y positions (more spread out)&#10;                y = mutableStateOf(-Random.nextInt(200, 2000).toFloat()), // Increased range&#10;                speed = Random.nextFloat() * 1.5f + 1.5f,&#10;                hp = mutableStateOf(100)&#10;            )&#10;        }&#10;    }&#10;&#10;    // Track respawn times for each monster&#10;    val monsterRespawnTimes = remember { MutableList(monsters.size) { 0L } }&#10;&#10;    val coins = remember {&#10;        List(6) {&#10;            BaseCoin(&#10;                x = Random.nextFloat() * (screenWidthPx - 50f),&#10;                y = mutableStateOf(-Random.nextInt(100, 600).toFloat()),&#10;                speed = Random.nextFloat() * 2f + 1f&#10;            )&#10;        }&#10;    }&#10;&#10;    val bullets = remember { mutableStateListOf&lt;Bullet&gt;() }&#10;    val bagCoins = remember { mutableStateListOf&lt;BagCoinDisplay&gt;() } // uses core.BagCoinDisplay&#10;    var chestItems by remember { mutableStateOf&lt;List&lt;ChestItem&gt;&gt;(emptyList()) }&#10;&#10;    // --- Load player data (score / chest) ---&#10;    LaunchedEffect(Unit) {&#10;        if (!playerName.isNullOrBlank()) {&#10;            FirebaseHelper.syncNewPlayer(playerName)&#10;            FirebaseHelper.getScore(playerName) { totalScore = it }&#10;            FirebaseHelper.getChestItems(playerName) { chestItems = it }&#10;        }&#10;    }&#10;&#10;    // --- Shooting ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.add(Bullet(planeX + planeWidth / 2f - 15f, planeY))&#10;            SoundManager.playSoundEffect(soundPool, shootSoundId, 0.5f)&#10;            delay(350)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.forEach { it.y -= 20f }&#10;            bullets.removeAll { it.y &lt; -40f }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Monster movement ---&#10;    monsters.forEachIndexed { index, m -&gt;&#10;        LaunchedEffect(m, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                // Check if monster needs to respawn after death&#10;                if (!m.alive.value &amp;&amp; System.currentTimeMillis() &gt;= monsterRespawnTimes[index]) {&#10;                    // Respawn the monster at a random position&#10;                    m.y.value = -Random.nextInt(200, 1500).toFloat()&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 100f)&#10;                    m.hp.value = 100&#10;                    m.alive.value = true&#10;                }&#10;&#10;                if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp; !timeActive) {&#10;                    // AI-based evasion: monster tries to dodge bullets intelligently&#10;                    val evasion = AIAvoidanceHelper.calculateEvasion(&#10;                        monsterX = m.x,&#10;                        monsterY = m.y.value,&#10;                        monsterSize = 100f,&#10;                        bullets = bullets,&#10;                        screenWidth = screenWidthPx&#10;                    )&#10;&#10;                    // Apply evasion movement (horizontal dodge)&#10;                    m.x = (m.x + evasion.first).coerceIn(0f, screenWidthPx - 100f)&#10;&#10;                    // Wall is at planeY - 60f, so stop monsters closer to actually touch it&#10;                    val wallTop = planeY - 60f&#10;                    val monsterBottom = m.y.value + 80f // Monster height is 80px&#10;&#10;                    if (wallActive &amp;&amp; monsterBottom &gt;= wallTop) {&#10;                        // Monster has reached wall - STOP here&#10;                        // Wall collision check will drain HP&#10;                    } else {&#10;                        // Normal movement&#10;                        m.y.value += m.speed&#10;                    }&#10;&#10;                    // If monster falls below plane (passed), damage plane and respawn&#10;                    if (m.y.value &gt; planeY + planeHeight / 2f) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) planeHp -= 50&#10;                        // Schedule respawn with random delay (3-8 seconds)&#10;                        monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 8000)&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;                delay(16)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Coin movement ---&#10;    coins.forEach { c -&gt;&#10;        LaunchedEffect(c, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                if (!c.collected.value &amp;&amp; !timeActive) {&#10;                    c.y.value += c.speed&#10;                    if (c.y.value &gt; screenHeightPx) {&#10;                        c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                        c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                    }&#10;                }&#10;                delay(32)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Bullet vs Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            val iter = bullets.iterator()&#10;            while (iter.hasNext()) {&#10;                val b = iter.next()&#10;                monsters.forEach { m -&gt;&#10;                    if (CollisionUtils.checkCollisionBulletMonster(b, m)) {&#10;                        // hit: reduce monster HP&#10;                        m.hp.value -= 25&#10;                        // Play hit sound&#10;                        SoundManager.playSoundEffect(soundPool, hitSoundId, 0.3f)&#10;                        iter.remove()&#10;                        if (m.hp.value &lt;= 0) {&#10;                            m.alive.value = false&#10;                            // Schedule respawn with random delay (3-8 seconds)&#10;                            val index = monsters.indexOf(m)&#10;                            if (index &gt;= 0) {&#10;                                monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 8000)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            // DON'T check for level clear here - let monsters respawn naturally&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Coin collision (collect coin) ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            coins.forEach { c -&gt;&#10;                if (!c.collected.value &amp;&amp; CollisionUtils.checkCollisionPlaneCoin(planeX, planeY, planeWidth, planeHeight, c)) {&#10;                    c.collected.value = true&#10;                    totalScore += 1&#10;                    currentSessionScore += 1&#10;                    // add bag coin display (will be animated in UI)&#10;                    val bag = BagCoinDisplay(c.x, c.y.value, 1)&#10;                    bagCoins.add(bag)&#10;                    // update backend&#10;                    if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Monster collision (direct hit) ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            monsters.forEach { m -&gt;&#10;                if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp;&#10;                    CollisionUtils.checkCollisionPlaneMonster(planeX, planeY, planeWidth, planeHeight, m)&#10;                ) {&#10;                    if (!shieldActive &amp;&amp; !wallActive) planeHp -= 50&#10;                    // kill this monster&#10;                    m.hp.value = 0&#10;                    m.alive.value = false&#10;                }&#10;            }&#10;            if (planeHp &lt;= 0) isGameOver = true&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Wall - Monster collision (wall damages monsters) ---&#10;    LaunchedEffect(wallActive, isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            if (wallActive) {&#10;                monsters.forEach { m -&gt;&#10;                    if (m.alive.value &amp;&amp; m.hp.value &gt; 0) {&#10;                        val isColliding = CollisionUtils.checkCollisionWallMonster(planeY, m)&#10;                        if (isColliding) {&#10;                            // Wall drains monster HP continuously&#10;                            m.hp.value -= 2 // Drain 2 HP per tick&#10;                            if (m.hp.value &lt;= 0) {&#10;                                m.alive.value = false&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(50) // Check every 50ms&#10;        }&#10;    }&#10;&#10;    // --- Use chest item wrapper ---&#10;    fun useChestItem(item: ChestItem) {&#10;        ChestItemEffectsBase.applyItemEffect(&#10;            itemName = item.name,&#10;            monsters = monsters,&#10;            coins = coins,&#10;            bagCoins = bagCoins,&#10;            coroutineScope = coroutineScope,&#10;            screenHeightPx = screenHeightPx,&#10;            planeX = planeX,&#10;            onScoreUpdate = { add -&gt;&#10;                totalScore += add&#10;                currentSessionScore += add&#10;                if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;            },&#10;            onShieldToggle = { active -&gt; shieldActive = active },&#10;            onWallToggle = { active -&gt; wallActive = active },&#10;            onTimeToggle = { active -&gt; timeActive = active },&#10;            onLevelClear = { isLevelClear = true }&#10;        )&#10;        chestItems = chestItems - item&#10;        if (!playerName.isNullOrBlank()) FirebaseHelper.updateChest(playerName, chestItems)&#10;    }&#10;&#10;    // --- Drag plane ---&#10;    val dragModifier = Modifier.pointerInput(Unit) {&#10;        detectDragGestures { change, dragAmount -&gt;&#10;            planeX = (planeX + dragAmount.x).coerceIn(0f, screenWidthPx - planeWidth)&#10;            change.consume()&#10;        }&#10;    }&#10;&#10;    // --- UI ---&#10;    Box(modifier = Modifier.fillMaxSize().then(dragModifier)) {&#10;        // background layers (sliding)&#10;        Image(&#10;            painter = painterResource(R.drawable.nen2),&#10;            contentDescription = null,&#10;            modifier = Modifier&#10;                .absoluteOffset { IntOffset(0, bg1Y.roundToInt()) }&#10;                .fillMaxSize()&#10;        )&#10;        Image(&#10;            painter = painterResource(R.drawable.nen2),&#10;            contentDescription = null,&#10;            modifier = Modifier&#10;                .absoluteOffset { IntOffset(0, bg2Y.roundToInt()) }&#10;                .fillMaxSize()&#10;        )&#10;&#10;        // --- Monsters (using MonsterUI component) ---&#10;        monsters.forEach { m -&gt;&#10;            MonsterUI(monster = m)&#10;        }&#10;&#10;        // --- Coins ---&#10;        coins.filter { !it.collected.value }.forEach { c -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.coin),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(c.x.roundToInt(), c.y.value.roundToInt()) }&#10;                    .size(40.dp)&#10;            )&#10;        }&#10;&#10;        // --- BagCoin animated views (spawned when coin collected) ---&#10;        bagCoins.toList().forEach { bag -&gt;&#10;            BagCoinAnimatedView(bag = bag, onFinished = { finishedBag -&gt;&#10;                bagCoins.remove(finishedBag)&#10;            })&#10;        }&#10;&#10;        // --- Bullets ---&#10;        bullets.forEach { b -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.dan2),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(b.x.roundToInt(), b.y.roundToInt()) }&#10;                    .size(30.dp)&#10;            )&#10;        }&#10;&#10;        // --- Plane (using PlaneUI component) ---&#10;        PlaneUI(&#10;            planeX = planeX,&#10;            planeY = planeY,&#10;            planeHp = planeHp,&#10;            shieldActive = shieldActive&#10;        )&#10;&#10;        // --- Wall effect (using WallUI component) ---&#10;        if (wallActive) {&#10;            WallUI(planeY = planeY)&#10;        }&#10;&#10;        // --- Top bar with chest items and score ---&#10;        TopBarUI(&#10;            bagCoinScore = totalScore,&#10;            chestItems = chestItems,&#10;            onBuyItem = { item, price -&gt;&#10;                if (totalScore &gt;= price) {&#10;                    totalScore -= price&#10;                    chestItems = chestItems + item&#10;                    if (!playerName.isNullOrBlank()) {&#10;                        FirebaseHelper.updateScore(playerName, totalScore)&#10;                        FirebaseHelper.updateChest(playerName, chestItems)&#10;                    }&#10;                }&#10;            },&#10;            onUseChestItem = { useChestItem(it) }&#10;        )&#10;&#10;        // --- Sound Control Button (top-right corner) ---&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp),&#10;            contentAlignment = Alignment.TopEnd&#10;        ) {&#10;            SoundControlButton()&#10;        }&#10;    }&#10;&#10;    // --- Game End Dialog ---&#10;    if (showGameEndDialog) {&#10;        GameEndDialog(&#10;            isWin = isLevelClear,&#10;            score = currentSessionScore,&#10;            level = 1,&#10;            onDismiss = {&#10;                showGameEndDialog = false&#10;            },&#10;            onReplay = {&#10;                // Reset game state to replay&#10;                showGameEndDialog = false&#10;                isGameOver = false&#10;                isLevelClear = false&#10;                planeHp = 100&#10;                currentSessionScore = 0&#10;&#10;                // Reset monsters&#10;                monsters.forEachIndexed { index, m -&gt;&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 100f)&#10;                    m.y.value = -Random.nextInt(200, 2000).toFloat()&#10;                    m.hp.value = 100&#10;                    m.alive.value = true&#10;                    monsterRespawnTimes[index] = 0L&#10;                }&#10;&#10;                // Reset coins&#10;                coins.forEach { c -&gt;&#10;                    c.collected.value = false&#10;                    c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                    c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                }&#10;&#10;                // Clear bullets&#10;                bullets.clear()&#10;            },&#10;            onNextLevel = {&#10;                // Navigate to next level handled by GameEndDialog itself&#10;                onExit() // Close this activity&#10;            },&#10;            onExit = {&#10;                // Back to main menu&#10;                onExit()&#10;            }&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.game&#10;&#10;import android.os.Bundle&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.TopBarComponent.TopBarUI&#10;import com.example.game.core.*&#10;import com.example.game.ui.PlaneUI&#10;import com.example.game.ui.MonsterUI&#10;import com.example.game.ui.WallUI&#10;import com.example.game.ui.SoundControlButton&#10;import com.example.game.ui.BagCoinAnimatedView&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.roundToInt&#10;import kotlin.random.Random&#10;&#10;class GameScreenActivity : BaseGameActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        initAudio()&#10;&#10;        // Initialize AI Avoidance Helper for smart bullet dodging&#10;        try {&#10;            AIAvoidanceHelper.init(this)&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;GameScreenActivity&quot;, &quot;AI init failed: ${e.message}&quot;, e)&#10;            // Continue without AI - game will still work with basic logic&#10;        }&#10;&#10;        setContent {&#10;            val density = LocalDensity.current&#10;            val screenWidthPx = with(density) { LocalConfiguration.current.screenWidthDp.dp.toPx() }&#10;            val screenHeightPx = with(density) { LocalConfiguration.current.screenHeightDp.dp.toPx() }&#10;&#10;            GameScreen(&#10;                screenWidthPx = screenWidthPx,&#10;                screenHeightPx = screenHeightPx,&#10;                soundPool = soundPool,&#10;                shootSoundId = shootSoundId,&#10;                hitSoundId = hitSoundId,&#10;                onExit = { finish() }&#10;            )&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        try {&#10;            AIAvoidanceHelper.release()&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;GameScreenActivity&quot;, &quot;AI release failed: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun GameScreen(&#10;    screenWidthPx: Float,&#10;    screenHeightPx: Float,&#10;    soundPool: android.media.SoundPool,&#10;    shootSoundId: Int,&#10;    hitSoundId: Int,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val playerName = PrefManager.getPlayerName(context)&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // --- State ---&#10;    var totalScore by remember { mutableStateOf(0) }&#10;    var currentSessionScore by remember { mutableStateOf(0) }&#10;    var planeHp by remember { mutableStateOf(100) } // 0..100&#10;&#10;    var shieldActive by remember { mutableStateOf(false) }&#10;    var wallActive by remember { mutableStateOf(false) }&#10;    var timeActive by remember { mutableStateOf(false) }&#10;&#10;    var isGameOver by remember { mutableStateOf(false) }&#10;    var isLevelClear by remember { mutableStateOf(false) }&#10;    var showGameEndDialog by remember { mutableStateOf(false) }&#10;&#10;    // Show dialog when game ends instead of navigating to new activity&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        if (isGameOver || isLevelClear) {&#10;            delay(500)&#10;            showGameEndDialog = true&#10;        }&#10;    }&#10;&#10;    // --- Plane ---&#10;    var planeX by remember { mutableStateOf(screenWidthPx / 2 - 50f) }&#10;    val planeY = screenHeightPx - 250f&#10;    val planeWidth = 100f&#10;    val planeHeight = 100f&#10;&#10;    // --- Background (2 images loop) ---&#10;    var bg1Y by remember { mutableStateOf(0f) }&#10;    var bg2Y by remember { mutableStateOf(-screenHeightPx) }&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bg1Y += 4f&#10;            bg2Y += 4f&#10;&#10;            // Fix: When an image scrolls completely off screen, place it right above the other one&#10;            if (bg1Y &gt;= screenHeightPx) {&#10;                bg1Y = bg2Y - screenHeightPx&#10;            }&#10;            if (bg2Y &gt;= screenHeightPx) {&#10;                bg2Y = bg1Y - screenHeightPx&#10;            }&#10;&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Entities ---&#10;    val monsters = remember {&#10;        List(10) {&#10;            BaseMonster(&#10;                x = Random.nextFloat() * (screenWidthPx - 100f),&#10;                // Spawn monsters at different Y positions (more spread out)&#10;                y = mutableStateOf(-Random.nextInt(200, 2000).toFloat()), // Increased range&#10;                speed = Random.nextFloat() * 1.5f + 1.5f,&#10;                hp = mutableStateOf(100)&#10;            )&#10;        }&#10;    }&#10;&#10;    // Track respawn times for each monster&#10;    val monsterRespawnTimes = remember { MutableList(monsters.size) { 0L } }&#10;&#10;    val coins = remember {&#10;        List(6) {&#10;            BaseCoin(&#10;                x = Random.nextFloat() * (screenWidthPx - 50f),&#10;                y = mutableStateOf(-Random.nextInt(100, 600).toFloat()),&#10;                speed = Random.nextFloat() * 2f + 1f&#10;            )&#10;        }&#10;    }&#10;&#10;    val bullets = remember { mutableStateListOf&lt;Bullet&gt;() }&#10;    val bagCoins = remember { mutableStateListOf&lt;BagCoinDisplay&gt;() } // uses core.BagCoinDisplay&#10;    var chestItems by remember { mutableStateOf&lt;List&lt;ChestItem&gt;&gt;(emptyList()) }&#10;&#10;    // --- Load player data (score / chest) ---&#10;    LaunchedEffect(Unit) {&#10;        if (!playerName.isNullOrBlank()) {&#10;            FirebaseHelper.syncNewPlayer(playerName)&#10;            FirebaseHelper.getScore(playerName) { totalScore = it }&#10;            FirebaseHelper.getChestItems(playerName) { chestItems = it }&#10;        }&#10;    }&#10;&#10;    // --- Shooting ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.add(Bullet(planeX + planeWidth / 2f - 15f, planeY))&#10;            SoundManager.playSoundEffect(soundPool, shootSoundId, 0.5f)&#10;            delay(350)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.forEach { it.y -= 20f }&#10;            bullets.removeAll { it.y &lt; -40f }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Monster movement ---&#10;    monsters.forEachIndexed { index, m -&gt;&#10;        LaunchedEffect(m, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                // Check if monster needs to respawn after death&#10;                if (!m.alive.value &amp;&amp; System.currentTimeMillis() &gt;= monsterRespawnTimes[index]) {&#10;                    // Respawn the monster at a random position&#10;                    m.y.value = -Random.nextInt(200, 1500).toFloat()&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 100f)&#10;                    m.hp.value = 100&#10;                    m.alive.value = true&#10;                }&#10;&#10;                if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp; !timeActive) {&#10;                    // AI-based evasion: monster tries to dodge bullets intelligently&#10;                    val evasion = AIAvoidanceHelper.calculateEvasion(&#10;                        monsterX = m.x,&#10;                        monsterY = m.y.value,&#10;                        monsterSize = 100f,&#10;                        bullets = bullets,&#10;                        screenWidth = screenWidthPx&#10;                    )&#10;&#10;                    // Apply evasion movement (horizontal dodge)&#10;                    m.x = (m.x + evasion.first).coerceIn(0f, screenWidthPx - 100f)&#10;&#10;                    // Wall is at planeY - 60f, so stop monsters closer to actually touch it&#10;                    val wallTop = planeY - 60f&#10;                    val monsterBottom = m.y.value + 80f // Monster height is 80px&#10;&#10;                    if (wallActive &amp;&amp; monsterBottom &gt;= wallTop) {&#10;                        // Monster has reached wall - STOP here&#10;                        // Wall collision check will drain HP&#10;                    } else {&#10;                        // Normal movement&#10;                        m.y.value += m.speed&#10;                    }&#10;&#10;                    // If monster falls below plane (passed), damage plane and respawn&#10;                    if (m.y.value &gt; planeY + planeHeight / 2f) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) planeHp -= 50&#10;                        // Schedule respawn with random delay (3-8 seconds)&#10;                        monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 8000)&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;                delay(16)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Coin movement ---&#10;    coins.forEach { c -&gt;&#10;        LaunchedEffect(c, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                if (!c.collected.value &amp;&amp; !timeActive) {&#10;                    c.y.value += c.speed&#10;                    if (c.y.value &gt; screenHeightPx) {&#10;                        c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                        c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                    }&#10;                }&#10;                delay(32)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Bullet vs Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            val iter = bullets.iterator()&#10;            while (iter.hasNext()) {&#10;                val b = iter.next()&#10;                monsters.forEach { m -&gt;&#10;                    if (CollisionUtils.checkCollisionBulletMonster(b, m)) {&#10;                        // hit: reduce monster HP&#10;                        m.hp.value -= 25&#10;                        // Play hit sound&#10;                        SoundManager.playSoundEffect(soundPool, hitSoundId, 0.3f)&#10;                        iter.remove()&#10;                        if (m.hp.value &lt;= 0) {&#10;                            m.alive.value = false&#10;                            // Schedule respawn with random delay (3-8 seconds)&#10;                            val index = monsters.indexOf(m)&#10;                            if (index &gt;= 0) {&#10;                                monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 8000)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            // DON'T check for level clear here - let monsters respawn naturally&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Coin collision (collect coin) ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            coins.forEach { c -&gt;&#10;                if (!c.collected.value &amp;&amp; CollisionUtils.checkCollisionPlaneCoin(planeX, planeY, planeWidth, planeHeight, c)) {&#10;                    c.collected.value = true&#10;                    totalScore += 1&#10;                    currentSessionScore += 1&#10;                    // add bag coin display (will be animated in UI)&#10;                    val bag = BagCoinDisplay(c.x, c.y.value, 1)&#10;                    bagCoins.add(bag)&#10;                    // update backend&#10;                    if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Monster collision (direct hit) ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            monsters.forEach { m -&gt;&#10;                if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp;&#10;                    CollisionUtils.checkCollisionPlaneMonster(planeX, planeY, planeWidth, planeHeight, m)&#10;                ) {&#10;                    if (!shieldActive &amp;&amp; !wallActive) planeHp -= 50&#10;                    // kill this monster&#10;                    m.hp.value = 0&#10;                    m.alive.value = false&#10;                }&#10;            }&#10;            if (planeHp &lt;= 0) isGameOver = true&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Wall - Monster collision (wall damages monsters) ---&#10;    LaunchedEffect(wallActive, isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            if (wallActive) {&#10;                monsters.forEach { m -&gt;&#10;                    if (m.alive.value &amp;&amp; m.hp.value &gt; 0) {&#10;                        val isColliding = CollisionUtils.checkCollisionWallMonster(planeY, m)&#10;                        if (isColliding) {&#10;                            // Wall drains monster HP continuously&#10;                            m.hp.value -= 2 // Drain 2 HP per tick&#10;                            if (m.hp.value &lt;= 0) {&#10;                                m.alive.value = false&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(50) // Check every 50ms&#10;        }&#10;    }&#10;&#10;    // --- Use chest item wrapper ---&#10;    fun useChestItem(item: ChestItem) {&#10;        ChestItemEffectsBase.applyItemEffect(&#10;            itemName = item.name,&#10;            monsters = monsters,&#10;            coins = coins,&#10;            bagCoins = bagCoins,&#10;            coroutineScope = coroutineScope,&#10;            screenHeightPx = screenHeightPx,&#10;            planeX = planeX,&#10;            onScoreUpdate = { add -&gt;&#10;                totalScore += add&#10;                currentSessionScore += add&#10;                if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;            },&#10;            onShieldToggle = { active -&gt; shieldActive = active },&#10;            onWallToggle = { active -&gt; wallActive = active },&#10;            onTimeToggle = { active -&gt; timeActive = active },&#10;            onLevelClear = { isLevelClear = true }&#10;        )&#10;        chestItems = chestItems - item&#10;        if (!playerName.isNullOrBlank()) FirebaseHelper.updateChest(playerName, chestItems)&#10;    }&#10;&#10;    // --- Drag plane ---&#10;    val dragModifier = Modifier.pointerInput(Unit) {&#10;        detectDragGestures { change, dragAmount -&gt;&#10;            planeX = (planeX + dragAmount.x).coerceIn(0f, screenWidthPx - planeWidth)&#10;            change.consume()&#10;        }&#10;    }&#10;&#10;    // --- UI ---&#10;    Box(modifier = Modifier.fillMaxSize().then(dragModifier)) {&#10;        // background layers (sliding)&#10;        Image(&#10;            painter = painterResource(R.drawable.nen2),&#10;            contentDescription = null,&#10;            modifier = Modifier&#10;                .absoluteOffset { IntOffset(0, bg1Y.roundToInt()) }&#10;                .fillMaxSize()&#10;        )&#10;        Image(&#10;            painter = painterResource(R.drawable.nen2),&#10;            contentDescription = null,&#10;            modifier = Modifier&#10;                .absoluteOffset { IntOffset(0, bg2Y.roundToInt()) }&#10;                .fillMaxSize()&#10;        )&#10;&#10;        // --- Monsters (using MonsterUI component) ---&#10;        monsters.forEach { m -&gt;&#10;            MonsterUI(monster = m)&#10;        }&#10;&#10;        // --- Coins ---&#10;        coins.filter { !it.collected.value }.forEach { c -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.coin),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(c.x.roundToInt(), c.y.value.roundToInt()) }&#10;                    .size(40.dp)&#10;            )&#10;        }&#10;&#10;        // --- BagCoin animated views (spawned when coin collected) ---&#10;        bagCoins.toList().forEach { bag -&gt;&#10;            BagCoinAnimatedView(bag = bag, onFinished = { finishedBag -&gt;&#10;                bagCoins.remove(finishedBag)&#10;            })&#10;        }&#10;&#10;        // --- Bullets ---&#10;        bullets.forEach { b -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.dan2),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(b.x.roundToInt(), b.y.roundToInt()) }&#10;                    .size(30.dp)&#10;            )&#10;        }&#10;&#10;        // --- Plane (using PlaneUI component) ---&#10;        PlaneUI(&#10;            planeX = planeX,&#10;            planeY = planeY,&#10;            planeHp = planeHp,&#10;            shieldActive = shieldActive&#10;        )&#10;&#10;        // --- Wall effect (using WallUI component) ---&#10;        if (wallActive) {&#10;            WallUI(planeY = planeY)&#10;        }&#10;&#10;        // --- Top bar with chest items and score ---&#10;        TopBarUI(&#10;            bagCoinScore = totalScore,&#10;            chestItems = chestItems,&#10;            onBuyItem = { item, price -&gt;&#10;                if (totalScore &gt;= price) {&#10;                    totalScore -= price&#10;                    chestItems = chestItems + item&#10;                    if (!playerName.isNullOrBlank()) {&#10;                        FirebaseHelper.updateScore(playerName, totalScore)&#10;                        FirebaseHelper.updateChest(playerName, chestItems)&#10;                    }&#10;                }&#10;            },&#10;            onUseChestItem = { useChestItem(it) }&#10;        )&#10;&#10;        // --- Sound Control Button (top-right corner) ---&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp),&#10;            contentAlignment = Alignment.TopEnd&#10;        ) {&#10;            SoundControlButton()&#10;        }&#10;    }&#10;&#10;    // --- Game End Dialog ---&#10;    if (showGameEndDialog) {&#10;        GameEndDialog(&#10;            isWin = isLevelClear,&#10;            score = currentSessionScore,&#10;            level = 1,&#10;            onDismiss = {&#10;                showGameEndDialog = false&#10;            },&#10;            onReplay = {&#10;                // Reset game state to replay&#10;                showGameEndDialog = false&#10;                isGameOver = false&#10;                isLevelClear = false&#10;                planeHp = 100&#10;                currentSessionScore = 0&#10;&#10;                // Reset monsters&#10;                monsters.forEachIndexed { index, m -&gt;&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 100f)&#10;                    m.y.value = -Random.nextInt(200, 2000).toFloat()&#10;                    m.hp.value = 100&#10;                    m.alive.value = true&#10;                    monsterRespawnTimes[index] = 0L&#10;                }&#10;&#10;                // Reset coins&#10;                coins.forEach { c -&gt;&#10;                    c.collected.value = false&#10;                    c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                    c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                }&#10;&#10;                // Clear bullets&#10;                bullets.clear()&#10;            },&#10;            onNextLevel = {&#10;                // Navigate to next level handled by GameEndDialog itself&#10;                onExit() // Close this activity&#10;            },&#10;            onExit = {&#10;                // Back to main menu&#10;                onExit()&#10;            }&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/game/Level2Activity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/game/Level2Activity.kt" />
              <option name="originalContent" value="package com.example.game&#10;&#10;import android.os.Bundle&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.TopBarComponent.TopBarUI&#10;import com.example.game.core.*&#10;import com.example.game.ui.PlaneUI&#10;import com.example.game.ui.MonsterUI&#10;import com.example.game.ui.WallUI&#10;import com.example.game.ui.SoundControlButton&#10;import com.example.game.ui.BagCoinAnimatedView&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.*&#10;import kotlin.random.Random&#10;&#10;class Level2Activity : BaseGameActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        initAudio()&#10;&#10;        // Initialize AI Avoidance Helper for smart bullet dodging&#10;        AIAvoidanceHelper.init(this)&#10;&#10;        setContent {&#10;            val density = LocalDensity.current&#10;            val screenWidthPx = with(density) { LocalConfiguration.current.screenWidthDp.dp.toPx() }&#10;            val screenHeightPx = with(density) { LocalConfiguration.current.screenHeightDp.dp.toPx() }&#10;&#10;            Level2Game(&#10;                screenWidthPx = screenWidthPx,&#10;                screenHeightPx = screenHeightPx,&#10;                soundPool = soundPool,&#10;                shootSoundId = shootSoundId,&#10;                hitSoundId = hitSoundId,&#10;                onExit = { finish() }&#10;            )&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        AIAvoidanceHelper.release()&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Level2Game(&#10;    screenWidthPx: Float,&#10;    screenHeightPx: Float,&#10;    soundPool: android.media.SoundPool,&#10;    shootSoundId: Int,&#10;    hitSoundId: Int,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val playerName = PrefManager.getPlayerName(context)&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // --- State ---&#10;    var totalScore by remember { mutableStateOf(0) }&#10;    var currentSessionScore by remember { mutableStateOf(0) }&#10;    var planeHp by remember { mutableStateOf(100) }&#10;&#10;    var shieldActive by remember { mutableStateOf(false) }&#10;    var wallActive by remember { mutableStateOf(false) }&#10;    var timeActive by remember { mutableStateOf(false) }&#10;&#10;    var isGameOver by remember { mutableStateOf(false) }&#10;    var isLevelClear by remember { mutableStateOf(false) }&#10;    var showGameEndDialog by remember { mutableStateOf(false) }&#10;&#10;    // Show dialog when game ends instead of navigating to new activity&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        if (isGameOver || isLevelClear) {&#10;            delay(500)&#10;            showGameEndDialog = true&#10;        }&#10;    }&#10;&#10;    // --- Plane setup ---&#10;    var planeX by remember { mutableStateOf(screenWidthPx / 2 - 50f) }&#10;    val planeY = screenHeightPx - 250f&#10;    val planeWidth = 100f&#10;    val planeHeight = 100f&#10;&#10;    // --- Background ---&#10;    var bg1Y by remember { mutableStateOf(0f) }&#10;    var bg2Y by remember { mutableStateOf(-screenHeightPx) }&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bg1Y += 4f&#10;            bg2Y += 4f&#10;            if (bg1Y &gt;= screenHeightPx) bg1Y = bg2Y - screenHeightPx&#10;            if (bg2Y &gt;= screenHeightPx) bg2Y = bg1Y - screenHeightPx&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Entities: 5 rotating monster groups ---&#10;    val monsterGroups = remember {&#10;        List(5) { i -&gt;&#10;            RotatingMonsterGroup(&#10;                centerX = Random.nextFloat() * (screenWidthPx - 300f) + 150f, // Random X position&#10;                centerY = -300f, // Start just above screen&#10;                radius = 100f,&#10;                angleOffset = Random.nextFloat() * 360f, // Random starting angle&#10;                vx = if (Random.nextBoolean()) Random.nextFloat() * 2f + 2f else -(Random.nextFloat() * 2f + 2f),&#10;                vy = Random.nextFloat() * 2f + 3f // Random vertical speed (3-5f)&#10;            ).apply {&#10;                // Initially set monsters as dead - they will spawn with delay&#10;                monsters.forEach { it.alive.value = false }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Track respawn times for each group&#10;    val groupRespawnTimes = remember { MutableList(monsterGroups.size) { i -&gt; System.currentTimeMillis() + (i * 3000L) } }&#10;&#10;    val coins = remember {&#10;        List(7) {&#10;            BaseCoin(&#10;                x = Random.nextFloat() * (screenWidthPx - 50f),&#10;                y = mutableStateOf(-Random.nextInt(100, 800).toFloat()),&#10;                speed = Random.nextFloat() * 2f + 1.5f&#10;            )&#10;        }&#10;    }&#10;&#10;    val bullets = remember { mutableStateListOf&lt;Bullet&gt;() }&#10;    val bagCoins = remember { mutableStateListOf&lt;BagCoinDisplay&gt;() }&#10;    var chestItems by remember { mutableStateOf&lt;List&lt;ChestItem&gt;&gt;(emptyList()) }&#10;&#10;    // --- Load player data ---&#10;    LaunchedEffect(Unit) {&#10;        if (!playerName.isNullOrBlank()) {&#10;            FirebaseHelper.syncNewPlayer(playerName)&#10;            FirebaseHelper.getScore(playerName) { totalScore = it }&#10;            FirebaseHelper.getChestItems(playerName) { chestItems = it }&#10;        }&#10;    }&#10;&#10;    // --- Shooting ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.add(Bullet(planeX + planeWidth / 2 - 15f, planeY))&#10;            SoundManager.playSoundEffect(soundPool, shootSoundId, 0.5f)&#10;            delay(300)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.forEach { it.y -= 25f }&#10;            bullets.removeAll { it.y &lt; -50f }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Monster groups movement + rotation ---&#10;    monsterGroups.forEachIndexed { index, group -&gt;&#10;        LaunchedEffect(group, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                // Check if group needs to respawn&#10;                val allDead = group.monsters.all { !it.alive.value }&#10;                if (allDead &amp;&amp; System.currentTimeMillis() &gt;= groupRespawnTimes[index]) {&#10;                    // Respawn group at random position&#10;                    group.centerX = Random.nextFloat() * (screenWidthPx - 300f) + 150f&#10;                    group.centerY = -300f&#10;                    group.vx = if (Random.nextBoolean()) Random.nextFloat() * 2f + 2f else -(Random.nextFloat() * 2f + 2f)&#10;                    group.vy = Random.nextFloat() * 2f + 3f&#10;                    group.angleOffset = Random.nextFloat() * 360f // Random rotation angle&#10;                    group.monsters.forEach { m -&gt;&#10;                        m.hp.value = 100&#10;                        m.alive.value = true&#10;                    }&#10;                    // Update positions to match new center and angle&#10;                    group.updatePositions()&#10;                    // Set next respawn time with random delay (3-5 seconds)&#10;                    groupRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 5000)&#10;                }&#10;&#10;                if (!timeActive &amp;&amp; !allDead) {&#10;                    // Rotate monsters&#10;                    group.angleOffset += 3f&#10;&#10;                    // Move center&#10;                    group.centerX += group.vx&#10;                    group.centerY += group.vy&#10;&#10;                    // Bounce off LEFT wall - reverse to RIGHT&#10;                    if (group.centerX &lt;= 150f) {&#10;                        group.centerX = 150f&#10;                        group.vx = abs(group.vx) // Bounce to opposite direction (right)&#10;                    }&#10;&#10;                    // Bounce off RIGHT wall - reverse to LEFT&#10;                    if (group.centerX &gt;= screenWidthPx - 150f) {&#10;                        group.centerX = screenWidthPx - 150f&#10;                        group.vx = -abs(group.vx) // Bounce to opposite direction (left)&#10;                    }&#10;&#10;                    // Bounce off TOP - reverse to DOWN&#10;                    if (group.centerY &lt;= 150f) {&#10;                        group.centerY = 150f&#10;                        group.vy = abs(group.vy) // Bounce to opposite direction (down)&#10;                    }&#10;&#10;                    // Bounce off BOTTOM - reverse to UP&#10;                    if (group.centerY &gt;= screenHeightPx - 300f) {&#10;                        group.centerY = screenHeightPx - 300f&#10;                        group.vy = -abs(group.vy) // Bounce to opposite direction (up)&#10;                    }&#10;&#10;                    // Update monster positions&#10;                    group.updatePositions()&#10;&#10;                    // Respawn if group goes way off screen (safety check)&#10;                    if (group.centerY &gt; screenHeightPx + 500f || group.centerY &lt; -1000f) {&#10;                        groupRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(2000, 5000)&#10;                        group.monsters.forEach { it.alive.value = false }&#10;                    }&#10;                }&#10;                delay(16)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Coin movement ---&#10;    coins.forEach { c -&gt;&#10;        LaunchedEffect(c, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                if (!c.collected.value &amp;&amp; !timeActive) {&#10;                    c.y.value += c.speed&#10;                    if (c.y.value &gt; screenHeightPx) {&#10;                        c.y.value = -Random.nextInt(100, 800).toFloat()&#10;                        c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                    }&#10;                }&#10;                delay(32)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Bullet vs Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            val iter = bullets.iterator()&#10;            while (iter.hasNext()) {&#10;                val b = iter.next()&#10;                monsterGroups.forEach { group -&gt;&#10;                    group.monsters.forEach { m -&gt;&#10;                        if (CollisionUtils.checkCollisionBulletMonster(b, m)) {&#10;                            m.hp.value -= 25&#10;                            // Play hit sound&#10;                            SoundManager.playSoundEffect(soundPool, hitSoundId, 0.3f)&#10;                            iter.remove()&#10;                            if (m.hp.value &lt;= 0) {&#10;                                m.alive.value = false&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Coin collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            coins.forEach { c -&gt;&#10;                if (!c.collected.value &amp;&amp; CollisionUtils.checkCollisionPlaneCoin(planeX, planeY, planeWidth, planeHeight, c)) {&#10;                    c.collected.value = true&#10;                    totalScore += 1&#10;                    currentSessionScore += 1&#10;                    val bag = BagCoinDisplay(c.x, c.y.value, 1)&#10;                    bagCoins.add(bag)&#10;                    if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            monsterGroups.forEach { group -&gt;&#10;                group.monsters.forEach { m -&gt;&#10;                    if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp;&#10;                        CollisionUtils.checkCollisionPlaneMonster(planeX, planeY, planeWidth, planeHeight, m)&#10;                    ) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) planeHp -= 50&#10;                        m.hp.value = 0&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;            }&#10;            if (planeHp &lt;= 0) isGameOver = true&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Wall - Monster collision ---&#10;    LaunchedEffect(wallActive, isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            if (wallActive) {&#10;                monsterGroups.forEach { group -&gt;&#10;                    group.monsters.forEach { m -&gt;&#10;                        if (m.alive.value &amp;&amp; m.hp.value &gt; 0) {&#10;                            if (CollisionUtils.checkCollisionWallMonster(planeY, m)) {&#10;                                m.hp.value -= 2&#10;                                if (m.hp.value &lt;= 0) {&#10;                                    m.alive.value = false&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Use chest item ---&#10;    fun useChestItem(item: ChestItem) {&#10;        // Flatten all monsters from groups for ChestItemEffectsBase&#10;        val allMonsters = monsterGroups.flatMap { it.monsters }&#10;        ChestItemEffectsBase.applyItemEffect(&#10;            itemName = item.name,&#10;            monsters = allMonsters,&#10;            coins = coins,&#10;            bagCoins = bagCoins,&#10;            coroutineScope = coroutineScope,&#10;            screenHeightPx = screenHeightPx,&#10;            planeX = planeX,&#10;            onScoreUpdate = { add -&gt;&#10;                totalScore += add&#10;                currentSessionScore += add&#10;                if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;            },&#10;            onShieldToggle = { active -&gt; shieldActive = active },&#10;            onWallToggle = { active -&gt; wallActive = active },&#10;            onTimeToggle = { active -&gt; timeActive = active },&#10;            onLevelClear = { isLevelClear = true }&#10;        )&#10;        chestItems = chestItems - item&#10;        if (!playerName.isNullOrBlank()) FirebaseHelper.updateChest(playerName, chestItems)&#10;    }&#10;&#10;    // --- Drag plane ---&#10;    val dragModifier = Modifier.pointerInput(Unit) {&#10;        detectDragGestures { change, dragAmount -&gt;&#10;            planeX = (planeX + dragAmount.x).coerceIn(0f, screenWidthPx - planeWidth)&#10;            change.consume()&#10;        }&#10;    }&#10;&#10;    // --- UI ---&#10;    Box(modifier = Modifier.fillMaxSize().then(dragModifier)) {&#10;        // Background&#10;        Image(&#10;            painter = painterResource(R.drawable.nen2),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg1Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;        Image(&#10;            painter = painterResource(R.drawable.nen2),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg2Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;&#10;        // Monsters (using MonsterUI component)&#10;        monsterGroups.forEach { group -&gt;&#10;            group.monsters.forEach { m -&gt;&#10;                MonsterUI(monster = m)&#10;            }&#10;        }&#10;&#10;        // Coins&#10;        coins.filter { !it.collected.value }.forEach { c -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.coin),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(c.x.roundToInt(), c.y.value.roundToInt()) }&#10;                    .size(40.dp)&#10;            )&#10;        }&#10;&#10;        // BagCoin animated views&#10;        bagCoins.toList().forEach { bag -&gt;&#10;            BagCoinAnimatedView(bag = bag, onFinished = { finishedBag -&gt;&#10;                bagCoins.remove(finishedBag)&#10;            })&#10;        }&#10;&#10;        // Bullets&#10;        bullets.forEach { b -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.dan2),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(b.x.roundToInt(), b.y.roundToInt()) }&#10;                    .size(30.dp)&#10;            )&#10;        }&#10;&#10;        // Plane (using PlaneUI component)&#10;        PlaneUI(&#10;            planeX = planeX,&#10;            planeY = planeY,&#10;            planeHp = planeHp,&#10;            shieldActive = shieldActive&#10;        )&#10;&#10;        // Wall (using WallUI component)&#10;        if (wallActive) {&#10;            WallUI(planeY = planeY)&#10;        }&#10;&#10;        // Top bar&#10;        TopBarUI(&#10;            bagCoinScore = totalScore,&#10;            chestItems = chestItems,&#10;            onBuyItem = { item, price -&gt;&#10;                if (totalScore &gt;= price) {&#10;                    totalScore -= price&#10;                    chestItems = chestItems + item&#10;                    if (!playerName.isNullOrBlank()) {&#10;                        FirebaseHelper.updateScore(playerName, totalScore)&#10;                        FirebaseHelper.updateChest(playerName, chestItems)&#10;                    }&#10;                }&#10;            },&#10;            onUseChestItem = { useChestItem(it) }&#10;        )&#10;&#10;        // --- Sound Control Button (top-right corner) ---&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp),&#10;            contentAlignment = Alignment.TopEnd&#10;        ) {&#10;            SoundControlButton()&#10;        }&#10;    }&#10;&#10;    // --- Game End Dialog ---&#10;    if (showGameEndDialog) {&#10;        GameEndDialog(&#10;            isWin = isLevelClear,&#10;            score = currentSessionScore,&#10;            level = 2,&#10;            onDismiss = {&#10;                showGameEndDialog = false&#10;            },&#10;            onReplay = {&#10;                // Reset game state to replay&#10;                showGameEndDialog = false&#10;                isGameOver = false&#10;                isLevelClear = false&#10;                planeHp = 100&#10;                currentSessionScore = 0&#10;&#10;                // Reset monsters&#10;                monsterGroups.forEach { group -&gt;&#10;                    group.centerX = Random.nextFloat() * (screenWidthPx - 300f) + 150f&#10;                    group.centerY = -300f&#10;                    group.vx = if (Random.nextBoolean()) Random.nextFloat() * 2f + 2f else -(Random.nextFloat() * 2f + 2f)&#10;                    group.vy = Random.nextFloat() * 2f + 3f&#10;                    group.angleOffset = Random.nextFloat() * 360f&#10;                    group.monsters.forEach { m -&gt;&#10;                        m.hp.value = 100&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;&#10;                // Reset respawn times&#10;                for (i in groupRespawnTimes.indices) {&#10;                    groupRespawnTimes[i] = System.currentTimeMillis() + (i * 3000L)&#10;                }&#10;&#10;                // Reset coins&#10;                coins.forEach { c -&gt;&#10;                    c.collected.value = false&#10;                    c.y.value = -Random.nextInt(100, 800).toFloat()&#10;                    c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                }&#10;&#10;                // Clear bullets&#10;                bullets.clear()&#10;            },&#10;            onNextLevel = {&#10;                // Navigate to next level handled by GameEndDialog itself&#10;                onExit() // Close this activity&#10;            },&#10;            onExit = {&#10;                // Back to main menu&#10;                onExit()&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * Rotating Monster Group - 3 monsters rotating around a center point&#10; */&#10;class RotatingMonsterGroup(&#10;    var centerX: Float,&#10;    var centerY: Float,&#10;    var radius: Float,&#10;    var angleOffset: Float,&#10;    var vx: Float, // velocity X&#10;    var vy: Float  // velocity Y&#10;) {&#10;    val monsters = List(3) { i -&gt;&#10;        val angle = angleOffset + i * 120f&#10;        val rad = Math.toRadians(angle.toDouble())&#10;        BaseMonster(&#10;            x = (centerX + cos(rad) * radius).toFloat(),&#10;            y = mutableStateOf((centerY + sin(rad) * radius).toFloat()),&#10;            speed = 0f,&#10;            hp = mutableStateOf(100)&#10;        )&#10;    }&#10;&#10;    fun updatePositions() {&#10;        val angles = listOf(0f, 120f, 240f)&#10;        monsters.forEachIndexed { i, m -&gt;&#10;            if (m.alive.value) {&#10;                val rad = Math.toRadians((angleOffset + angles[i]).toDouble())&#10;                m.x = (centerX + cos(rad) * radius).toFloat()&#10;                m.y.value = (centerY + sin(rad) * radius).toFloat()&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.game&#10;&#10;import android.os.Bundle&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.TopBarComponent.TopBarUI&#10;import com.example.game.core.*&#10;import com.example.game.ui.PlaneUI&#10;import com.example.game.ui.MonsterUI&#10;import com.example.game.ui.WallUI&#10;import com.example.game.ui.SoundControlButton&#10;import com.example.game.ui.BagCoinAnimatedView&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.*&#10;import kotlin.random.Random&#10;&#10;class Level2Activity : BaseGameActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        initAudio()&#10;&#10;        // Initialize AI Avoidance Helper for smart bullet dodging&#10;        try {&#10;            AIAvoidanceHelper.init(this)&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;Level2Activity&quot;, &quot;AI init failed: ${e.message}&quot;, e)&#10;            // Continue without AI - game will still work with basic logic&#10;        }&#10;&#10;        setContent {&#10;            val density = LocalDensity.current&#10;            val screenWidthPx = with(density) { LocalConfiguration.current.screenWidthDp.dp.toPx() }&#10;            val screenHeightPx = with(density) { LocalConfiguration.current.screenHeightDp.dp.toPx() }&#10;&#10;            Level2Game(&#10;                screenWidthPx = screenWidthPx,&#10;                screenHeightPx = screenHeightPx,&#10;                soundPool = soundPool,&#10;                shootSoundId = shootSoundId,&#10;                hitSoundId = hitSoundId,&#10;                onExit = { finish() }&#10;            )&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        try {&#10;            AIAvoidanceHelper.release()&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;Level2Activity&quot;, &quot;AI release failed: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Level2Game(&#10;    screenWidthPx: Float,&#10;    screenHeightPx: Float,&#10;    soundPool: android.media.SoundPool,&#10;    shootSoundId: Int,&#10;    hitSoundId: Int,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val playerName = PrefManager.getPlayerName(context)&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // --- State ---&#10;    var totalScore by remember { mutableStateOf(0) }&#10;    var currentSessionScore by remember { mutableStateOf(0) }&#10;    var planeHp by remember { mutableStateOf(100) }&#10;&#10;    var shieldActive by remember { mutableStateOf(false) }&#10;    var wallActive by remember { mutableStateOf(false) }&#10;    var timeActive by remember { mutableStateOf(false) }&#10;&#10;    var isGameOver by remember { mutableStateOf(false) }&#10;    var isLevelClear by remember { mutableStateOf(false) }&#10;    var showGameEndDialog by remember { mutableStateOf(false) }&#10;&#10;    // Show dialog when game ends instead of navigating to new activity&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        if (isGameOver || isLevelClear) {&#10;            delay(500)&#10;            showGameEndDialog = true&#10;        }&#10;    }&#10;&#10;    // --- Plane setup ---&#10;    var planeX by remember { mutableStateOf(screenWidthPx / 2 - 50f) }&#10;    val planeY = screenHeightPx - 250f&#10;    val planeWidth = 100f&#10;    val planeHeight = 100f&#10;&#10;    // --- Background ---&#10;    var bg1Y by remember { mutableStateOf(0f) }&#10;    var bg2Y by remember { mutableStateOf(-screenHeightPx) }&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bg1Y += 4f&#10;            bg2Y += 4f&#10;            if (bg1Y &gt;= screenHeightPx) bg1Y = bg2Y - screenHeightPx&#10;            if (bg2Y &gt;= screenHeightPx) bg2Y = bg1Y - screenHeightPx&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Entities: 5 rotating monster groups ---&#10;    val monsterGroups = remember {&#10;        List(5) { i -&gt;&#10;            RotatingMonsterGroup(&#10;                centerX = Random.nextFloat() * (screenWidthPx - 300f) + 150f, // Random X position&#10;                centerY = -300f, // Start just above screen&#10;                radius = 100f,&#10;                angleOffset = Random.nextFloat() * 360f, // Random starting angle&#10;                vx = if (Random.nextBoolean()) Random.nextFloat() * 2f + 2f else -(Random.nextFloat() * 2f + 2f),&#10;                vy = Random.nextFloat() * 2f + 3f // Random vertical speed (3-5f)&#10;            ).apply {&#10;                // Initially set monsters as dead - they will spawn with delay&#10;                monsters.forEach { it.alive.value = false }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Track respawn times for each group&#10;    val groupRespawnTimes = remember { MutableList(monsterGroups.size) { i -&gt; System.currentTimeMillis() + (i * 3000L) } }&#10;&#10;    val coins = remember {&#10;        List(7) {&#10;            BaseCoin(&#10;                x = Random.nextFloat() * (screenWidthPx - 50f),&#10;                y = mutableStateOf(-Random.nextInt(100, 800).toFloat()),&#10;                speed = Random.nextFloat() * 2f + 1.5f&#10;            )&#10;        }&#10;    }&#10;&#10;    val bullets = remember { mutableStateListOf&lt;Bullet&gt;() }&#10;    val bagCoins = remember { mutableStateListOf&lt;BagCoinDisplay&gt;() }&#10;    var chestItems by remember { mutableStateOf&lt;List&lt;ChestItem&gt;&gt;(emptyList()) }&#10;&#10;    // --- Load player data ---&#10;    LaunchedEffect(Unit) {&#10;        if (!playerName.isNullOrBlank()) {&#10;            FirebaseHelper.syncNewPlayer(playerName)&#10;            FirebaseHelper.getScore(playerName) { totalScore = it }&#10;            FirebaseHelper.getChestItems(playerName) { chestItems = it }&#10;        }&#10;    }&#10;&#10;    // --- Shooting ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.add(Bullet(planeX + planeWidth / 2 - 15f, planeY))&#10;            SoundManager.playSoundEffect(soundPool, shootSoundId, 0.5f)&#10;            delay(300)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.forEach { it.y -= 25f }&#10;            bullets.removeAll { it.y &lt; -50f }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Monster groups movement + rotation ---&#10;    monsterGroups.forEachIndexed { index, group -&gt;&#10;        LaunchedEffect(group, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                // Check if group needs to respawn&#10;                val allDead = group.monsters.all { !it.alive.value }&#10;                if (allDead &amp;&amp; System.currentTimeMillis() &gt;= groupRespawnTimes[index]) {&#10;                    // Respawn group at random position&#10;                    group.centerX = Random.nextFloat() * (screenWidthPx - 300f) + 150f&#10;                    group.centerY = -300f&#10;                    group.vx = if (Random.nextBoolean()) Random.nextFloat() * 2f + 2f else -(Random.nextFloat() * 2f + 2f)&#10;                    group.vy = Random.nextFloat() * 2f + 3f&#10;                    group.angleOffset = Random.nextFloat() * 360f // Random rotation angle&#10;                    group.monsters.forEach { m -&gt;&#10;                        m.hp.value = 100&#10;                        m.alive.value = true&#10;                    }&#10;                    // Update positions to match new center and angle&#10;                    group.updatePositions()&#10;                    // Set next respawn time with random delay (3-5 seconds)&#10;                    groupRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 5000)&#10;                }&#10;&#10;                if (!timeActive &amp;&amp; !allDead) {&#10;                    // Rotate monsters&#10;                    group.angleOffset += 3f&#10;&#10;                    // Move center&#10;                    group.centerX += group.vx&#10;                    group.centerY += group.vy&#10;&#10;                    // Bounce off LEFT wall - reverse to RIGHT&#10;                    if (group.centerX &lt;= 150f) {&#10;                        group.centerX = 150f&#10;                        group.vx = abs(group.vx) // Bounce to opposite direction (right)&#10;                    }&#10;&#10;                    // Bounce off RIGHT wall - reverse to LEFT&#10;                    if (group.centerX &gt;= screenWidthPx - 150f) {&#10;                        group.centerX = screenWidthPx - 150f&#10;                        group.vx = -abs(group.vx) // Bounce to opposite direction (left)&#10;                    }&#10;&#10;                    // Bounce off TOP - reverse to DOWN&#10;                    if (group.centerY &lt;= 150f) {&#10;                        group.centerY = 150f&#10;                        group.vy = abs(group.vy) // Bounce to opposite direction (down)&#10;                    }&#10;&#10;                    // Bounce off BOTTOM - reverse to UP&#10;                    if (group.centerY &gt;= screenHeightPx - 300f) {&#10;                        group.centerY = screenHeightPx - 300f&#10;                        group.vy = -abs(group.vy) // Bounce to opposite direction (up)&#10;                    }&#10;&#10;                    // Update monster positions&#10;                    group.updatePositions()&#10;&#10;                    // Respawn if group goes way off screen (safety check)&#10;                    if (group.centerY &gt; screenHeightPx + 500f || group.centerY &lt; -1000f) {&#10;                        groupRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(2000, 5000)&#10;                        group.monsters.forEach { it.alive.value = false }&#10;                    }&#10;                }&#10;                delay(16)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Coin movement ---&#10;    coins.forEach { c -&gt;&#10;        LaunchedEffect(c, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                if (!c.collected.value &amp;&amp; !timeActive) {&#10;                    c.y.value += c.speed&#10;                    if (c.y.value &gt; screenHeightPx) {&#10;                        c.y.value = -Random.nextInt(100, 800).toFloat()&#10;                        c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                    }&#10;                }&#10;                delay(32)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Bullet vs Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            val iter = bullets.iterator()&#10;            while (iter.hasNext()) {&#10;                val b = iter.next()&#10;                monsterGroups.forEach { group -&gt;&#10;                    group.monsters.forEach { m -&gt;&#10;                        if (CollisionUtils.checkCollisionBulletMonster(b, m)) {&#10;                            m.hp.value -= 25&#10;                            // Play hit sound&#10;                            SoundManager.playSoundEffect(soundPool, hitSoundId, 0.3f)&#10;                            iter.remove()&#10;                            if (m.hp.value &lt;= 0) {&#10;                                m.alive.value = false&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Coin collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            coins.forEach { c -&gt;&#10;                if (!c.collected.value &amp;&amp; CollisionUtils.checkCollisionPlaneCoin(planeX, planeY, planeWidth, planeHeight, c)) {&#10;                    c.collected.value = true&#10;                    totalScore += 1&#10;                    currentSessionScore += 1&#10;                    val bag = BagCoinDisplay(c.x, c.y.value, 1)&#10;                    bagCoins.add(bag)&#10;                    if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            monsterGroups.forEach { group -&gt;&#10;                group.monsters.forEach { m -&gt;&#10;                    if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp;&#10;                        CollisionUtils.checkCollisionPlaneMonster(planeX, planeY, planeWidth, planeHeight, m)&#10;                    ) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) planeHp -= 50&#10;                        m.hp.value = 0&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;            }&#10;            if (planeHp &lt;= 0) isGameOver = true&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Wall - Monster collision ---&#10;    LaunchedEffect(wallActive, isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            if (wallActive) {&#10;                monsterGroups.forEach { group -&gt;&#10;                    group.monsters.forEach { m -&gt;&#10;                        if (m.alive.value &amp;&amp; m.hp.value &gt; 0) {&#10;                            if (CollisionUtils.checkCollisionWallMonster(planeY, m)) {&#10;                                m.hp.value -= 2&#10;                                if (m.hp.value &lt;= 0) {&#10;                                    m.alive.value = false&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Use chest item ---&#10;    fun useChestItem(item: ChestItem) {&#10;        // Flatten all monsters from groups for ChestItemEffectsBase&#10;        val allMonsters = monsterGroups.flatMap { it.monsters }&#10;        ChestItemEffectsBase.applyItemEffect(&#10;            itemName = item.name,&#10;            monsters = allMonsters,&#10;            coins = coins,&#10;            bagCoins = bagCoins,&#10;            coroutineScope = coroutineScope,&#10;            screenHeightPx = screenHeightPx,&#10;            planeX = planeX,&#10;            onScoreUpdate = { add -&gt;&#10;                totalScore += add&#10;                currentSessionScore += add&#10;                if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;            },&#10;            onShieldToggle = { active -&gt; shieldActive = active },&#10;            onWallToggle = { active -&gt; wallActive = active },&#10;            onTimeToggle = { active -&gt; timeActive = active },&#10;            onLevelClear = { isLevelClear = true }&#10;        )&#10;        chestItems = chestItems - item&#10;        if (!playerName.isNullOrBlank()) FirebaseHelper.updateChest(playerName, chestItems)&#10;    }&#10;&#10;    // --- Drag plane ---&#10;    val dragModifier = Modifier.pointerInput(Unit) {&#10;        detectDragGestures { change, dragAmount -&gt;&#10;            planeX = (planeX + dragAmount.x).coerceIn(0f, screenWidthPx - planeWidth)&#10;            change.consume()&#10;        }&#10;    }&#10;&#10;    // --- UI ---&#10;    Box(modifier = Modifier.fillMaxSize().then(dragModifier)) {&#10;        // Background&#10;        Image(&#10;            painter = painterResource(R.drawable.nen2),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg1Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;        Image(&#10;            painter = painterResource(R.drawable.nen2),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg2Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;&#10;        // Monsters (using MonsterUI component)&#10;        monsterGroups.forEach { group -&gt;&#10;            group.monsters.forEach { m -&gt;&#10;                MonsterUI(monster = m)&#10;            }&#10;        }&#10;&#10;        // Coins&#10;        coins.filter { !it.collected.value }.forEach { c -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.coin),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(c.x.roundToInt(), c.y.value.roundToInt()) }&#10;                    .size(40.dp)&#10;            )&#10;        }&#10;&#10;        // BagCoin animated views&#10;        bagCoins.toList().forEach { bag -&gt;&#10;            BagCoinAnimatedView(bag = bag, onFinished = { finishedBag -&gt;&#10;                bagCoins.remove(finishedBag)&#10;            })&#10;        }&#10;&#10;        // Bullets&#10;        bullets.forEach { b -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.dan2),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(b.x.roundToInt(), b.y.roundToInt()) }&#10;                    .size(30.dp)&#10;            )&#10;        }&#10;&#10;        // Plane (using PlaneUI component)&#10;        PlaneUI(&#10;            planeX = planeX,&#10;            planeY = planeY,&#10;            planeHp = planeHp,&#10;            shieldActive = shieldActive&#10;        )&#10;&#10;        // Wall (using WallUI component)&#10;        if (wallActive) {&#10;            WallUI(planeY = planeY)&#10;        }&#10;&#10;        // Top bar&#10;        TopBarUI(&#10;            bagCoinScore = totalScore,&#10;            chestItems = chestItems,&#10;            onBuyItem = { item, price -&gt;&#10;                if (totalScore &gt;= price) {&#10;                    totalScore -= price&#10;                    chestItems = chestItems + item&#10;                    if (!playerName.isNullOrBlank()) {&#10;                        FirebaseHelper.updateScore(playerName, totalScore)&#10;                        FirebaseHelper.updateChest(playerName, chestItems)&#10;                    }&#10;                }&#10;            },&#10;            onUseChestItem = { useChestItem(it) }&#10;        )&#10;&#10;        // --- Sound Control Button (top-right corner) ---&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp),&#10;            contentAlignment = Alignment.TopEnd&#10;        ) {&#10;            SoundControlButton()&#10;        }&#10;    }&#10;&#10;    // --- Game End Dialog ---&#10;    if (showGameEndDialog) {&#10;        GameEndDialog(&#10;            isWin = isLevelClear,&#10;            score = currentSessionScore,&#10;            level = 2,&#10;            onDismiss = {&#10;                showGameEndDialog = false&#10;            },&#10;            onReplay = {&#10;                // Reset game state to replay&#10;                showGameEndDialog = false&#10;                isGameOver = false&#10;                isLevelClear = false&#10;                planeHp = 100&#10;                currentSessionScore = 0&#10;&#10;                // Reset monsters&#10;                monsterGroups.forEach { group -&gt;&#10;                    group.centerX = Random.nextFloat() * (screenWidthPx - 300f) + 150f&#10;                    group.centerY = -300f&#10;                    group.vx = if (Random.nextBoolean()) Random.nextFloat() * 2f + 2f else -(Random.nextFloat() * 2f + 2f)&#10;                    group.vy = Random.nextFloat() * 2f + 3f&#10;                    group.angleOffset = Random.nextFloat() * 360f&#10;                    group.monsters.forEach { m -&gt;&#10;                        m.hp.value = 100&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;&#10;                // Reset respawn times&#10;                for (i in groupRespawnTimes.indices) {&#10;                    groupRespawnTimes[i] = System.currentTimeMillis() + (i * 3000L)&#10;                }&#10;&#10;                // Reset coins&#10;                coins.forEach { c -&gt;&#10;                    c.collected.value = false&#10;                    c.y.value = -Random.nextInt(100, 800).toFloat()&#10;                    c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                }&#10;&#10;                // Clear bullets&#10;                bullets.clear()&#10;            },&#10;            onNextLevel = {&#10;                // Navigate to next level handled by GameEndDialog itself&#10;                onExit() // Close this activity&#10;            },&#10;            onExit = {&#10;                // Back to main menu&#10;                onExit()&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * Rotating Monster Group - 3 monsters rotating around a center point&#10; */&#10;class RotatingMonsterGroup(&#10;    var centerX: Float,&#10;    var centerY: Float,&#10;    var radius: Float,&#10;    var angleOffset: Float,&#10;    var vx: Float, // velocity X&#10;    var vy: Float  // velocity Y&#10;) {&#10;    val monsters = List(3) { i -&gt;&#10;        val angle = angleOffset + i * 120f&#10;        val rad = Math.toRadians(angle.toDouble())&#10;        BaseMonster(&#10;            x = (centerX + cos(rad) * radius).toFloat(),&#10;            y = mutableStateOf((centerY + sin(rad) * radius).toFloat()),&#10;            speed = 0f,&#10;            hp = mutableStateOf(100)&#10;        )&#10;    }&#10;&#10;    fun updatePositions() {&#10;        val angles = listOf(0f, 120f, 240f)&#10;        monsters.forEachIndexed { i, m -&gt;&#10;            if (m.alive.value) {&#10;                val rad = Math.toRadians((angleOffset + angles[i]).toDouble())&#10;                m.x = (centerX + cos(rad) * radius).toFloat()&#10;                m.y.value = (centerY + sin(rad) * radius).toFloat()&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/game/Level4Activity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/game/Level4Activity.kt" />
              <option name="originalContent" value="package com.example.game&#10;&#10;import android.os.Bundle&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.TopBarComponent.TopBarUI&#10;import com.example.game.core.*&#10;import com.example.game.ui.PlaneUI&#10;import com.example.game.ui.WallUI&#10;import com.example.game.ui.GrowingMonsterUI&#10;import com.example.game.ui.SoundControlButton&#10;import com.example.game.ui.BagCoinAnimatedView&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.roundToInt&#10;import kotlin.random.Random&#10;&#10;class Level4Activity : BaseGameActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        initAudio()&#10;&#10;        // Initialize AI Avoidance Helper for smart bullet dodging&#10;        AIAvoidanceHelper.init(this)&#10;&#10;        setContent {&#10;            val density = LocalDensity.current&#10;            val screenWidthPx = with(density) { LocalConfiguration.current.screenWidthDp.dp.toPx() }&#10;            val screenHeightPx = with(density) { LocalConfiguration.current.screenHeightDp.dp.toPx() }&#10;&#10;            Level4Game(&#10;                screenWidthPx = screenWidthPx,&#10;                screenHeightPx = screenHeightPx,&#10;                soundPool = soundPool,&#10;                shootSoundId = shootSoundId,&#10;                hitSoundId = hitSoundId,&#10;                onExit = { finish() }&#10;            )&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        AIAvoidanceHelper.release()&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Level4Game(&#10;    screenWidthPx: Float,&#10;    screenHeightPx: Float,&#10;    soundPool: android.media.SoundPool,&#10;    shootSoundId: Int,&#10;    hitSoundId: Int,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val playerName = PrefManager.getPlayerName(context)&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // --- State ---&#10;    var totalScore by remember { mutableStateOf(0) }&#10;    var currentSessionScore by remember { mutableStateOf(0) }&#10;    var planeHp by remember { mutableStateOf(100) }&#10;&#10;    var shieldActive by remember { mutableStateOf(false) }&#10;    var wallActive by remember { mutableStateOf(false) }&#10;    var timeActive by remember { mutableStateOf(false) }&#10;&#10;    var isGameOver by remember { mutableStateOf(false) }&#10;    var isLevelClear by remember { mutableStateOf(false) }&#10;    var showGameEndDialog by remember { mutableStateOf(false) }&#10;&#10;    // Show dialog when game ends&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        if (isGameOver || isLevelClear) {&#10;            delay(500)&#10;            showGameEndDialog = true&#10;        }&#10;    }&#10;&#10;    // --- Plane setup ---&#10;    var planeX by remember { mutableStateOf(screenWidthPx / 2 - 50f) }&#10;    val planeY = screenHeightPx - 250f&#10;    val planeWidth = 100f&#10;    val planeHeight = 100f&#10;&#10;    // --- Background ---&#10;    var bg1Y by remember { mutableStateOf(0f) }&#10;    var bg2Y by remember { mutableStateOf(-screenHeightPx) }&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bg1Y += 4f&#10;            bg2Y += 4f&#10;            if (bg1Y &gt;= screenHeightPx) bg1Y = bg2Y - screenHeightPx&#10;            if (bg2Y &gt;= screenHeightPx) bg2Y = bg1Y - screenHeightPx&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Growing Monsters ---&#10;    val growingMonsters = remember {&#10;        List(10) {&#10;            GrowingMonster(&#10;                x = Random.nextFloat() * (screenWidthPx - 200f) + 100f,&#10;                y = mutableStateOf(-Random.nextInt(200, 2500).toFloat()),&#10;                speed = Random.nextFloat() * 1.2f + 1.0f,&#10;                hp = mutableStateOf(80),&#10;                initialSize = 60f,&#10;                maxSize = 600f,&#10;                growthRate = 0.5f&#10;            )&#10;        }&#10;    }&#10;&#10;    // Track respawn times&#10;    val monsterRespawnTimes = remember { MutableList(growingMonsters.size) { 0L } }&#10;&#10;    val coins = remember {&#10;        List(6) {&#10;            BaseCoin(&#10;                x = Random.nextFloat() * (screenWidthPx - 50f),&#10;                y = mutableStateOf(-Random.nextInt(100, 600).toFloat()),&#10;                speed = Random.nextFloat() * 2f + 1f&#10;            )&#10;        }&#10;    }&#10;&#10;    val bullets = remember { mutableStateListOf&lt;Bullet&gt;() }&#10;    val bagCoins = remember { mutableStateListOf&lt;BagCoinDisplay&gt;() }&#10;    var chestItems by remember { mutableStateOf&lt;List&lt;ChestItem&gt;&gt;(emptyList()) }&#10;&#10;    // --- Load player data ---&#10;    LaunchedEffect(Unit) {&#10;        if (!playerName.isNullOrBlank()) {&#10;            FirebaseHelper.syncNewPlayer(playerName)&#10;            FirebaseHelper.getChestItems(playerName) { chestItems = it }&#10;        }&#10;    }&#10;&#10;    // --- Shooting ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.add(Bullet(planeX + planeWidth / 2f - 15f, planeY))&#10;            SoundManager.playSoundEffect(soundPool, shootSoundId, 0.5f)&#10;            delay(300)&#10;        }&#10;    }&#10;&#10;    // --- Bullet movement ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.forEach { it.y -= 25f }&#10;            bullets.removeAll { it.y &lt; -50f }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Monster movement + growing + AI evasion ---&#10;    growingMonsters.forEachIndexed { index, m -&gt;&#10;        LaunchedEffect(m, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                // Check if monster needs to respawn&#10;                if (!m.alive.value &amp;&amp; System.currentTimeMillis() &gt;= monsterRespawnTimes[index]) {&#10;                    m.y.value = -Random.nextInt(200, 1500).toFloat()&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 200f) + 100f&#10;                    m.hp.value = 80&#10;                    m.maxHp = 80&#10;                    m.currentMaxHp.value = 80&#10;                    m.currentSize.value = m.initialSize&#10;                    m.alive.value = true&#10;                }&#10;&#10;                if (m.alive.value) {&#10;                    // AI-based evasion: monster tries to dodge bullets intelligently&#10;                    val evasion = AIAvoidanceHelper.calculateEvasion(&#10;                        monsterX = m.x,&#10;                        monsterY = m.y.value,&#10;                        monsterSize = m.currentSize.value,&#10;                        bullets = bullets,&#10;                        screenWidth = screenWidthPx&#10;                    )&#10;&#10;                    // Apply evasion movement (horizontal dodge)&#10;                    m.x = (m.x + evasion.first).coerceIn(0f, screenWidthPx - m.currentSize.value)&#10;&#10;                    // Grow over time&#10;                    m.grow()&#10;&#10;                    // Wall collision check&#10;                    val wallTop = planeY - 60f&#10;                    val monsterBottom = m.y.value + m.currentSize.value&#10;&#10;                    if (wallActive &amp;&amp; monsterBottom &gt;= wallTop) {&#10;                        // Stop at wall&#10;                    } else {&#10;                        // Normal downward movement&#10;                        m.y.value += m.speed&#10;                    }&#10;&#10;                    // If monster passes plane&#10;                    if (m.y.value &gt; planeY + planeHeight / 2f) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) {&#10;                            // Damage scales with monster size&#10;                            val damage = (30 * (m.currentSize.value / m.initialSize)).toInt()&#10;                            planeHp -= damage&#10;                        }&#10;                        monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 8000)&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;                delay(16)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Coin movement ---&#10;    coins.forEach { c -&gt;&#10;        LaunchedEffect(c, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                if (!c.collected.value &amp;&amp; !timeActive) {&#10;                    c.y.value += c.speed&#10;                    if (c.y.value &gt; screenHeightPx) {&#10;                        c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                        c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                    }&#10;                }&#10;                delay(32)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Bullet - Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            growingMonsters.forEach { m -&gt;&#10;                if (m.alive.value) {&#10;                    val iter = bullets.iterator()&#10;                    while (iter.hasNext()) {&#10;                        val b = iter.next()&#10;                        if (CollisionUtils.checkCollisionBulletMonster(b, m)) {&#10;                            m.hp.value -= 20&#10;                            SoundManager.playSoundEffect(soundPool, hitSoundId, 0.3f)&#10;                            iter.remove()&#10;                            if (m.hp.value &lt;= 0) {&#10;                                m.alive.value = false&#10;                                val index = growingMonsters.indexOf(m)&#10;                                if (index &gt;= 0) {&#10;                                    monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 8000)&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Coin collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            coins.forEach { c -&gt;&#10;                if (!c.collected.value &amp;&amp; CollisionUtils.checkCollisionPlaneCoin(planeX, planeY, planeWidth, planeHeight, c)) {&#10;                    c.collected.value = true&#10;                    totalScore += 1&#10;                    currentSessionScore += 1&#10;                    val bag = BagCoinDisplay(c.x, c.y.value, 1)&#10;                    bagCoins.add(bag)&#10;                    if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            growingMonsters.forEach { m -&gt;&#10;                if (m.alive.value &amp;&amp; CollisionUtils.checkCollisionPlaneMonster(planeX, planeY, planeWidth, planeHeight, m)) {&#10;                    if (!shieldActive) {&#10;                        val damage = (30 * (m.currentSize.value / m.initialSize)).toInt()&#10;                        planeHp -= damage&#10;                    }&#10;                    m.hp.value = 0&#10;                    m.alive.value = false&#10;                }&#10;            }&#10;            if (planeHp &lt;= 0) isGameOver = true&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Wall - Monster collision ---&#10;    LaunchedEffect(wallActive, isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            if (wallActive) {&#10;                growingMonsters.forEach { m -&gt;&#10;                    if (m.alive.value) {&#10;                        val wallTop = planeY - 60f&#10;                        val monsterBottom = m.y.value + m.currentSize.value&#10;                        if (monsterBottom &gt;= wallTop) {&#10;                            m.hp.value -= 2&#10;                            if (m.hp.value &lt;= 0) {&#10;                                m.alive.value = false&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Use chest item ---&#10;    fun useChestItem(item: ChestItem) {&#10;        ChestItemEffectsBase.applyItemEffect(&#10;            itemName = item.name,&#10;            monsters = growingMonsters,&#10;            coins = coins,&#10;            bagCoins = bagCoins,&#10;            coroutineScope = coroutineScope,&#10;            screenHeightPx = screenHeightPx,&#10;            planeX = planeX,&#10;            onScoreUpdate = { add -&gt;&#10;                totalScore += add&#10;                currentSessionScore += add&#10;                if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;            },&#10;            onShieldToggle = { active -&gt; shieldActive = active },&#10;            onWallToggle = { active -&gt; wallActive = active },&#10;            onTimeToggle = { active -&gt; timeActive = active },&#10;            onLevelClear = { isLevelClear = true }&#10;        )&#10;        chestItems = chestItems - item&#10;        if (!playerName.isNullOrBlank()) FirebaseHelper.updateChest(playerName, chestItems)&#10;    }&#10;&#10;    // --- Drag plane ---&#10;    val dragModifier = Modifier.pointerInput(Unit) {&#10;        detectDragGestures { change, dragAmount -&gt;&#10;            planeX = (planeX + dragAmount.x).coerceIn(0f, screenWidthPx - planeWidth)&#10;            change.consume()&#10;        }&#10;    }&#10;&#10;    // --- UI ---&#10;    Box(modifier = Modifier.fillMaxSize().then(dragModifier)) {&#10;        // Background&#10;        Image(&#10;            painter = painterResource(R.drawable.vutru1),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg1Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;        Image(&#10;            painter = painterResource(R.drawable.vutru1),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg2Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;&#10;        // Growing Monsters&#10;        growingMonsters.forEach { m -&gt;&#10;            GrowingMonsterUI(monster = m)&#10;        }&#10;&#10;        // Coins&#10;        coins.filter { !it.collected.value }.forEach { c -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.coin),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(c.x.roundToInt(), c.y.value.roundToInt()) }&#10;                    .size(40.dp)&#10;            )&#10;        }&#10;&#10;        // BagCoin animated views&#10;        bagCoins.toList().forEach { bag -&gt;&#10;            BagCoinAnimatedView(bag = bag, onFinished = { finishedBag -&gt;&#10;                bagCoins.remove(finishedBag)&#10;            })&#10;        }&#10;&#10;        // Bullets&#10;        bullets.forEach { b -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.dan2),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(b.x.roundToInt(), b.y.roundToInt()) }&#10;                    .size(30.dp)&#10;            )&#10;        }&#10;&#10;        // Plane&#10;        PlaneUI(&#10;            planeX = planeX,&#10;            planeY = planeY,&#10;            planeHp = planeHp,&#10;            shieldActive = shieldActive&#10;        )&#10;&#10;        // Wall&#10;        if (wallActive) {&#10;            WallUI(planeY = planeY)&#10;        }&#10;&#10;        // Top bar&#10;        TopBarUI(&#10;            bagCoinScore = totalScore,&#10;            chestItems = chestItems,&#10;            onBuyItem = { item, price -&gt;&#10;                if (totalScore &gt;= price) {&#10;                    totalScore -= price&#10;                    chestItems = chestItems + item&#10;                    if (!playerName.isNullOrBlank()) {&#10;                        FirebaseHelper.updateScore(playerName, totalScore)&#10;                        FirebaseHelper.updateChest(playerName, chestItems)&#10;                    }&#10;                }&#10;            },&#10;            onUseChestItem = { useChestItem(it) }&#10;        )&#10;&#10;        // --- Sound Control Button (top-right corner) ---&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp),&#10;            contentAlignment = androidx.compose.ui.Alignment.TopEnd&#10;        ) {&#10;            SoundControlButton()&#10;        }&#10;    }&#10;&#10;    // --- Game End Dialog ---&#10;    if (showGameEndDialog) {&#10;        GameEndDialog(&#10;            isWin = isLevelClear,&#10;            score = currentSessionScore,&#10;            level = 4,&#10;            onDismiss = {&#10;                showGameEndDialog = false&#10;            },&#10;            onReplay = {&#10;                // Reset game&#10;                showGameEndDialog = false&#10;                isGameOver = false&#10;                isLevelClear = false&#10;                planeHp = 100&#10;                currentSessionScore = 0&#10;&#10;                growingMonsters.forEachIndexed { index, m -&gt;&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 200f) + 100f&#10;                    m.y.value = -Random.nextInt(200, 2500).toFloat()&#10;                    m.hp.value = 80&#10;                    m.maxHp = 80&#10;                    m.currentMaxHp.value = 80&#10;                    m.currentSize.value = m.initialSize&#10;                    m.alive.value = true&#10;                    monsterRespawnTimes[index] = 0L&#10;                }&#10;&#10;                coins.forEach { c -&gt;&#10;                    c.collected.value = false&#10;                    c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                    c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                }&#10;&#10;                bullets.clear()&#10;            },&#10;            onNextLevel = {&#10;                onExit()&#10;            },&#10;            onExit = {&#10;                onExit()&#10;            }&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.game&#10;&#10;import android.os.Bundle&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.TopBarComponent.TopBarUI&#10;import com.example.game.core.*&#10;import com.example.game.ui.PlaneUI&#10;import com.example.game.ui.WallUI&#10;import com.example.game.ui.GrowingMonsterUI&#10;import com.example.game.ui.SoundControlButton&#10;import com.example.game.ui.BagCoinAnimatedView&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.roundToInt&#10;import kotlin.random.Random&#10;&#10;class Level4Activity : BaseGameActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        initAudio()&#10;&#10;        // Initialize AI Avoidance Helper for smart bullet dodging&#10;        try {&#10;            AIAvoidanceHelper.init(this)&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;Level4Activity&quot;, &quot;AI init failed: ${e.message}&quot;, e)&#10;            // Continue without AI - game will still work with basic logic&#10;        }&#10;&#10;        setContent {&#10;            val density = LocalDensity.current&#10;            val screenWidthPx = with(density) { LocalConfiguration.current.screenWidthDp.dp.toPx() }&#10;            val screenHeightPx = with(density) { LocalConfiguration.current.screenHeightDp.dp.toPx() }&#10;&#10;            Level4Game(&#10;                screenWidthPx = screenWidthPx,&#10;                screenHeightPx = screenHeightPx,&#10;                soundPool = soundPool,&#10;                shootSoundId = shootSoundId,&#10;                hitSoundId = hitSoundId,&#10;                onExit = { finish() }&#10;            )&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        try {&#10;            AIAvoidanceHelper.release()&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;Level4Activity&quot;, &quot;AI release failed: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Level4Game(&#10;    screenWidthPx: Float,&#10;    screenHeightPx: Float,&#10;    soundPool: android.media.SoundPool,&#10;    shootSoundId: Int,&#10;    hitSoundId: Int,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val playerName = PrefManager.getPlayerName(context)&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // --- State ---&#10;    var totalScore by remember { mutableStateOf(0) }&#10;    var currentSessionScore by remember { mutableStateOf(0) }&#10;    var planeHp by remember { mutableStateOf(100) }&#10;&#10;    var shieldActive by remember { mutableStateOf(false) }&#10;    var wallActive by remember { mutableStateOf(false) }&#10;    var timeActive by remember { mutableStateOf(false) }&#10;&#10;    var isGameOver by remember { mutableStateOf(false) }&#10;    var isLevelClear by remember { mutableStateOf(false) }&#10;    var showGameEndDialog by remember { mutableStateOf(false) }&#10;&#10;    // Show dialog when game ends&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        if (isGameOver || isLevelClear) {&#10;            delay(500)&#10;            showGameEndDialog = true&#10;        }&#10;    }&#10;&#10;    // --- Plane setup ---&#10;    var planeX by remember { mutableStateOf(screenWidthPx / 2 - 50f) }&#10;    val planeY = screenHeightPx - 250f&#10;    val planeWidth = 100f&#10;    val planeHeight = 100f&#10;&#10;    // --- Background ---&#10;    var bg1Y by remember { mutableStateOf(0f) }&#10;    var bg2Y by remember { mutableStateOf(-screenHeightPx) }&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bg1Y += 4f&#10;            bg2Y += 4f&#10;            if (bg1Y &gt;= screenHeightPx) bg1Y = bg2Y - screenHeightPx&#10;            if (bg2Y &gt;= screenHeightPx) bg2Y = bg1Y - screenHeightPx&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Growing Monsters ---&#10;    val growingMonsters = remember {&#10;        List(10) {&#10;            GrowingMonster(&#10;                x = Random.nextFloat() * (screenWidthPx - 200f) + 100f,&#10;                y = mutableStateOf(-Random.nextInt(200, 2500).toFloat()),&#10;                speed = Random.nextFloat() * 1.2f + 1.0f,&#10;                hp = mutableStateOf(80),&#10;                initialSize = 60f,&#10;                maxSize = 600f,&#10;                growthRate = 0.5f&#10;            )&#10;        }&#10;    }&#10;&#10;    // Track respawn times&#10;    val monsterRespawnTimes = remember { MutableList(growingMonsters.size) { 0L } }&#10;&#10;    val coins = remember {&#10;        List(6) {&#10;            BaseCoin(&#10;                x = Random.nextFloat() * (screenWidthPx - 50f),&#10;                y = mutableStateOf(-Random.nextInt(100, 600).toFloat()),&#10;                speed = Random.nextFloat() * 2f + 1f&#10;            )&#10;        }&#10;    }&#10;&#10;    val bullets = remember { mutableStateListOf&lt;Bullet&gt;() }&#10;    val bagCoins = remember { mutableStateListOf&lt;BagCoinDisplay&gt;() }&#10;    var chestItems by remember { mutableStateOf&lt;List&lt;ChestItem&gt;&gt;(emptyList()) }&#10;&#10;    // --- Load player data ---&#10;    LaunchedEffect(Unit) {&#10;        if (!playerName.isNullOrBlank()) {&#10;            FirebaseHelper.syncNewPlayer(playerName)&#10;            FirebaseHelper.getScore(playerName) { totalScore = it }&#10;            FirebaseHelper.getChestItems(playerName) { chestItems = it }&#10;        }&#10;    }&#10;&#10;    // --- Shooting ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.add(Bullet(planeX + planeWidth / 2f - 15f, planeY))&#10;            SoundManager.playSoundEffect(soundPool, shootSoundId, 0.5f)&#10;            delay(300)&#10;        }&#10;    }&#10;&#10;    // --- Bullet movement ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.forEach { it.y -= 25f }&#10;            bullets.removeAll { it.y &lt; -50f }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Monster movement + growing + AI evasion ---&#10;    growingMonsters.forEachIndexed { index, m -&gt;&#10;        LaunchedEffect(m, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                // Check if monster needs to respawn&#10;                if (!m.alive.value &amp;&amp; System.currentTimeMillis() &gt;= monsterRespawnTimes[index]) {&#10;                    m.y.value = -Random.nextInt(200, 1500).toFloat()&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 200f) + 100f&#10;                    m.hp.value = 80&#10;                    m.maxHp = 80&#10;                    m.currentMaxHp.value = 80&#10;                    m.currentSize.value = m.initialSize&#10;                    m.alive.value = true&#10;                }&#10;&#10;                if (m.alive.value) {&#10;                    // AI-based evasion: monster tries to dodge bullets intelligently&#10;                    val evasion = AIAvoidanceHelper.calculateEvasion(&#10;                        monsterX = m.x,&#10;                        monsterY = m.y.value,&#10;                        monsterSize = m.currentSize.value,&#10;                        bullets = bullets,&#10;                        screenWidth = screenWidthPx&#10;                    )&#10;&#10;                    // Apply evasion movement (horizontal dodge)&#10;                    m.x = (m.x + evasion.first).coerceIn(0f, screenWidthPx - m.currentSize.value)&#10;&#10;                    // Grow over time&#10;                    m.grow()&#10;&#10;                    // Wall collision check&#10;                    val wallTop = planeY - 60f&#10;                    val monsterBottom = m.y.value + m.currentSize.value&#10;&#10;                    if (wallActive &amp;&amp; monsterBottom &gt;= wallTop) {&#10;                        // Stop at wall&#10;                    } else {&#10;                        // Normal downward movement&#10;                        m.y.value += m.speed&#10;                    }&#10;&#10;                    // If monster passes plane&#10;                    if (m.y.value &gt; planeY + planeHeight / 2f) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) {&#10;                            // Damage scales with monster size&#10;                            val damage = (30 * (m.currentSize.value / m.initialSize)).toInt()&#10;                            planeHp -= damage&#10;                        }&#10;                        monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 8000)&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;                delay(16)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Coin movement ---&#10;    coins.forEach { c -&gt;&#10;        LaunchedEffect(c, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                if (!c.collected.value &amp;&amp; !timeActive) {&#10;                    c.y.value += c.speed&#10;                    if (c.y.value &gt; screenHeightPx) {&#10;                        c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                        c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                    }&#10;                }&#10;                delay(32)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Bullet - Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            growingMonsters.forEach { m -&gt;&#10;                if (m.alive.value) {&#10;                    val iter = bullets.iterator()&#10;                    while (iter.hasNext()) {&#10;                        val b = iter.next()&#10;                        if (CollisionUtils.checkCollisionBulletMonster(b, m)) {&#10;                            m.hp.value -= 20&#10;                            SoundManager.playSoundEffect(soundPool, hitSoundId, 0.3f)&#10;                            iter.remove()&#10;                            if (m.hp.value &lt;= 0) {&#10;                                m.alive.value = false&#10;                                val index = growingMonsters.indexOf(m)&#10;                                if (index &gt;= 0) {&#10;                                    monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 8000)&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Coin collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            coins.forEach { c -&gt;&#10;                if (!c.collected.value &amp;&amp; CollisionUtils.checkCollisionPlaneCoin(planeX, planeY, planeWidth, planeHeight, c)) {&#10;                    c.collected.value = true&#10;                    totalScore += 1&#10;                    currentSessionScore += 1&#10;                    val bag = BagCoinDisplay(c.x, c.y.value, 1)&#10;                    bagCoins.add(bag)&#10;                    if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            growingMonsters.forEach { m -&gt;&#10;                if (m.alive.value &amp;&amp; CollisionUtils.checkCollisionPlaneMonster(planeX, planeY, planeWidth, planeHeight, m)) {&#10;                    if (!shieldActive) {&#10;                        val damage = (30 * (m.currentSize.value / m.initialSize)).toInt()&#10;                        planeHp -= damage&#10;                    }&#10;                    m.hp.value = 0&#10;                    m.alive.value = false&#10;                }&#10;            }&#10;            if (planeHp &lt;= 0) isGameOver = true&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Wall - Monster collision ---&#10;    LaunchedEffect(wallActive, isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            if (wallActive) {&#10;                growingMonsters.forEach { m -&gt;&#10;                    if (m.alive.value) {&#10;                        val wallTop = planeY - 60f&#10;                        val monsterBottom = m.y.value + m.currentSize.value&#10;                        if (monsterBottom &gt;= wallTop) {&#10;                            m.hp.value -= 2&#10;                            if (m.hp.value &lt;= 0) {&#10;                                m.alive.value = false&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Use chest item ---&#10;    fun useChestItem(item: ChestItem) {&#10;        ChestItemEffectsBase.applyItemEffect(&#10;            itemName = item.name,&#10;            monsters = growingMonsters,&#10;            coins = coins,&#10;            bagCoins = bagCoins,&#10;            coroutineScope = coroutineScope,&#10;            screenHeightPx = screenHeightPx,&#10;            planeX = planeX,&#10;            onScoreUpdate = { add -&gt;&#10;                totalScore += add&#10;                currentSessionScore += add&#10;                if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;            },&#10;            onShieldToggle = { active -&gt; shieldActive = active },&#10;            onWallToggle = { active -&gt; wallActive = active },&#10;            onTimeToggle = { active -&gt; timeActive = active },&#10;            onLevelClear = { isLevelClear = true }&#10;        )&#10;        chestItems = chestItems - item&#10;        if (!playerName.isNullOrBlank()) FirebaseHelper.updateChest(playerName, chestItems)&#10;    }&#10;&#10;    // --- Drag plane ---&#10;    val dragModifier = Modifier.pointerInput(Unit) {&#10;        detectDragGestures { change, dragAmount -&gt;&#10;            planeX = (planeX + dragAmount.x).coerceIn(0f, screenWidthPx - planeWidth)&#10;            change.consume()&#10;        }&#10;    }&#10;&#10;    // --- UI ---&#10;    Box(modifier = Modifier.fillMaxSize().then(dragModifier)) {&#10;        // Background&#10;        Image(&#10;            painter = painterResource(R.drawable.vutru1),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg1Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;        Image(&#10;            painter = painterResource(R.drawable.vutru1),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg2Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;&#10;        // Growing Monsters&#10;        growingMonsters.forEach { m -&gt;&#10;            GrowingMonsterUI(monster = m)&#10;        }&#10;&#10;        // Coins&#10;        coins.filter { !it.collected.value }.forEach { c -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.coin),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(c.x.roundToInt(), c.y.value.roundToInt()) }&#10;                    .size(40.dp)&#10;            )&#10;        }&#10;&#10;        // BagCoin animated views&#10;        bagCoins.toList().forEach { bag -&gt;&#10;            BagCoinAnimatedView(bag = bag, onFinished = { finishedBag -&gt;&#10;                bagCoins.remove(finishedBag)&#10;            })&#10;        }&#10;&#10;        // Bullets&#10;        bullets.forEach { b -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.dan2),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(b.x.roundToInt(), b.y.roundToInt()) }&#10;                    .size(30.dp)&#10;            )&#10;        }&#10;&#10;        // Plane&#10;        PlaneUI(&#10;            planeX = planeX,&#10;            planeY = planeY,&#10;            planeHp = planeHp,&#10;            shieldActive = shieldActive&#10;        )&#10;&#10;        // Wall&#10;        if (wallActive) {&#10;            WallUI(planeY = planeY)&#10;        }&#10;&#10;        // Top bar&#10;        TopBarUI(&#10;            bagCoinScore = totalScore,&#10;            chestItems = chestItems,&#10;            onBuyItem = { item, price -&gt;&#10;                if (totalScore &gt;= price) {&#10;                    totalScore -= price&#10;                    chestItems = chestItems + item&#10;                    if (!playerName.isNullOrBlank()) {&#10;                        FirebaseHelper.updateScore(playerName, totalScore)&#10;                        FirebaseHelper.updateChest(playerName, chestItems)&#10;                    }&#10;                }&#10;            },&#10;            onUseChestItem = { useChestItem(it) }&#10;        )&#10;&#10;        // --- Sound Control Button (top-right corner) ---&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp),&#10;            contentAlignment = androidx.compose.ui.Alignment.TopEnd&#10;        ) {&#10;            SoundControlButton()&#10;        }&#10;    }&#10;&#10;    // --- Game End Dialog ---&#10;    if (showGameEndDialog) {&#10;        GameEndDialog(&#10;            isWin = isLevelClear,&#10;            score = currentSessionScore,&#10;            level = 4,&#10;            onDismiss = {&#10;                showGameEndDialog = false&#10;            },&#10;            onReplay = {&#10;                // Reset game&#10;                showGameEndDialog = false&#10;                isGameOver = false&#10;                isLevelClear = false&#10;                planeHp = 100&#10;                currentSessionScore = 0&#10;&#10;                growingMonsters.forEachIndexed { index, m -&gt;&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 200f) + 100f&#10;                    m.y.value = -Random.nextInt(200, 2500).toFloat()&#10;                    m.hp.value = 80&#10;                    m.maxHp = 80&#10;                    m.currentMaxHp.value = 80&#10;                    m.currentSize.value = m.initialSize&#10;                    m.alive.value = true&#10;                    monsterRespawnTimes[index] = 0L&#10;                }&#10;&#10;                coins.forEach { c -&gt;&#10;                    c.collected.value = false&#10;                    c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                    c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                }&#10;&#10;                bullets.clear()&#10;            },&#10;            onNextLevel = {&#10;                onExit()&#10;            },&#10;            onExit = {&#10;                onExit()&#10;            }&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>
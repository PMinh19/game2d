<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;!-- Permissions --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.Game&quot;&#10;        tools:targetApi=&quot;31&quot;&gt;&#10;&#10;        &lt;!-- Game Screen Activity --&gt;&#10;        &lt;activity&#10;            android:name=&quot;.GameScreenActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:screenOrientation=&quot;portrait&quot;&#10;            android:theme=&quot;@style/Theme.Game&quot; /&gt;&#10;&#10;        &lt;!-- Level 2 Activity --&gt;&#10;        &lt;activity&#10;            android:name=&quot;.Level2Activity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:screenOrientation=&quot;portrait&quot;&#10;            android:theme=&quot;@style/Theme.Game&quot; /&gt;&#10;&#10;        &lt;!-- Level 3 Activity --&gt;&#10;        &lt;activity&#10;            android:name=&quot;.Level3Activity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:screenOrientation=&quot;portrait&quot;&#10;            android:theme=&quot;@style/Theme.Game&quot; /&gt;&#10;&#10;        &lt;!-- Level 4 Activity --&gt;&#10;        &lt;activity&#10;            android:name=&quot;.Level4Activity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:screenOrientation=&quot;portrait&quot;&#10;            android:theme=&quot;@style/Theme.Game&quot; /&gt;&#10;&#10;        &lt;!-- Level 5 Activity --&gt;&#10;        &lt;activity&#10;            android:name=&quot;.Level5Activity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:screenOrientation=&quot;portrait&quot;&#10;            android:theme=&quot;@style/Theme.Game&quot; /&gt;&#10;&#10;        &lt;!-- Main Activity --&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:screenOrientation=&quot;portrait&quot;&#10;            android:theme=&quot;@style/Theme.Game&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;!-- Permissions --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.Game&quot;&#10;        tools:targetApi=&quot;31&quot;&gt;&#10;&#10;        &lt;!-- Splash Activity (LAUNCHER - Màn hình khởi động đầu tiên) --&gt;&#10;        &lt;activity&#10;            android:name=&quot;.SplashActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:screenOrientation=&quot;portrait&quot;&#10;            android:theme=&quot;@style/Theme.Game&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;!-- Name Input Activity (Màn hình nhập tên) --&gt;&#10;        &lt;activity&#10;            android:name=&quot;.NameInputActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:screenOrientation=&quot;portrait&quot;&#10;            android:theme=&quot;@style/Theme.Game&quot; /&gt;&#10;&#10;        &lt;!-- Main Activity (Màn hình chính) --&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:screenOrientation=&quot;portrait&quot;&#10;            android:theme=&quot;@style/Theme.Game&quot; /&gt;&#10;&#10;        &lt;!-- Game Screen Activity --&gt;&#10;        &lt;activity&#10;            android:name=&quot;.GameScreenActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:screenOrientation=&quot;portrait&quot;&#10;            android:theme=&quot;@style/Theme.Game&quot; /&gt;&#10;&#10;        &lt;!-- Level 2 Activity --&gt;&#10;        &lt;activity&#10;            android:name=&quot;.Level2Activity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:screenOrientation=&quot;portrait&quot;&#10;            android:theme=&quot;@style/Theme.Game&quot; /&gt;&#10;&#10;        &lt;!-- Level 3 Activity --&gt;&#10;        &lt;activity&#10;            android:name=&quot;.Level3Activity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:screenOrientation=&quot;portrait&quot;&#10;            android:theme=&quot;@style/Theme.Game&quot; /&gt;&#10;&#10;        &lt;!-- Level 4 Activity --&gt;&#10;        &lt;activity&#10;            android:name=&quot;.Level4Activity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:screenOrientation=&quot;portrait&quot;&#10;            android:theme=&quot;@style/Theme.Game&quot; /&gt;&#10;&#10;        &lt;!-- Level 5 Activity --&gt;&#10;        &lt;activity&#10;            android:name=&quot;.Level5Activity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:screenOrientation=&quot;portrait&quot;&#10;            android:theme=&quot;@style/Theme.Game&quot; /&gt;&#10;&#10;        &lt;activity android:name=&quot;.Top6Activity&quot; /&gt;&#10;        &lt;activity android:name=&quot;.RankScreenActivity&quot; /&gt;&#10;        &lt;activity android:name=&quot;.SettingScreenActivity&quot; /&gt;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/game/FirebaseHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/game/FirebaseHelper.kt" />
              <option name="originalContent" value="package com.example.game&#10;&#10;import android.util.Log&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import java.util.Date&#10;&#10;data class ChestItem(val name: String, val resId: Int)&#10;data class ScoreEntry(val score: Int, val timestamp: Long)&#10;&#10;object FirebaseHelper {&#10;    private val db = FirebaseFirestore.getInstance()&#10;&#10;    private fun resolveResIdFromName(name: String): Int {&#10;        return when (name) {&#10;            &quot;Fireworks&quot; -&gt; R.drawable.fireworks&#10;            &quot;Firework2&quot; -&gt; R.drawable.firework2&#10;            &quot;Bom&quot;, &quot;Bomb&quot; -&gt; R.drawable.bom1&#10;            &quot;Shield&quot;, &quot;Khiên&quot; -&gt; R.drawable.shield1&#10;            &quot;Time&quot;, &quot;Đồng hồ&quot;, &quot;Clock&quot; -&gt; R.drawable.time&#10;            &quot;Wall&quot;, &quot;Tường&quot; -&gt; R.drawable.wall&#10;            else -&gt; R.drawable.store&#10;        }&#10;    }&#10;&#10;    // ---------------- SYNC ----------------&#10;    fun syncAllPlayers() {&#10;        db.collection(&quot;rankings&quot;).get()&#10;            .addOnSuccessListener { snapshot -&gt;&#10;                for (doc in snapshot.documents) {&#10;                    val updates = mutableMapOf&lt;String, Any&gt;()&#10;                    if (doc.get(&quot;score&quot;) == null) updates[&quot;score&quot;] = 0&#10;                    if (doc.get(&quot;chest&quot;) == null) updates[&quot;chest&quot;] = emptyList&lt;Map&lt;String, Any&gt;&gt;()&#10;                    if (doc.get(&quot;scoreHistory&quot;) == null) updates[&quot;scoreHistory&quot;] = emptyList&lt;Map&lt;String, Any&gt;&gt;()&#10;                    if (updates.isNotEmpty()) {&#10;                        db.collection(&quot;rankings&quot;).document(doc.id)&#10;                            .update(updates)&#10;                            .addOnSuccessListener {&#10;                                Log.d(&quot;FirebaseHelper&quot;, &quot;Updated ${doc.getString(&quot;name&quot;)}&quot;)&#10;                            }&#10;                            .addOnFailureListener { e -&gt;&#10;                                Log.w(&quot;FirebaseHelper&quot;, &quot;Failed update ${doc.getString(&quot;name&quot;)}&quot;, e)&#10;                            }&#10;                    }&#10;                }&#10;                Log.d(&quot;FirebaseHelper&quot;, &quot;All players synced&quot;)&#10;            }&#10;            .addOnFailureListener { e -&gt;&#10;                Log.w(&quot;FirebaseHelper&quot;, &quot;Failed to fetch rankings&quot;, e)&#10;            }&#10;    }&#10;&#10;    fun syncNewPlayer(playerName: String) {&#10;        if (playerName.isBlank()) return&#10;        db.collection(&quot;rankings&quot;)&#10;            .whereEqualTo(&quot;name&quot;, playerName)&#10;            .get()&#10;            .addOnSuccessListener { docs -&gt;&#10;                if (docs.isEmpty) {&#10;                    val newPlayer = hashMapOf(&#10;                        &quot;name&quot; to playerName,&#10;                        &quot;score&quot; to 0,&#10;                        &quot;chest&quot; to emptyList&lt;Map&lt;String, Any&gt;&gt;(),&#10;                        &quot;scoreHistory&quot; to emptyList&lt;Map&lt;String, Any&gt;&gt;()&#10;                    )&#10;                    db.collection(&quot;rankings&quot;).add(newPlayer)&#10;                        .addOnSuccessListener {&#10;                            Log.d(&quot;FirebaseHelper&quot;, &quot;New player $playerName created&quot;)&#10;                        }&#10;                        .addOnFailureListener { e -&gt;&#10;                            Log.w(&quot;FirebaseHelper&quot;, &quot;Failed to create new player&quot;, e)&#10;                        }&#10;                }&#10;            }&#10;    }&#10;&#10;    // ---------------- SCORE ----------------&#10;    fun getScore(playerName: String, onResult: (Int) -&gt; Unit) {&#10;        db.collection(&quot;rankings&quot;)&#10;            .whereEqualTo(&quot;name&quot;, playerName)&#10;            .get()&#10;            .addOnSuccessListener { docs -&gt;&#10;                if (!docs.isEmpty) {&#10;                    val score = docs.documents[0].getLong(&quot;score&quot;)?.toInt() ?: 0&#10;                    onResult(score)&#10;                } else {&#10;                    onResult(0)&#10;                }&#10;            }&#10;            .addOnFailureListener {&#10;                onResult(0)&#10;            }&#10;    }&#10;&#10;    fun updateScore(playerName: String, score: Int) {&#10;        db.collection(&quot;rankings&quot;)&#10;            .whereEqualTo(&quot;name&quot;, playerName)&#10;            .get()&#10;            .addOnSuccessListener { docs -&gt;&#10;                if (!docs.isEmpty) {&#10;                    val docId = docs.documents[0].id&#10;                    val currentHistory = docs.documents[0].get(&quot;scoreHistory&quot;) as? List&lt;Map&lt;String, Any&gt;&gt; ?: emptyList()&#10;                    val newScoreEntry = mapOf(&#10;                        &quot;score&quot; to score,&#10;                        &quot;timestamp&quot; to Date().time&#10;                    )&#10;                    val updatedHistory = currentHistory + newScoreEntry&#10;                    db.collection(&quot;rankings&quot;).document(docId)&#10;                        .update(&#10;                            mapOf(&#10;                                &quot;score&quot; to score,&#10;                                &quot;scoreHistory&quot; to updatedHistory&#10;                            )&#10;                        )&#10;                } else {&#10;                    val data = hashMapOf(&#10;                        &quot;name&quot; to playerName,&#10;                        &quot;score&quot; to score,&#10;                        &quot;chest&quot; to emptyList&lt;Map&lt;String, Any&gt;&gt;(),&#10;                        &quot;scoreHistory&quot; to listOf(&#10;                            mapOf(&#10;                                &quot;score&quot; to score,&#10;                                &quot;timestamp&quot; to Date().time&#10;                            )&#10;                        )&#10;                    )&#10;                    db.collection(&quot;rankings&quot;).add(data)&#10;                }&#10;            }&#10;            .addOnFailureListener { e -&gt;&#10;                Log.w(&quot;FirebaseHelper&quot;, &quot;updateScore failed&quot;, e)&#10;            }&#10;    }&#10;&#10;    // ---------------- SCORE HISTORY ----------------&#10;    fun getScoreHistory(playerName: String, onResult: (List&lt;ScoreEntry&gt;) -&gt; Unit) {&#10;        db.collection(&quot;rankings&quot;)&#10;            .whereEqualTo(&quot;name&quot;, playerName)&#10;            .get()&#10;            .addOnSuccessListener { docs -&gt;&#10;                if (!docs.isEmpty) {&#10;                    val historyRaw = docs.documents[0].get(&quot;scoreHistory&quot;)&#10;                    val history: List&lt;ScoreEntry&gt; = when (historyRaw) {&#10;                        is List&lt;*&gt; -&gt; {&#10;                            if (historyRaw.firstOrNull() is Map&lt;*, *&gt;) {&#10;                                @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;                                val maps = historyRaw as List&lt;Map&lt;String, Any&gt;&gt;&#10;                                maps.mapNotNull { m -&gt;&#10;                                    val score = (m[&quot;score&quot;] as? Number)?.toInt()&#10;                                    val timestamp = (m[&quot;timestamp&quot;] as? Long)&#10;                                    if (score != null &amp;&amp; timestamp != null) ScoreEntry(score, timestamp) else null&#10;                                }&#10;                            } else {&#10;                                emptyList()&#10;                            }&#10;                        }&#10;                        else -&gt; emptyList()&#10;                    }&#10;                    onResult(history)&#10;                } else {&#10;                    onResult(emptyList())&#10;                }&#10;            }&#10;            .addOnFailureListener {&#10;                onResult(emptyList())&#10;            }&#10;    }&#10;&#10;    // ---------------- TOP 6 SCORES ----------------&#10;    fun getTop6Scores(onResult: (List&lt;Pair&lt;String, ScoreEntry&gt;&gt;) -&gt; Unit) {&#10;        db.collection(&quot;rankings&quot;)&#10;            .get()&#10;            .addOnSuccessListener { snapshot -&gt;&#10;                val allScores = mutableListOf&lt;Pair&lt;String, ScoreEntry&gt;&gt;()&#10;                for (doc in snapshot.documents) {&#10;                    val playerName = doc.getString(&quot;name&quot;) ?: continue&#10;                    val historyRaw = doc.get(&quot;scoreHistory&quot;)&#10;                    val history: List&lt;ScoreEntry&gt; = when (historyRaw) {&#10;                        is List&lt;*&gt; -&gt; {&#10;                            if (historyRaw.firstOrNull() is Map&lt;*, *&gt;) {&#10;                                @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;                                val maps = historyRaw as List&lt;Map&lt;String, Any&gt;&gt;&#10;                                maps.mapNotNull { m -&gt;&#10;                                    val score = (m[&quot;score&quot;] as? Number)?.toInt()&#10;                                    val timestamp = (m[&quot;timestamp&quot;] as? Long)&#10;                                    if (score != null &amp;&amp; timestamp != null) ScoreEntry(score, timestamp) else null&#10;                                }&#10;                            } else {&#10;                                emptyList()&#10;                            }&#10;                        }&#10;                        else -&gt; emptyList()&#10;                    }&#10;                    history.forEach { scoreEntry -&gt;&#10;                        allScores.add(Pair(playerName, scoreEntry))&#10;                    }&#10;                }&#10;                // Sort by score in descending order and take top 6&#10;                val topScores = allScores.sortedByDescending { it.second.score }.take(6)&#10;                onResult(topScores)&#10;            }&#10;            .addOnFailureListener { e -&gt;&#10;                Log.w(&quot;FirebaseHelper&quot;, &quot;Failed to fetch top scores&quot;, e)&#10;                onResult(emptyList())&#10;            }&#10;    }&#10;&#10;    // ---------------- ENHANCED SCORE SYNC ----------------&#10;    fun syncScoreWithRetry(playerName: String, score: Int, retryCount: Int = 3) {&#10;        if (playerName.isBlank()) return&#10;        fun attemptSync(attemptsLeft: Int) {&#10;            if (attemptsLeft &lt;= 0) {&#10;                Log.e(&quot;FirebaseHelper&quot;, &quot;Failed to sync score after all retries&quot;)&#10;                return&#10;            }&#10;            updateScore(playerName, score)&#10;            android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({&#10;                getScore(playerName) { retrievedScore -&gt;&#10;                    if (retrievedScore != score &amp;&amp; attemptsLeft &gt; 1) {&#10;                        Log.w(&quot;FirebaseHelper&quot;, &quot;Score mismatch, retrying... ($attemptsLeft attempts left)&quot;)&#10;                        attemptSync(attemptsLeft - 1)&#10;                    } else {&#10;                        Log.d(&quot;FirebaseHelper&quot;, &quot;Score sync successful: $score&quot;)&#10;                    }&#10;                }&#10;            }, 1000)&#10;        }&#10;        attemptSync(retryCount)&#10;    }&#10;&#10;    // Auto-sync score every 30 seconds&#10;    fun startPeriodicScoreSync(playerName: String, getCurrentScore: () -&gt; Int) {&#10;        if (playerName.isBlank()) return&#10;        val handler = android.os.Handler(android.os.Looper.getMainLooper())&#10;        val syncRunnable = object : Runnable {&#10;            override fun run() {&#10;                val currentScore = getCurrentScore()&#10;                Log.d(&quot;FirebaseHelper&quot;, &quot;Periodic sync: $currentScore points for $playerName&quot;)&#10;                updateScore(playerName, currentScore)&#10;                handler.postDelayed(this, 30000)&#10;            }&#10;        }&#10;        handler.post(syncRunnable)&#10;    }&#10;&#10;    // ---------------- CHEST ----------------&#10;    fun getChestItems(playerName: String, onResult: (List&lt;ChestItem&gt;) -&gt; Unit) {&#10;        db.collection(&quot;rankings&quot;)&#10;            .whereEqualTo(&quot;name&quot;, playerName)&#10;            .get()&#10;            .addOnSuccessListener { docs -&gt;&#10;                if (!docs.isEmpty) {&#10;                    val chestRaw = docs.documents[0].get(&quot;chest&quot;)&#10;                    val chest: List&lt;ChestItem&gt; = when (chestRaw) {&#10;                        is List&lt;*&gt; -&gt; {&#10;                            if (chestRaw.firstOrNull() is Map&lt;*, *&gt;) {&#10;                                @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;                                val maps = chestRaw as List&lt;Map&lt;String, Any&gt;&gt;&#10;                                maps.mapNotNull { m -&gt;&#10;                                    val name = m[&quot;name&quot;] as? String&#10;                                    val res = (m[&quot;resId&quot;] as? Number)?.toInt()&#10;                                    if (name != null &amp;&amp; res != null) ChestItem(name, res) else null&#10;                                }&#10;                            } else if (chestRaw.firstOrNull() is String) {&#10;                                val names = chestRaw.filterIsInstance&lt;String&gt;()&#10;                                names.map { n -&gt; ChestItem(n, resolveResIdFromName(n)) }&#10;                            } else emptyList()&#10;                        }&#10;                        else -&gt; emptyList()&#10;                    }&#10;                    onResult(chest)&#10;                } else {&#10;                    onResult(emptyList())&#10;                }&#10;            }&#10;            .addOnFailureListener {&#10;                onResult(emptyList())&#10;            }&#10;    }&#10;&#10;    fun addItemToChest(playerName: String, newItem: ChestItem) {&#10;        db.collection(&quot;rankings&quot;)&#10;            .whereEqualTo(&quot;name&quot;, playerName)&#10;            .get()&#10;            .addOnSuccessListener { docs -&gt;&#10;                if (!docs.isEmpty) {&#10;                    val doc = docs.documents[0]&#10;                    val docId = doc.id&#10;                    val chestList = doc.get(&quot;chest&quot;) as? MutableList&lt;Map&lt;String, Any&gt;&gt; ?: mutableListOf()&#10;                    chestList.add(mapOf(&quot;name&quot; to newItem.name, &quot;resId&quot; to newItem.resId))&#10;                    db.collection(&quot;rankings&quot;).document(docId)&#10;                        .update(&quot;chest&quot;, chestList)&#10;                } else {&#10;                    val data = hashMapOf(&#10;                        &quot;name&quot; to playerName,&#10;                        &quot;score&quot; to 0,&#10;                        &quot;chest&quot; to listOf(mapOf(&quot;name&quot; to newItem.name, &quot;resId&quot; to newItem.resId)),&#10;                        &quot;scoreHistory&quot; to emptyList&lt;Map&lt;String, Any&gt;&gt;()&#10;                    )&#10;                    db.collection(&quot;rankings&quot;).add(data)&#10;                }&#10;            }&#10;            .addOnFailureListener { e -&gt;&#10;                Log.w(&quot;FirebaseHelper&quot;, &quot;addItemToChest failed&quot;, e)&#10;            }&#10;    }&#10;&#10;    fun updateChest(playerName: String, newChest: List&lt;ChestItem&gt;, onComplete: (() -&gt; Unit)? = null) {&#10;        db.collection(&quot;rankings&quot;)&#10;            .whereEqualTo(&quot;name&quot;, playerName)&#10;            .get()&#10;            .addOnSuccessListener { docs -&gt;&#10;                if (!docs.isEmpty) {&#10;                    val docId = docs.documents[0].id&#10;                    val chestMapList = newChest.map { mapOf(&quot;name&quot; to it.name, &quot;resId&quot; to it.resId) }&#10;                    db.collection(&quot;rankings&quot;)&#10;                        .document(docId)&#10;                        .update(&quot;chest&quot;, chestMapList)&#10;                        .addOnSuccessListener { onComplete?.invoke() }&#10;                }&#10;            }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.game&#13;&#10;&#13;&#10;import android.util.Log&#13;&#10;import com.google.firebase.firestore.FirebaseFirestore&#13;&#10;import java.util.Date&#13;&#10;&#13;&#10;data class ChestItem(val name: String, val resId: Int)&#13;&#10;data class ScoreEntry(val score: Int, val timestamp: Long)&#13;&#10;&#13;&#10;object FirebaseHelper {&#13;&#10;    private val db = FirebaseFirestore.getInstance()&#13;&#10;&#13;&#10;    private fun resolveResIdFromName(name: String): Int {&#13;&#10;        return when (name) {&#13;&#10;            &quot;Fireworks&quot; -&gt; R.drawable.fireworks&#13;&#10;            &quot;Firework2&quot; -&gt; R.drawable.firework2&#13;&#10;            &quot;Bom&quot;, &quot;Bomb&quot; -&gt; R.drawable.bom1&#13;&#10;            &quot;Shield&quot;, &quot;Khiên&quot; -&gt; R.drawable.shield1&#13;&#10;            &quot;Time&quot;, &quot;Đồng hồ&quot;, &quot;Clock&quot; -&gt; R.drawable.time&#13;&#10;            &quot;Wall&quot;, &quot;Tường&quot; -&gt; R.drawable.wall&#13;&#10;            else -&gt; R.drawable.store&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // ---------------- SYNC ----------------&#13;&#10;    fun syncAllPlayers() {&#13;&#10;        db.collection(&quot;rankings&quot;).get()&#13;&#10;            .addOnSuccessListener { snapshot -&gt;&#13;&#10;                for (doc in snapshot.documents) {&#13;&#10;                    val updates = mutableMapOf&lt;String, Any&gt;()&#13;&#10;                    if (doc.get(&quot;score&quot;) == null) updates[&quot;score&quot;] = 0&#13;&#10;                    if (doc.get(&quot;chest&quot;) == null) updates[&quot;chest&quot;] = emptyList&lt;Map&lt;String, Any&gt;&gt;()&#13;&#10;                    if (doc.get(&quot;scoreHistory&quot;) == null) updates[&quot;scoreHistory&quot;] = emptyList&lt;Map&lt;String, Any&gt;&gt;()&#13;&#10;                    if (updates.isNotEmpty()) {&#13;&#10;                        db.collection(&quot;rankings&quot;).document(doc.id)&#13;&#10;                            .update(updates)&#13;&#10;                            .addOnSuccessListener {&#13;&#10;                                Log.d(&quot;FirebaseHelper&quot;, &quot;Updated ${doc.getString(&quot;name&quot;)}&quot;)&#13;&#10;                            }&#13;&#10;                            .addOnFailureListener { e -&gt;&#13;&#10;                                Log.w(&quot;FirebaseHelper&quot;, &quot;Failed update ${doc.getString(&quot;name&quot;)}&quot;, e)&#13;&#10;                            }&#13;&#10;                    }&#13;&#10;                }&#13;&#10;                Log.d(&quot;FirebaseHelper&quot;, &quot;All players synced&quot;)&#13;&#10;            }&#13;&#10;            .addOnFailureListener { e -&gt;&#13;&#10;                Log.w(&quot;FirebaseHelper&quot;, &quot;Failed to fetch rankings&quot;, e)&#13;&#10;            }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun syncNewPlayer(playerName: String) {&#13;&#10;        if (playerName.isBlank()) return&#13;&#10;        db.collection(&quot;rankings&quot;)&#13;&#10;            .whereEqualTo(&quot;name&quot;, playerName)&#13;&#10;            .get()&#13;&#10;            .addOnSuccessListener { docs -&gt;&#13;&#10;                if (docs.isEmpty) {&#13;&#10;                    val newPlayer = hashMapOf(&#13;&#10;                        &quot;name&quot; to playerName,&#13;&#10;                        &quot;score&quot; to 0,&#13;&#10;                        &quot;chest&quot; to emptyList&lt;Map&lt;String, Any&gt;&gt;(),&#13;&#10;                        &quot;scoreHistory&quot; to emptyList&lt;Map&lt;String, Any&gt;&gt;()&#13;&#10;                    )&#13;&#10;                    db.collection(&quot;rankings&quot;).add(newPlayer)&#13;&#10;                        .addOnSuccessListener {&#13;&#10;                            Log.d(&quot;FirebaseHelper&quot;, &quot;New player $playerName created&quot;)&#13;&#10;                        }&#13;&#10;                        .addOnFailureListener { e -&gt;&#13;&#10;                            Log.w(&quot;FirebaseHelper&quot;, &quot;Failed to create new player&quot;, e)&#13;&#10;                        }&#13;&#10;                }&#13;&#10;            }&#13;&#10;    }&#13;&#10;&#13;&#10;    // ---------------- SCORE ----------------&#13;&#10;    fun getScore(playerName: String, onResult: (Int) -&gt; Unit) {&#13;&#10;        db.collection(&quot;rankings&quot;)&#13;&#10;            .whereEqualTo(&quot;name&quot;, playerName)&#13;&#10;            .get()&#13;&#10;            .addOnSuccessListener { docs -&gt;&#13;&#10;                if (!docs.isEmpty) {&#13;&#10;                    val score = docs.documents[0].getLong(&quot;score&quot;)?.toInt() ?: 0&#13;&#10;                    onResult(score)&#13;&#10;                } else {&#13;&#10;                    onResult(0)&#13;&#10;                }&#13;&#10;            }&#13;&#10;            .addOnFailureListener {&#13;&#10;                onResult(0)&#13;&#10;            }&#13;&#10;    }&#13;&#10;&#13;&#10;    // CẬP NHẬT ĐIỂM TRONG KHI CHƠI (không lưu vào history)&#13;&#10;    fun updateScore(playerName: String, score: Int) {&#13;&#10;        db.collection(&quot;rankings&quot;)&#13;&#10;            .whereEqualTo(&quot;name&quot;, playerName)&#13;&#10;            .get()&#13;&#10;            .addOnSuccessListener { docs -&gt;&#13;&#10;                if (!docs.isEmpty) {&#13;&#10;                    val docId = docs.documents[0].id&#13;&#10;                    // CHỈ cập nhật điểm hiện tại, KHÔNG lưu vào scoreHistory&#13;&#10;                    db.collection(&quot;rankings&quot;).document(docId)&#13;&#10;                        .update(&quot;score&quot;, score)&#13;&#10;                } else {&#13;&#10;                    // Nếu player chưa tồn tại, tạo mới&#13;&#10;                    val data = hashMapOf(&#13;&#10;                        &quot;name&quot; to playerName,&#13;&#10;                        &quot;score&quot; to score,&#13;&#10;                        &quot;chest&quot; to emptyList&lt;Map&lt;String, Any&gt;&gt;(),&#13;&#10;                        &quot;scoreHistory&quot; to emptyList&lt;Map&lt;String, Any&gt;&gt;()&#13;&#10;                    )&#13;&#10;                    db.collection(&quot;rankings&quot;).add(data)&#13;&#10;                }&#13;&#10;            }&#13;&#10;            .addOnFailureListener { e -&gt;&#13;&#10;                Log.w(&quot;FirebaseHelper&quot;, &quot;updateScore failed&quot;, e)&#13;&#10;            }&#13;&#10;    }&#13;&#10;&#13;&#10;    // LƯU ĐIỂM CUỐI TRẬN vào history (chỉ gọi khi kết thúc trận)&#13;&#10;    fun saveMatchScore(playerName: String, finalScore: Int) {&#13;&#10;        if (finalScore &lt;= 0) return // Không lưu nếu điểm = 0&#13;&#10;        &#13;&#10;        db.collection(&quot;rankings&quot;)&#13;&#10;            .whereEqualTo(&quot;name&quot;, playerName)&#13;&#10;            .get()&#13;&#10;            .addOnSuccessListener { docs -&gt;&#13;&#10;                if (!docs.isEmpty) {&#13;&#10;                    val docId = docs.documents[0].id&#13;&#10;                    val currentHistory = docs.documents[0].get(&quot;scoreHistory&quot;) as? List&lt;Map&lt;String, Any&gt;&gt; ?: emptyList()&#13;&#10;                    &#13;&#10;                    // Thêm điểm cuối trận vào lịch sử&#13;&#10;                    val newScoreEntry = mapOf(&#13;&#10;                        &quot;score&quot; to finalScore,&#13;&#10;                        &quot;timestamp&quot; to Date().time&#13;&#10;                    )&#13;&#10;                    val updatedHistory = currentHistory + newScoreEntry&#13;&#10;                    &#13;&#10;                    db.collection(&quot;rankings&quot;).document(docId)&#13;&#10;                        .update(&#13;&#10;                            mapOf(&#13;&#10;                                &quot;score&quot; to finalScore,&#13;&#10;                                &quot;scoreHistory&quot; to updatedHistory&#13;&#10;                            )&#13;&#10;                        )&#13;&#10;                        .addOnSuccessListener {&#13;&#10;                            Log.d(&quot;FirebaseHelper&quot;, &quot;Match score saved: $finalScore&quot;)&#13;&#10;                        }&#13;&#10;                } else {&#13;&#10;                    // Nếu player chưa tồn tại, tạo mới với điểm này&#13;&#10;                    val data = hashMapOf(&#13;&#10;                        &quot;name&quot; to playerName,&#13;&#10;                        &quot;score&quot; to finalScore,&#13;&#10;                        &quot;chest&quot; to emptyList&lt;Map&lt;String, Any&gt;&gt;(),&#13;&#10;                        &quot;scoreHistory&quot; to listOf(&#13;&#10;                            mapOf(&#13;&#10;                                &quot;score&quot; to finalScore,&#13;&#10;                                &quot;timestamp&quot; to Date().time&#13;&#10;                            )&#13;&#10;                        )&#13;&#10;                    )&#13;&#10;                    db.collection(&quot;rankings&quot;).add(data)&#13;&#10;                }&#13;&#10;            }&#13;&#10;            .addOnFailureListener { e -&gt;&#13;&#10;                Log.w(&quot;FirebaseHelper&quot;, &quot;saveMatchScore failed&quot;, e)&#13;&#10;            }&#13;&#10;    }&#13;&#10;&#13;&#10;    // ---------------- SCORE HISTORY ----------------&#13;&#10;    fun getScoreHistory(playerName: String, onResult: (List&lt;ScoreEntry&gt;) -&gt; Unit) {&#13;&#10;        db.collection(&quot;rankings&quot;)&#13;&#10;            .whereEqualTo(&quot;name&quot;, playerName)&#13;&#10;            .get()&#13;&#10;            .addOnSuccessListener { docs -&gt;&#13;&#10;                if (!docs.isEmpty) {&#13;&#10;                    val historyRaw = docs.documents[0].get(&quot;scoreHistory&quot;)&#13;&#10;                    val history: List&lt;ScoreEntry&gt; = when (historyRaw) {&#13;&#10;                        is List&lt;*&gt; -&gt; {&#13;&#10;                            if (historyRaw.firstOrNull() is Map&lt;*, *&gt;) {&#13;&#10;                                @Suppress(&quot;UNCHECKED_CAST&quot;)&#13;&#10;                                val maps = historyRaw as List&lt;Map&lt;String, Any&gt;&gt;&#13;&#10;                                maps.mapNotNull { m -&gt;&#13;&#10;                                    val score = (m[&quot;score&quot;] as? Number)?.toInt()&#13;&#10;                                    val timestamp = (m[&quot;timestamp&quot;] as? Long)&#13;&#10;                                    if (score != null &amp;&amp; timestamp != null) ScoreEntry(score, timestamp) else null&#13;&#10;                                }&#13;&#10;                            } else {&#13;&#10;                                emptyList()&#13;&#10;                            }&#13;&#10;                        }&#13;&#10;                        else -&gt; emptyList()&#13;&#10;                    }&#13;&#10;                    onResult(history)&#13;&#10;                } else {&#13;&#10;                    onResult(emptyList())&#13;&#10;                }&#13;&#10;            }&#13;&#10;            .addOnFailureListener {&#13;&#10;                onResult(emptyList())&#13;&#10;            }&#13;&#10;    }&#13;&#10;&#13;&#10;    // ---------------- TOP 6 SCORES ----------------&#13;&#10;    fun getTop6Scores(onResult: (List&lt;Pair&lt;String, ScoreEntry&gt;&gt;) -&gt; Unit) {&#13;&#10;        db.collection(&quot;rankings&quot;)&#13;&#10;            .get()&#13;&#10;            .addOnSuccessListener { snapshot -&gt;&#13;&#10;                val allScores = mutableListOf&lt;Pair&lt;String, ScoreEntry&gt;&gt;()&#13;&#10;                for (doc in snapshot.documents) {&#13;&#10;                    val playerName = doc.getString(&quot;name&quot;) ?: continue&#13;&#10;                    val historyRaw = doc.get(&quot;scoreHistory&quot;)&#13;&#10;                    val history: List&lt;ScoreEntry&gt; = when (historyRaw) {&#13;&#10;                        is List&lt;*&gt; -&gt; {&#13;&#10;                            if (historyRaw.firstOrNull() is Map&lt;*, *&gt;) {&#13;&#10;                                @Suppress(&quot;UNCHECKED_CAST&quot;)&#13;&#10;                                val maps = historyRaw as List&lt;Map&lt;String, Any&gt;&gt;&#13;&#10;                                maps.mapNotNull { m -&gt;&#13;&#10;                                    val score = (m[&quot;score&quot;] as? Number)?.toInt()&#13;&#10;                                    val timestamp = (m[&quot;timestamp&quot;] as? Long)&#13;&#10;                                    if (score != null &amp;&amp; timestamp != null) ScoreEntry(score, timestamp) else null&#13;&#10;                                }&#13;&#10;                            } else {&#13;&#10;                                emptyList()&#13;&#10;                            }&#13;&#10;                        }&#13;&#10;                        else -&gt; emptyList()&#13;&#10;                    }&#13;&#10;                    history.forEach { scoreEntry -&gt;&#13;&#10;                        allScores.add(Pair(playerName, scoreEntry))&#13;&#10;                    }&#13;&#10;                }&#13;&#10;                // Sort by score in descending order and take top 6&#13;&#10;                val topScores = allScores.sortedByDescending { it.second.score }.take(6)&#13;&#10;                onResult(topScores)&#13;&#10;            }&#13;&#10;            .addOnFailureListener { e -&gt;&#13;&#10;                Log.w(&quot;FirebaseHelper&quot;, &quot;Failed to fetch top scores&quot;, e)&#13;&#10;                onResult(emptyList())&#13;&#10;            }&#13;&#10;    }&#13;&#10;&#13;&#10;    // ---------------- ENHANCED SCORE SYNC ----------------&#13;&#10;    fun syncScoreWithRetry(playerName: String, score: Int, retryCount: Int = 3) {&#13;&#10;        if (playerName.isBlank()) return&#13;&#10;        fun attemptSync(attemptsLeft: Int) {&#13;&#10;            if (attemptsLeft &lt;= 0) {&#13;&#10;                Log.e(&quot;FirebaseHelper&quot;, &quot;Failed to sync score after all retries&quot;)&#13;&#10;                return&#13;&#10;            }&#13;&#10;            updateScore(playerName, score)&#13;&#10;            android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({&#13;&#10;                getScore(playerName) { retrievedScore -&gt;&#13;&#10;                    if (retrievedScore != score &amp;&amp; attemptsLeft &gt; 1) {&#13;&#10;                        Log.w(&quot;FirebaseHelper&quot;, &quot;Score mismatch, retrying... ($attemptsLeft attempts left)&quot;)&#13;&#10;                        attemptSync(attemptsLeft - 1)&#13;&#10;                    } else {&#13;&#10;                        Log.d(&quot;FirebaseHelper&quot;, &quot;Score sync successful: $score&quot;)&#13;&#10;                    }&#13;&#10;                }&#13;&#10;            }, 1000)&#13;&#10;        }&#13;&#10;        attemptSync(retryCount)&#13;&#10;    }&#13;&#10;&#13;&#10;    // Auto-sync score every 30 seconds&#13;&#10;    fun startPeriodicScoreSync(playerName: String, getCurrentScore: () -&gt; Int) {&#13;&#10;        if (playerName.isBlank()) return&#13;&#10;        val handler = android.os.Handler(android.os.Looper.getMainLooper())&#13;&#10;        val syncRunnable = object : Runnable {&#13;&#10;            override fun run() {&#13;&#10;                val currentScore = getCurrentScore()&#13;&#10;                Log.d(&quot;FirebaseHelper&quot;, &quot;Periodic sync: $currentScore points for $playerName&quot;)&#13;&#10;                updateScore(playerName, currentScore)&#13;&#10;                handler.postDelayed(this, 30000)&#13;&#10;            }&#13;&#10;        }&#13;&#10;        handler.post(syncRunnable)&#13;&#10;    }&#13;&#10;&#13;&#10;    // ---------------- CHEST ----------------&#13;&#10;    fun getChestItems(playerName: String, onResult: (List&lt;ChestItem&gt;) -&gt; Unit) {&#13;&#10;        db.collection(&quot;rankings&quot;)&#13;&#10;            .whereEqualTo(&quot;name&quot;, playerName)&#13;&#10;            .get()&#13;&#10;            .addOnSuccessListener { docs -&gt;&#13;&#10;                if (!docs.isEmpty) {&#13;&#10;                    val chestRaw = docs.documents[0].get(&quot;chest&quot;)&#13;&#10;                    val chest: List&lt;ChestItem&gt; = when (chestRaw) {&#13;&#10;                        is List&lt;*&gt; -&gt; {&#13;&#10;                            if (chestRaw.firstOrNull() is Map&lt;*, *&gt;) {&#13;&#10;                                @Suppress(&quot;UNCHECKED_CAST&quot;)&#13;&#10;                                val maps = chestRaw as List&lt;Map&lt;String, Any&gt;&gt;&#13;&#10;                                maps.mapNotNull { m -&gt;&#13;&#10;                                    val name = m[&quot;name&quot;] as? String&#13;&#10;                                    val res = (m[&quot;resId&quot;] as? Number)?.toInt()&#13;&#10;                                    if (name != null &amp;&amp; res != null) ChestItem(name, res) else null&#13;&#10;                                }&#13;&#10;                            } else if (chestRaw.firstOrNull() is String) {&#13;&#10;                                val names = chestRaw.filterIsInstance&lt;String&gt;()&#13;&#10;                                names.map { n -&gt; ChestItem(n, resolveResIdFromName(n)) }&#13;&#10;                            } else emptyList()&#13;&#10;                        }&#13;&#10;                        else -&gt; emptyList()&#13;&#10;                    }&#13;&#10;                    onResult(chest)&#13;&#10;                } else {&#13;&#10;                    onResult(emptyList())&#13;&#10;                }&#13;&#10;            }&#13;&#10;            .addOnFailureListener {&#13;&#10;                onResult(emptyList())&#13;&#10;            }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun addItemToChest(playerName: String, newItem: ChestItem) {&#13;&#10;        db.collection(&quot;rankings&quot;)&#13;&#10;            .whereEqualTo(&quot;name&quot;, playerName)&#13;&#10;            .get()&#13;&#10;            .addOnSuccessListener { docs -&gt;&#13;&#10;                if (!docs.isEmpty) {&#13;&#10;                    val doc = docs.documents[0]&#13;&#10;                    val docId = doc.id&#13;&#10;                    val chestList = doc.get(&quot;chest&quot;) as? MutableList&lt;Map&lt;String, Any&gt;&gt; ?: mutableListOf()&#13;&#10;                    chestList.add(mapOf(&quot;name&quot; to newItem.name, &quot;resId&quot; to newItem.resId))&#13;&#10;                    db.collection(&quot;rankings&quot;).document(docId)&#13;&#10;                        .update(&quot;chest&quot;, chestList)&#13;&#10;                } else {&#13;&#10;                    val data = hashMapOf(&#13;&#10;                        &quot;name&quot; to playerName,&#13;&#10;                        &quot;score&quot; to 0,&#13;&#10;                        &quot;chest&quot; to listOf(mapOf(&quot;name&quot; to newItem.name, &quot;resId&quot; to newItem.resId)),&#13;&#10;                        &quot;scoreHistory&quot; to emptyList&lt;Map&lt;String, Any&gt;&gt;()&#13;&#10;                    )&#13;&#10;                    db.collection(&quot;rankings&quot;).add(data)&#13;&#10;                }&#13;&#10;            }&#13;&#10;            .addOnFailureListener { e -&gt;&#13;&#10;                Log.w(&quot;FirebaseHelper&quot;, &quot;addItemToChest failed&quot;, e)&#13;&#10;            }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun updateChest(playerName: String, newChest: List&lt;ChestItem&gt;, onComplete: (() -&gt; Unit)? = null) {&#13;&#10;        db.collection(&quot;rankings&quot;)&#13;&#10;            .whereEqualTo(&quot;name&quot;, playerName)&#13;&#10;            .get()&#13;&#10;            .addOnSuccessListener { docs -&gt;&#13;&#10;                if (!docs.isEmpty) {&#13;&#10;                    val docId = docs.documents[0].id&#13;&#10;                    val chestMapList = newChest.map { mapOf(&quot;name&quot; to it.name, &quot;resId&quot; to it.resId) }&#13;&#10;                    db.collection(&quot;rankings&quot;)&#13;&#10;                        .document(docId)&#13;&#10;                        .update(&quot;chest&quot;, chestMapList)&#13;&#10;                        .addOnSuccessListener { onComplete?.invoke() }&#13;&#10;                }&#13;&#10;            }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/game/GameScreenActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/game/GameScreenActivity.kt" />
              <option name="originalContent" value="package com.example.game&#10;&#10;import android.os.Bundle&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.TopBarComponent.TopBarUI&#10;import com.example.game.core.*&#10;import com.example.game.ui.PlaneUI&#10;import com.example.game.ui.MonsterUI&#10;import com.example.game.ui.WallUI&#10;import com.example.game.ui.SoundControlButton&#10;import com.example.game.ui.BagCoinAnimatedView&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.roundToInt&#10;import kotlin.random.Random&#10;&#10;class GameScreenActivity : BaseGameActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        initAudio()&#10;&#10;        // Initialize AI Avoidance Helper for smart bullet dodging&#10;        try {&#10;            AIAvoidanceHelper.init(this)&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;GameScreenActivity&quot;, &quot;AI init failed: ${e.message}&quot;, e)&#10;            // Continue without AI - game will still work with basic logic&#10;        }&#10;&#10;        setContent {&#10;            val density = LocalDensity.current&#10;            val screenWidthPx = with(density) { LocalConfiguration.current.screenWidthDp.dp.toPx() }&#10;            val screenHeightPx = with(density) { LocalConfiguration.current.screenHeightDp.dp.toPx() }&#10;&#10;            GameScreen(&#10;                screenWidthPx = screenWidthPx,&#10;                screenHeightPx = screenHeightPx,&#10;                soundPool = soundPool,&#10;                shootSoundId = shootSoundId,&#10;                hitSoundId = hitSoundId,&#10;                onExit = { finish() }&#10;            )&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        try {&#10;            AIAvoidanceHelper.release()&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;GameScreenActivity&quot;, &quot;AI release failed: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun GameScreen(&#10;    screenWidthPx: Float,&#10;    screenHeightPx: Float,&#10;    soundPool: android.media.SoundPool,&#10;    shootSoundId: Int,&#10;    hitSoundId: Int,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val playerName = PrefManager.getPlayerName(context)&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // --- State ---&#10;    var totalScore by remember { mutableStateOf(0) }&#10;    var currentSessionScore by remember { mutableStateOf(0) }&#10;    var planeHp by remember { mutableStateOf(100) } // 0..100&#10;&#10;    var shieldActive by remember { mutableStateOf(false) }&#10;    var wallActive by remember { mutableStateOf(false) }&#10;    var timeActive by remember { mutableStateOf(false) }&#10;&#10;    var isGameOver by remember { mutableStateOf(false) }&#10;    var isLevelClear by remember { mutableStateOf(false) }&#10;    var showGameEndDialog by remember { mutableStateOf(false) }&#10;&#10;    // Show dialog when game ends instead of navigating to new activity&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        if (isGameOver || isLevelClear) {&#10;            delay(500)&#10;            showGameEndDialog = true&#10;        }&#10;    }&#10;&#10;    // --- Plane ---&#10;    var planeX by remember { mutableStateOf(screenWidthPx / 2 - 50f) }&#10;    val planeY = screenHeightPx - 250f&#10;    val planeWidth = 100f&#10;    val planeHeight = 100f&#10;&#10;    // --- Background (2 images loop) ---&#10;    var offsetY by remember { mutableStateOf(0f) }&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            offsetY += 4f&#10;            // Sử dụng modulo để giữ chuyển động liên tục&#10;            if (offsetY &gt;= screenHeightPx) {&#10;                offsetY %= screenHeightPx&#10;            }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Entities ---&#10;    val monsters = remember {&#10;        List(10) {&#10;            BaseMonster(&#10;                x = Random.nextFloat() * (screenWidthPx - 100f),&#10;                // Spawn monsters at different Y positions (more spread out)&#10;                y = mutableStateOf(-Random.nextInt(200, 2000).toFloat()), // Increased range&#10;                speed = Random.nextFloat() * 1.5f + 1.5f,&#10;                hp = mutableStateOf(100)&#10;            )&#10;        }&#10;    }&#10;&#10;    // Track respawn times for each monster&#10;    val monsterRespawnTimes = remember { MutableList(monsters.size) { 0L } }&#10;&#10;    val coins = remember {&#10;        List(6) {&#10;            BaseCoin(&#10;                x = Random.nextFloat() * (screenWidthPx - 50f),&#10;                y = mutableStateOf(-Random.nextInt(100, 600).toFloat()),&#10;                speed = Random.nextFloat() * 2f + 1f&#10;            )&#10;        }&#10;    }&#10;&#10;    val bullets = remember { mutableStateListOf&lt;Bullet&gt;() }&#10;    val bagCoins = remember { mutableStateListOf&lt;BagCoinDisplay&gt;() } // uses core.BagCoinDisplay&#10;    var chestItems by remember { mutableStateOf&lt;List&lt;ChestItem&gt;&gt;(emptyList()) }&#10;&#10;    // --- Load player data (score / chest) ---&#10;    LaunchedEffect(Unit) {&#10;        if (!playerName.isNullOrBlank()) {&#10;            FirebaseHelper.syncNewPlayer(playerName)&#10;            FirebaseHelper.getScore(playerName) { totalScore = it }&#10;            FirebaseHelper.getChestItems(playerName) { chestItems = it }&#10;        }&#10;    }&#10;&#10;    // --- Shooting ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.add(Bullet(planeX + planeWidth / 2f - 15f, planeY))&#10;            SoundManager.playSoundEffect(soundPool, shootSoundId, 0.5f)&#10;            delay(350)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.forEach { it.y -= 20f }&#10;            bullets.removeAll { it.y &lt; -40f }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Monster movement ---&#10;    monsters.forEachIndexed { index, m -&gt;&#10;        LaunchedEffect(m, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                // Check if monster needs to respawn after death&#10;                if (!m.alive.value &amp;&amp; System.currentTimeMillis() &gt;= monsterRespawnTimes[index]) {&#10;                    // Respawn the monster at a random position&#10;                    m.y.value = -Random.nextInt(200, 1500).toFloat()&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 100f)&#10;                    m.hp.value = 100&#10;                    m.alive.value = true&#10;                }&#10;&#10;                if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp; !timeActive) {&#10;                    // AI-based evasion: monster tries to dodge bullets intelligently&#10;                    val evasion = AIAvoidanceHelper.calculateEvasion(&#10;                        monsterX = m.x,&#10;                        monsterY = m.y.value,&#10;                        monsterSize = 100f,&#10;                        bullets = bullets,&#10;                        screenWidth = screenWidthPx&#10;                    )&#10;&#10;                    // Apply evasion movement (horizontal dodge)&#10;                    m.x = (m.x + evasion.first).coerceIn(0f, screenWidthPx - 100f)&#10;&#10;                    // Wall is at planeY - 60f, so stop monsters closer to actually touch it&#10;                    val wallTop = planeY - 60f&#10;                    val monsterBottom = m.y.value + 80f // Monster height is 80px&#10;&#10;                    if (wallActive &amp;&amp; monsterBottom &gt;= wallTop) {&#10;                        // Monster has reached wall - STOP here&#10;                        // Wall collision check will drain HP&#10;                    } else {&#10;                        // Normal movement&#10;                        m.y.value += m.speed&#10;                    }&#10;&#10;                    // If monster falls below plane (passed), damage plane and respawn&#10;                    if (m.y.value &gt; planeY + planeHeight / 2f) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) planeHp -= 50&#10;                        // Schedule respawn with random delay (3-8 seconds)&#10;                        monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 8000)&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;                delay(16)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Coin movement ---&#10;    coins.forEach { c -&gt;&#10;        LaunchedEffect(c, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                if (!c.collected.value &amp;&amp; !timeActive) {&#10;                    c.y.value += c.speed&#10;                    if (c.y.value &gt; screenHeightPx) {&#10;                        c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                        c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                    }&#10;                }&#10;                delay(32)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Bullet vs Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            val iter = bullets.iterator()&#10;            while (iter.hasNext()) {&#10;                val b = iter.next()&#10;                monsters.forEach { m -&gt;&#10;                    if (CollisionUtils.checkCollisionBulletMonster(b, m)) {&#10;                        // hit: reduce monster HP&#10;                        m.hp.value -= 25&#10;                        // Play hit sound&#10;                        SoundManager.playSoundEffect(soundPool, hitSoundId, 0.3f)&#10;                        iter.remove()&#10;                        if (m.hp.value &lt;= 0) {&#10;                            m.alive.value = false&#10;                            // Schedule respawn with random delay (3-8 seconds)&#10;                            val index = monsters.indexOf(m)&#10;                            if (index &gt;= 0) {&#10;                                monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 8000)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            // DON'T check for level clear here - let monsters respawn naturally&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Coin collision (collect coin) ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            coins.forEach { c -&gt;&#10;                if (!c.collected.value &amp;&amp; CollisionUtils.checkCollisionPlaneCoin(planeX, planeY, planeWidth, planeHeight, c)) {&#10;                    c.collected.value = true&#10;                    totalScore += 1&#10;                    currentSessionScore += 1&#10;                    // add bag coin display (will be animated in UI)&#10;                    val bag = BagCoinDisplay(c.x, c.y.value, 1)&#10;                    bagCoins.add(bag)&#10;                    // update backend&#10;                    if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Monster collision (direct hit) ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            monsters.forEach { m -&gt;&#10;                if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp;&#10;                    CollisionUtils.checkCollisionPlaneMonster(planeX, planeY, planeWidth, planeHeight, m)&#10;                ) {&#10;                    if (!shieldActive &amp;&amp; !wallActive) planeHp -= 50&#10;                    // kill this monster&#10;                    m.hp.value = 0&#10;                    m.alive.value = false&#10;                }&#10;            }&#10;            if (planeHp &lt;= 0) isGameOver = true&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Wall - Monster collision (wall damages monsters) ---&#10;    LaunchedEffect(wallActive, isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            if (wallActive) {&#10;                monsters.forEach { m -&gt;&#10;                    if (m.alive.value &amp;&amp; m.hp.value &gt; 0) {&#10;                        val isColliding = CollisionUtils.checkCollisionWallMonster(planeY, m)&#10;                        if (isColliding) {&#10;                            // Wall drains monster HP continuously&#10;                            m.hp.value -= 2 // Drain 2 HP per tick&#10;                            if (m.hp.value &lt;= 0) {&#10;                                m.alive.value = false&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(50) // Check every 50ms&#10;        }&#10;    }&#10;&#10;    // --- Use chest item wrapper ---&#10;    fun useChestItem(item: ChestItem) {&#10;        ChestItemEffectsBase.applyItemEffect(&#10;            itemName = item.name,&#10;            monsters = monsters,&#10;            coins = coins,&#10;            bagCoins = bagCoins,&#10;            coroutineScope = coroutineScope,&#10;            screenHeightPx = screenHeightPx,&#10;            planeX = planeX,&#10;            onScoreUpdate = { add -&gt;&#10;                totalScore += add&#10;                currentSessionScore += add&#10;                if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;            },&#10;            onShieldToggle = { active -&gt; shieldActive = active },&#10;            onWallToggle = { active -&gt; wallActive = active },&#10;            onTimeToggle = { active -&gt; timeActive = active },&#10;            onLevelClear = { isLevelClear = true }&#10;        )&#10;        chestItems = chestItems - item&#10;        if (!playerName.isNullOrBlank()) FirebaseHelper.updateChest(playerName, chestItems)&#10;    }&#10;&#10;    // --- Drag plane ---&#10;    val dragModifier = Modifier.pointerInput(Unit) {&#10;        detectDragGestures { change, dragAmount -&gt;&#10;            planeX = (planeX + dragAmount.x).coerceIn(0f, screenWidthPx - planeWidth)&#10;            change.consume()&#10;        }&#10;    }&#10;&#10;    // --- UI ---&#10;    Box(modifier = Modifier.fillMaxSize()) {&#10;        // Background layer - separate from drag gestures&#10;        Box(modifier = Modifier.fillMaxSize()) {&#10;            // Hình nền chính&#10;            Image(&#10;                painter = painterResource(R.drawable.nen2),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .offset { IntOffset(0, offsetY.roundToInt()) },&#10;                contentScale = ContentScale.Crop&#10;            )&#10;            // Hình nền phụ để tạo hiệu ứng lặp&#10;            Image(&#10;                painter = painterResource(R.drawable.nen2),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .offset { IntOffset(0, (offsetY - screenHeightPx).roundToInt()) },&#10;                contentScale = ContentScale.Crop&#10;            )&#10;        }&#10;&#10;        // Game content with drag gesture&#10;        Box(modifier = Modifier.fillMaxSize().then(dragModifier)) {&#10;            // --- Monsters (using MonsterUI component) ---&#10;            monsters.forEach { m -&gt;&#10;                MonsterUI(monster = m)&#10;            }&#10;&#10;            // --- Coins ---&#10;            coins.filter { !it.collected.value }.forEach { c -&gt;&#10;                Image(&#10;                    painter = painterResource(R.drawable.coin),&#10;                    contentDescription = null,&#10;                    modifier = Modifier&#10;                        .absoluteOffset { IntOffset(c.x.roundToInt(), c.y.value.roundToInt()) }&#10;                        .size(40.dp)&#10;                )&#10;            }&#10;&#10;            // --- BagCoin animated views (spawned when coin collected) ---&#10;            bagCoins.toList().forEach { bag -&gt;&#10;                BagCoinAnimatedView(bag = bag, onFinished = { finishedBag -&gt;&#10;                    bagCoins.remove(finishedBag)&#10;                })&#10;            }&#10;&#10;            // --- Bullets ---&#10;            bullets.forEach { b -&gt;&#10;                Image(&#10;                    painter = painterResource(R.drawable.dan2),&#10;                    contentDescription = null,&#10;                    modifier = Modifier&#10;                        .absoluteOffset { IntOffset(b.x.roundToInt(), b.y.roundToInt()) }&#10;                        .size(30.dp)&#10;                )&#10;            }&#10;&#10;            // --- Plane (using PlaneUI component) ---&#10;            PlaneUI(&#10;                planeX = planeX,&#10;                planeY = planeY,&#10;                planeHp = planeHp,&#10;                shieldActive = shieldActive&#10;            )&#10;&#10;            // --- Wall effect (using WallUI component) ---&#10;            if (wallActive) {&#10;                WallUI(planeY = planeY)&#10;            }&#10;&#10;            // --- Top bar with chest items and score ---&#10;            TopBarUI(&#10;                bagCoinScore = totalScore,&#10;                chestItems = chestItems,&#10;                onBuyItem = { item, price -&gt;&#10;                    if (totalScore &gt;= price) {&#10;                        totalScore -= price&#10;                        chestItems = chestItems + item&#10;                        if (!playerName.isNullOrBlank()) {&#10;                            FirebaseHelper.updateScore(playerName, totalScore)&#10;                            FirebaseHelper.updateChest(playerName, chestItems)&#10;                        }&#10;                    }&#10;                },&#10;                onUseChestItem = { useChestItem(it) }&#10;            )&#10;&#10;            // --- Sound Control Button (top-right corner) ---&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(16.dp),&#10;                contentAlignment = Alignment.TopEnd&#10;            ) {&#10;                SoundControlButton()&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Game End Dialog ---&#10;    if (showGameEndDialog) {&#10;        GameEndDialog(&#10;            isWin = isLevelClear,&#10;            score = currentSessionScore,&#10;            level = 1,&#10;            onDismiss = {&#10;                showGameEndDialog = false&#10;            },&#10;            onReplay = {&#10;                // Reset game state to replay&#10;                showGameEndDialog = false&#10;                isGameOver = false&#10;                isLevelClear = false&#10;                planeHp = 100&#10;                currentSessionScore = 0&#10;&#10;                // Reset monsters&#10;                monsters.forEachIndexed { index, m -&gt;&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 100f)&#10;                    m.y.value = -Random.nextInt(200, 2000).toFloat()&#10;                    m.hp.value = 100&#10;                    m.alive.value = true&#10;                    monsterRespawnTimes[index] = 0L&#10;                }&#10;&#10;                // Reset coins&#10;                coins.forEach { c -&gt;&#10;                    c.collected.value = false&#10;                    c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                    c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                }&#10;&#10;                // Clear bullets&#10;                bullets.clear()&#10;            },&#10;            onNextLevel = {&#10;                // Navigate to next level handled by GameEndDialog itself&#10;                onExit() // Close this activity&#10;            },&#10;            onExit = {&#10;                // Back to main menu&#10;                onExit()&#10;            }&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.game&#10;&#10;import android.os.Bundle&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.TopBarComponent.TopBarUI&#10;import com.example.game.core.*&#10;import com.example.game.ui.PlaneUI&#10;import com.example.game.ui.MonsterUI&#10;import com.example.game.ui.WallUI&#10;import com.example.game.ui.SoundControlButton&#10;import com.example.game.ui.BagCoinAnimatedView&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.roundToInt&#10;import kotlin.random.Random&#10;&#10;class GameScreenActivity : BaseGameActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        initAudio()&#10;&#10;        // Initialize AI Avoidance Helper for smart bullet dodging&#10;        try {&#10;            AIAvoidanceHelper.init(this)&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;GameScreenActivity&quot;, &quot;AI init failed: ${e.message}&quot;, e)&#10;            // Continue without AI - game will still work with basic logic&#10;        }&#10;&#10;        setContent {&#10;            val density = LocalDensity.current&#10;            val screenWidthPx = with(density) { LocalConfiguration.current.screenWidthDp.dp.toPx() }&#10;            val screenHeightPx = with(density) { LocalConfiguration.current.screenHeightDp.dp.toPx() }&#10;&#10;            GameScreen(&#10;                screenWidthPx = screenWidthPx,&#10;                screenHeightPx = screenHeightPx,&#10;                soundPool = soundPool,&#10;                shootSoundId = shootSoundId,&#10;                hitSoundId = hitSoundId,&#10;                onExit = { finish() }&#10;            )&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        try {&#10;            AIAvoidanceHelper.release()&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;GameScreenActivity&quot;, &quot;AI release failed: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun GameScreen(&#10;    screenWidthPx: Float,&#10;    screenHeightPx: Float,&#10;    soundPool: android.media.SoundPool,&#10;    shootSoundId: Int,&#10;    hitSoundId: Int,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val playerName = PrefManager.getPlayerName(context)&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // --- State ---&#10;    var totalScore by remember { mutableStateOf(0) }&#10;    var currentSessionScore by remember { mutableStateOf(0) }&#10;    var planeHp by remember { mutableStateOf(100) } // 0..100&#10;&#10;    var shieldActive by remember { mutableStateOf(false) }&#10;    var wallActive by remember { mutableStateOf(false) }&#10;    var timeActive by remember { mutableStateOf(false) }&#10;&#10;    var isGameOver by remember { mutableStateOf(false) }&#10;    var isLevelClear by remember { mutableStateOf(false) }&#10;    var showGameEndDialog by remember { mutableStateOf(false) }&#10;&#10;    // Show dialog when game ends instead of navigating to new activity&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        if (isGameOver || isLevelClear) {&#10;            delay(500)&#10;            showGameEndDialog = true&#10;        }&#10;    }&#10;&#10;    // --- Plane ---&#10;    var planeX by remember { mutableStateOf(screenWidthPx / 2 - 50f) }&#10;    val planeY = screenHeightPx - 250f&#10;    val planeWidth = 100f&#10;    val planeHeight = 100f&#10;&#10;    // --- Background (2 images loop) ---&#10;    var offsetY by remember { mutableStateOf(0f) }&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            offsetY += 4f&#10;            // Sử dụng modulo để giữ chuyển động liên tục&#10;            if (offsetY &gt;= screenHeightPx) {&#10;                offsetY %= screenHeightPx&#10;            }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Entities ---&#10;    val monsters = remember {&#10;        List(10) {&#10;            BaseMonster(&#10;                x = Random.nextFloat() * (screenWidthPx - 100f),&#10;                // Spawn monsters at different Y positions (more spread out)&#10;                y = mutableStateOf(-Random.nextInt(200, 2000).toFloat()), // Increased range&#10;                speed = Random.nextFloat() * 1.5f + 1.5f,&#10;                hp = mutableStateOf(100)&#10;            )&#10;        }&#10;    }&#10;&#10;    // Track respawn times for each monster&#10;    val monsterRespawnTimes = remember { MutableList(monsters.size) { 0L } }&#10;&#10;    val coins = remember {&#10;        List(6) {&#10;            BaseCoin(&#10;                x = Random.nextFloat() * (screenWidthPx - 50f),&#10;                y = mutableStateOf(-Random.nextInt(100, 600).toFloat()),&#10;                speed = Random.nextFloat() * 2f + 1f&#10;            )&#10;        }&#10;    }&#10;&#10;    val bullets = remember { mutableStateListOf&lt;Bullet&gt;() }&#10;    val bagCoins = remember { mutableStateListOf&lt;BagCoinDisplay&gt;() } // uses core.BagCoinDisplay&#10;    var chestItems by remember { mutableStateOf&lt;List&lt;ChestItem&gt;&gt;(emptyList()) }&#10;&#10;    // --- Load player data (score / chest) ---&#10;    LaunchedEffect(Unit) {&#10;        if (!playerName.isNullOrBlank()) {&#10;            FirebaseHelper.syncNewPlayer(playerName)&#10;            FirebaseHelper.getScore(playerName) { totalScore = it }&#10;            FirebaseHelper.getChestItems(playerName) { chestItems = it }&#10;        }&#10;    }&#10;&#10;    // --- Shooting ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.add(Bullet(planeX + planeWidth / 2f - 15f, planeY))&#10;            SoundManager.playSoundEffect(soundPool, shootSoundId, 0.5f)&#10;            delay(350)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.forEach { it.y -= 20f }&#10;            bullets.removeAll { it.y &lt; -40f }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Monster movement ---&#10;    monsters.forEachIndexed { index, m -&gt;&#10;        LaunchedEffect(m, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                // Check if monster needs to respawn after death&#10;                if (!m.alive.value &amp;&amp; System.currentTimeMillis() &gt;= monsterRespawnTimes[index]) {&#10;                    // Respawn the monster at a random position&#10;                    m.y.value = -Random.nextInt(200, 1500).toFloat()&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 100f)&#10;                    m.hp.value = 100&#10;                    m.alive.value = true&#10;                }&#10;&#10;                if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp; !timeActive) {&#10;                    // AI-based evasion: monster tries to dodge bullets intelligently&#10;                    val evasion = AIAvoidanceHelper.calculateEvasion(&#10;                        monsterX = m.x,&#10;                        monsterY = m.y.value,&#10;                        monsterSize = 100f,&#10;                        bullets = bullets,&#10;                        screenWidth = screenWidthPx&#10;                    )&#10;&#10;                    // Apply evasion movement (horizontal dodge)&#10;                    m.x = (m.x + evasion.first).coerceIn(0f, screenWidthPx - 100f)&#10;&#10;                    // Wall is at planeY - 60f, so stop monsters closer to actually touch it&#10;                    val wallTop = planeY - 60f&#10;                    val monsterBottom = m.y.value + 80f // Monster height is 80px&#10;&#10;                    if (wallActive &amp;&amp; monsterBottom &gt;= wallTop) {&#10;                        // Monster has reached wall - STOP here&#10;                        // Wall collision check will drain HP&#10;                    } else {&#10;                        // Normal movement&#10;                        m.y.value += m.speed&#10;                    }&#10;&#10;                    // If monster falls below plane (passed), damage plane and respawn&#10;                    if (m.y.value &gt; planeY + planeHeight / 2f) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) planeHp -= 50&#10;                        // Schedule respawn with random delay (3-8 seconds)&#10;                        monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 8000)&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;                delay(16)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Coin movement ---&#10;    coins.forEach { c -&gt;&#10;        LaunchedEffect(c, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                if (!c.collected.value &amp;&amp; !timeActive) {&#10;                    c.y.value += c.speed&#10;                    if (c.y.value &gt; screenHeightPx) {&#10;                        c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                        c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                    }&#10;                }&#10;                delay(32)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Bullet vs Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            val iter = bullets.iterator()&#10;            while (iter.hasNext()) {&#10;                val b = iter.next()&#10;                monsters.forEach { m -&gt;&#10;                    if (CollisionUtils.checkCollisionBulletMonster(b, m)) {&#10;                        // hit: reduce monster HP&#10;                        m.hp.value -= 25&#10;                        // Play hit sound&#10;                        SoundManager.playSoundEffect(soundPool, hitSoundId, 0.3f)&#10;                        iter.remove()&#10;                        if (m.hp.value &lt;= 0) {&#10;                            m.alive.value = false&#10;                            // Schedule respawn with random delay (3-8 seconds)&#10;                            val index = monsters.indexOf(m)&#10;                            if (index &gt;= 0) {&#10;                                monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 8000)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            // DON'T check for level clear here - let monsters respawn naturally&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Coin collision (collect coin) ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            coins.forEach { c -&gt;&#10;                if (!c.collected.value &amp;&amp; CollisionUtils.checkCollisionPlaneCoin(planeX, planeY, planeWidth, planeHeight, c)) {&#10;                    c.collected.value = true&#10;                    totalScore += 1&#10;                    currentSessionScore += 1&#10;                    // add bag coin display (will be animated in UI)&#10;                    val bag = BagCoinDisplay(c.x, c.y.value, 1)&#10;                    bagCoins.add(bag)&#10;                    // update backend&#10;                    if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Monster collision (direct hit) ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            monsters.forEach { m -&gt;&#10;                if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp;&#10;                    CollisionUtils.checkCollisionPlaneMonster(planeX, planeY, planeWidth, planeHeight, m)&#10;                ) {&#10;                    if (!shieldActive &amp;&amp; !wallActive) planeHp -= 50&#10;                    // kill this monster&#10;                    m.hp.value = 0&#10;                    m.alive.value = false&#10;                }&#10;            }&#10;            if (planeHp &lt;= 0) isGameOver = true&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Wall - Monster collision (wall damages monsters) ---&#10;    LaunchedEffect(wallActive, isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            if (wallActive) {&#10;                monsters.forEach { m -&gt;&#10;                    if (m.alive.value &amp;&amp; m.hp.value &gt; 0) {&#10;                        val isColliding = CollisionUtils.checkCollisionWallMonster(planeY, m)&#10;                        if (isColliding) {&#10;                            // Wall drains monster HP continuously&#10;                            m.hp.value -= 2 // Drain 2 HP per tick&#10;                            if (m.hp.value &lt;= 0) {&#10;                                m.alive.value = false&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(50) // Check every 50ms&#10;        }&#10;    }&#10;&#10;    // --- Use chest item wrapper ---&#10;    fun useChestItem(item: ChestItem) {&#10;        ChestItemEffectsBase.applyItemEffect(&#10;            itemName = item.name,&#10;            monsters = monsters,&#10;            coins = coins,&#10;            bagCoins = bagCoins,&#10;            coroutineScope = coroutineScope,&#10;            screenHeightPx = screenHeightPx,&#10;            planeX = planeX,&#10;            onScoreUpdate = { add -&gt;&#10;                totalScore += add&#10;                currentSessionScore += add&#10;                if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;            },&#10;            onShieldToggle = { active -&gt; shieldActive = active },&#10;            onWallToggle = { active -&gt; wallActive = active },&#10;            onTimeToggle = { active -&gt; timeActive = active },&#10;            onLevelClear = { isLevelClear = true }&#10;        )&#10;        chestItems = chestItems - item&#10;        if (!playerName.isNullOrBlank()) FirebaseHelper.updateChest(playerName, chestItems)&#10;    }&#10;&#10;    // --- Drag plane ---&#10;    val dragModifier = Modifier.pointerInput(Unit) {&#10;        detectDragGestures { change, dragAmount -&gt;&#10;            planeX = (planeX + dragAmount.x).coerceIn(0f, screenWidthPx - planeWidth)&#10;            change.consume()&#10;        }&#10;    }&#10;&#10;    // --- UI ---&#10;    Box(modifier = Modifier.fillMaxSize()) {&#10;        // Background layer - separate from drag gestures&#10;        Box(modifier = Modifier.fillMaxSize()) {&#10;            // Hình nền chính&#10;            Image(&#10;                painter = painterResource(R.drawable.nen2),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .offset { IntOffset(0, offsetY.roundToInt()) },&#10;                contentScale = ContentScale.Crop&#10;            )&#10;            // Hình nền phụ để tạo hiệu ứng lặp&#10;            Image(&#10;                painter = painterResource(R.drawable.nen2),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .offset { IntOffset(0, (offsetY - screenHeightPx).roundToInt()) },&#10;                contentScale = ContentScale.Crop&#10;            )&#10;        }&#10;&#10;        // Game content with drag gesture&#10;        Box(modifier = Modifier.fillMaxSize().then(dragModifier)) {&#10;            // --- Monsters (using MonsterUI component) ---&#10;            monsters.forEach { m -&gt;&#10;                MonsterUI(monster = m)&#10;            }&#10;&#10;            // --- Coins ---&#10;            coins.filter { !it.collected.value }.forEach { c -&gt;&#10;                Image(&#10;                    painter = painterResource(R.drawable.coin),&#10;                    contentDescription = null,&#10;                    modifier = Modifier&#10;                        .absoluteOffset { IntOffset(c.x.roundToInt(), c.y.value.roundToInt()) }&#10;                        .size(40.dp)&#10;                )&#10;            }&#10;&#10;            // --- BagCoin animated views (spawned when coin collected) ---&#10;            bagCoins.toList().forEach { bag -&gt;&#10;                BagCoinAnimatedView(bag = bag, onFinished = { finishedBag -&gt;&#10;                    bagCoins.remove(finishedBag)&#10;                })&#10;            }&#10;&#10;            // --- Bullets ---&#10;            bullets.forEach { b -&gt;&#10;                Image(&#10;                    painter = painterResource(R.drawable.dan2),&#10;                    contentDescription = null,&#10;                    modifier = Modifier&#10;                        .absoluteOffset { IntOffset(b.x.roundToInt(), b.y.roundToInt()) }&#10;                        .size(30.dp)&#10;                )&#10;            }&#10;&#10;            // --- Plane (using PlaneUI component) ---&#10;            PlaneUI(&#10;                planeX = planeX,&#10;                planeY = planeY,&#10;                planeHp = planeHp,&#10;                shieldActive = shieldActive&#10;            )&#10;&#10;            // --- Wall effect (using WallUI component) ---&#10;            if (wallActive) {&#10;                WallUI(planeY = planeY)&#10;            }&#10;&#10;            // --- Top bar with chest items and score ---&#10;            TopBarUI(&#10;                bagCoinScore = totalScore,&#10;                chestItems = chestItems,&#10;                onBuyItem = { item, price -&gt;&#10;                    if (totalScore &gt;= price) {&#10;                        totalScore -= price&#10;                        chestItems = chestItems + item&#10;                        if (!playerName.isNullOrBlank()) {&#10;                            FirebaseHelper.updateScore(playerName, totalScore)&#10;                            FirebaseHelper.updateChest(playerName, chestItems)&#10;                        }&#10;                    }&#10;                },&#10;                onUseChestItem = { useChestItem(it) }&#10;            )&#10;&#10;            // --- Sound Control Button (top-right corner) ---&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(16.dp),&#10;                contentAlignment = Alignment.TopEnd&#10;            ) {&#10;                SoundControlButton()&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Game End Dialog ---&#10;    if (showGameEndDialog) {&#10;        GameEndDialog(&#10;            isWin = isLevelClear,&#10;            score = currentSessionScore,&#10;            level = 1,&#10;            onDismiss = {&#10;                showGameEndDialog = false&#10;            },&#10;            onReplay = {&#10;                // Reset game state to replay&#10;                showGameEndDialog = false&#10;                isGameOver = false&#10;                isLevelClear = false&#10;                planeHp = 100&#10;                currentSessionScore = 0&#10;&#10;                // Reset monsters&#10;                monsters.forEachIndexed { index, m -&gt;&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 100f)&#10;                    m.y.value = -Random.nextInt(200, 2000).toFloat()&#10;                    m.hp.value = 100&#10;                    m.alive.value = true&#10;                    monsterRespawnTimes[index] = 0L&#10;                }&#10;&#10;                // Reset coins&#10;                coins.forEach { c -&gt;&#10;                    c.collected.value = false&#10;                    c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                    c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                }&#10;&#10;                // Clear bullets&#10;                bullets.clear()&#10;            },&#10;            onNextLevel = {&#10;                // Navigate to next level handled by GameEndDialog itself&#10;                onExit() // Close this activity&#10;            },&#10;            onExit = {&#10;                // Back to main menu&#10;                onExit()&#10;            },&#10;            playerName = playerName,&#10;            totalScore = totalScore&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/game/Level2Activity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/game/Level2Activity.kt" />
              <option name="originalContent" value="package com.example.game&#10;&#10;import android.os.Bundle&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.TopBarComponent.TopBarUI&#10;import com.example.game.core.*&#10;import com.example.game.ui.PlaneUI&#10;import com.example.game.ui.MonsterUI&#10;import com.example.game.ui.WallUI&#10;import com.example.game.ui.SoundControlButton&#10;import com.example.game.ui.BagCoinAnimatedView&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.*&#10;import kotlin.random.Random&#10;&#10;class Level2Activity : BaseGameActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        initAudio()&#10;&#10;        // Initialize AI Avoidance Helper for smart bullet dodging&#10;        try {&#10;            AIAvoidanceHelper.init(this)&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;Level2Activity&quot;, &quot;AI init failed: ${e.message}&quot;, e)&#10;            // Continue without AI - game will still work with basic logic&#10;        }&#10;&#10;        setContent {&#10;            val density = LocalDensity.current&#10;            val screenWidthPx = with(density) { LocalConfiguration.current.screenWidthDp.dp.toPx() }&#10;            val screenHeightPx = with(density) { LocalConfiguration.current.screenHeightDp.dp.toPx() }&#10;&#10;            Level2Game(&#10;                screenWidthPx = screenWidthPx,&#10;                screenHeightPx = screenHeightPx,&#10;                soundPool = soundPool,&#10;                shootSoundId = shootSoundId,&#10;                hitSoundId = hitSoundId,&#10;                onExit = { finish() }&#10;            )&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        try {&#10;            AIAvoidanceHelper.release()&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;Level2Activity&quot;, &quot;AI release failed: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Level2Game(&#10;    screenWidthPx: Float,&#10;    screenHeightPx: Float,&#10;    soundPool: android.media.SoundPool,&#10;    shootSoundId: Int,&#10;    hitSoundId: Int,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val playerName = PrefManager.getPlayerName(context)&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // --- State ---&#10;    var totalScore by remember { mutableStateOf(0) }&#10;    var currentSessionScore by remember { mutableStateOf(0) }&#10;    var planeHp by remember { mutableStateOf(100) }&#10;&#10;    var shieldActive by remember { mutableStateOf(false) }&#10;    var wallActive by remember { mutableStateOf(false) }&#10;    var timeActive by remember { mutableStateOf(false) }&#10;&#10;    var isGameOver by remember { mutableStateOf(false) }&#10;    var isLevelClear by remember { mutableStateOf(false) }&#10;    var showGameEndDialog by remember { mutableStateOf(false) }&#10;&#10;    // Show dialog when game ends instead of navigating to new activity&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        if (isGameOver || isLevelClear) {&#10;            delay(500)&#10;            showGameEndDialog = true&#10;        }&#10;    }&#10;&#10;    // --- Plane setup ---&#10;    var planeX by remember { mutableStateOf(screenWidthPx / 2 - 50f) }&#10;    val planeY = screenHeightPx - 250f&#10;    val planeWidth = 100f&#10;    val planeHeight = 100f&#10;&#10;    // --- Background ---&#10;    var offsetY by remember { mutableStateOf(0f) }&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            offsetY += 4f&#10;            if (offsetY &gt;= screenHeightPx) {&#10;                offsetY %= screenHeightPx&#10;            }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Entities: 5 rotating monster groups ---&#10;    val monsterGroups = remember {&#10;        List(5) { i -&gt;&#10;            RotatingMonsterGroup(&#10;                centerX = Random.nextFloat() * (screenWidthPx - 300f) + 150f, // Random X position&#10;                centerY = -300f, // Start just above screen&#10;                radius = 100f,&#10;                angleOffset = Random.nextFloat() * 360f, // Random starting angle&#10;                vx = if (Random.nextBoolean()) Random.nextFloat() * 2f + 2f else -(Random.nextFloat() * 2f + 2f),&#10;                vy = Random.nextFloat() * 2f + 3f // Random vertical speed (3-5f)&#10;            ).apply {&#10;                // Initially set monsters as dead - they will spawn with delay&#10;                monsters.forEach { it.alive.value = false }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Track respawn times for each group&#10;    val groupRespawnTimes = remember { MutableList(monsterGroups.size) { i -&gt; System.currentTimeMillis() + (i * 3000L) } }&#10;&#10;    val coins = remember {&#10;        List(7) {&#10;            BaseCoin(&#10;                x = Random.nextFloat() * (screenWidthPx - 50f),&#10;                y = mutableStateOf(-Random.nextInt(100, 800).toFloat()),&#10;                speed = Random.nextFloat() * 2f + 1.5f&#10;            )&#10;        }&#10;    }&#10;&#10;    val bullets = remember { mutableStateListOf&lt;Bullet&gt;() }&#10;    val bagCoins = remember { mutableStateListOf&lt;BagCoinDisplay&gt;() }&#10;    var chestItems by remember { mutableStateOf&lt;List&lt;ChestItem&gt;&gt;(emptyList()) }&#10;&#10;    // --- Load player data ---&#10;    LaunchedEffect(Unit) {&#10;        if (!playerName.isNullOrBlank()) {&#10;            FirebaseHelper.syncNewPlayer(playerName)&#10;            FirebaseHelper.getScore(playerName) { totalScore = it }&#10;            FirebaseHelper.getChestItems(playerName) { chestItems = it }&#10;        }&#10;    }&#10;&#10;    // --- Shooting ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.add(Bullet(planeX + planeWidth / 2 - 15f, planeY))&#10;            SoundManager.playSoundEffect(soundPool, shootSoundId, 0.5f)&#10;            delay(300)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.forEach { it.y -= 25f }&#10;            bullets.removeAll { it.y &lt; -50f }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Monster groups movement + rotation ---&#10;    monsterGroups.forEachIndexed { index, group -&gt;&#10;        LaunchedEffect(group, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                // Check if group needs to respawn&#10;                val allDead = group.monsters.all { !it.alive.value }&#10;                if (allDead &amp;&amp; System.currentTimeMillis() &gt;= groupRespawnTimes[index]) {&#10;                    // Respawn group at random position&#10;                    group.centerX = Random.nextFloat() * (screenWidthPx - 300f) + 150f&#10;                    group.centerY = -300f&#10;                    group.vx = if (Random.nextBoolean()) Random.nextFloat() * 2f + 2f else -(Random.nextFloat() * 2f + 2f)&#10;                    group.vy = Random.nextFloat() * 2f + 3f&#10;                    group.angleOffset = Random.nextFloat() * 360f // Random rotation angle&#10;                    group.monsters.forEach { m -&gt;&#10;                        m.hp.value = 100&#10;                        m.alive.value = true&#10;                    }&#10;                    // Update positions to match new center and angle&#10;                    group.updatePositions()&#10;                    // Set next respawn time with random delay (3-5 seconds)&#10;                    groupRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 5000)&#10;                }&#10;&#10;                if (!timeActive &amp;&amp; !allDead) {&#10;                    // Rotate monsters&#10;                    group.angleOffset += 3f&#10;&#10;                    // Move center&#10;                    group.centerX += group.vx&#10;                    group.centerY += group.vy&#10;&#10;                    // Bounce off LEFT wall - reverse to RIGHT&#10;                    if (group.centerX &lt;= 150f) {&#10;                        group.centerX = 150f&#10;                        group.vx = abs(group.vx) // Bounce to opposite direction (right)&#10;                    }&#10;&#10;                    // Bounce off RIGHT wall - reverse to LEFT&#10;                    if (group.centerX &gt;= screenWidthPx - 150f) {&#10;                        group.centerX = screenWidthPx - 150f&#10;                        group.vx = -abs(group.vx) // Bounce to opposite direction (left)&#10;                    }&#10;&#10;                    // Bounce off TOP - reverse to DOWN&#10;                    if (group.centerY &lt;= 150f) {&#10;                        group.centerY = 150f&#10;                        group.vy = abs(group.vy) // Bounce to opposite direction (down)&#10;                    }&#10;&#10;                    // Bounce off BOTTOM - reverse to UP&#10;                    if (group.centerY &gt;= screenHeightPx - 300f) {&#10;                        group.centerY = screenHeightPx - 300f&#10;                        group.vy = -abs(group.vy) // Bounce to opposite direction (up)&#10;                    }&#10;&#10;                    // Update monster positions&#10;                    group.updatePositions()&#10;&#10;                    // Respawn if group goes way off screen (safety check)&#10;                    if (group.centerY &gt; screenHeightPx + 500f || group.centerY &lt; -1000f) {&#10;                        groupRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(2000, 5000)&#10;                        group.monsters.forEach { it.alive.value = false }&#10;                    }&#10;                }&#10;                delay(16)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Coin movement ---&#10;    coins.forEach { c -&gt;&#10;        LaunchedEffect(c, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                if (!c.collected.value &amp;&amp; !timeActive) {&#10;                    c.y.value += c.speed&#10;                    if (c.y.value &gt; screenHeightPx) {&#10;                        c.y.value = -Random.nextInt(100, 800).toFloat()&#10;                        c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                    }&#10;                }&#10;                delay(32)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Bullet vs Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            val toRemove = mutableSetOf&lt;Bullet&gt;()&#10;            bullets.toList().forEach { b -&gt;&#10;                var shouldRemove = false&#10;                monsterGroups.forEach { group -&gt;&#10;                    group.monsters.forEach { m -&gt;&#10;                        if (m.alive.value &amp;&amp; CollisionUtils.checkCollisionBulletMonster(b, m)) {&#10;                            m.hp.value -= 25&#10;                            // Play hit sound&#10;                            SoundManager.playSoundEffect(soundPool, hitSoundId, 0.3f)&#10;                            shouldRemove = true&#10;                            if (m.hp.value &lt;= 0) {&#10;                                m.alive.value = false&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;                if (shouldRemove) {&#10;                    toRemove.add(b)&#10;                }&#10;            }&#10;            bullets.removeAll(toRemove)&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Coin collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            coins.forEach { c -&gt;&#10;                if (!c.collected.value &amp;&amp; CollisionUtils.checkCollisionPlaneCoin(planeX, planeY, planeWidth, planeHeight, c)) {&#10;                    c.collected.value = true&#10;                    totalScore += 1&#10;                    currentSessionScore += 1&#10;                    val bag = BagCoinDisplay(c.x, c.y.value, 1)&#10;                    bagCoins.add(bag)&#10;                    if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            monsterGroups.forEach { group -&gt;&#10;                group.monsters.forEach { m -&gt;&#10;                    if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp;&#10;                        CollisionUtils.checkCollisionPlaneMonster(planeX, planeY, planeWidth, planeHeight, m)&#10;                    ) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) planeHp -= 50&#10;                        m.hp.value = 0&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;            }&#10;            if (planeHp &lt;= 0) isGameOver = true&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Wall - Monster collision ---&#10;    LaunchedEffect(wallActive, isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            if (wallActive) {&#10;                monsterGroups.forEach { group -&gt;&#10;                    group.monsters.forEach { m -&gt;&#10;                        if (m.alive.value &amp;&amp; m.hp.value &gt; 0) {&#10;                            if (CollisionUtils.checkCollisionWallMonster(planeY, m)) {&#10;                                m.hp.value -= 2&#10;                                if (m.hp.value &lt;= 0) {&#10;                                    m.alive.value = false&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Use chest item ---&#10;    fun useChestItem(item: ChestItem) {&#10;        // Flatten all monsters from groups for ChestItemEffectsBase&#10;        val allMonsters = monsterGroups.flatMap { it.monsters }&#10;        ChestItemEffectsBase.applyItemEffect(&#10;            itemName = item.name,&#10;            monsters = allMonsters,&#10;            coins = coins,&#10;            bagCoins = bagCoins,&#10;            coroutineScope = coroutineScope,&#10;            screenHeightPx = screenHeightPx,&#10;            planeX = planeX,&#10;            onScoreUpdate = { add -&gt;&#10;                totalScore += add&#10;                currentSessionScore += add&#10;                if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;            },&#10;            onShieldToggle = { active -&gt; shieldActive = active },&#10;            onWallToggle = { active -&gt; wallActive = active },&#10;            onTimeToggle = { active -&gt; timeActive = active },&#10;            onLevelClear = { isLevelClear = true }&#10;        )&#10;        chestItems = chestItems - item&#10;        if (!playerName.isNullOrBlank()) FirebaseHelper.updateChest(playerName, chestItems)&#10;    }&#10;&#10;    // --- Drag plane ---&#10;    val dragModifier = Modifier.pointerInput(Unit) {&#10;        detectDragGestures { change, dragAmount -&gt;&#10;            planeX = (planeX + dragAmount.x).coerceIn(0f, screenWidthPx - planeWidth)&#10;            change.consume()&#10;        }&#10;    }&#10;&#10;    // --- UI ---&#10;    Box(modifier = Modifier.fillMaxSize()) {&#10;        // Background layer - separate from drag gestures&#10;        Box(modifier = Modifier.fillMaxSize()) {&#10;            // Hình nền chính&#10;            Image(&#10;                painter = painterResource(R.drawable.nen21),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .offset { IntOffset(0, offsetY.roundToInt()) },&#10;                contentScale = ContentScale.Crop&#10;            )&#10;            // Hình nền phụ để tạo hiệu ứng lặp&#10;            Image(&#10;                painter = painterResource(R.drawable.nen21),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .offset { IntOffset(0, (offsetY - screenHeightPx).roundToInt()) },&#10;                contentScale = ContentScale.Crop&#10;            )&#10;        }&#10;&#10;        // Game content with drag gesture&#10;        Box(modifier = Modifier.fillMaxSize().then(dragModifier)) {&#10;            // Monsters (using MonsterUI component)&#10;            monsterGroups.forEach { group -&gt;&#10;                group.monsters.forEach { m -&gt;&#10;                    MonsterUI(monster = m, level = 2)&#10;                }&#10;            }&#10;&#10;            // Coins&#10;            coins.filter { !it.collected.value }.forEach { c -&gt;&#10;                Image(&#10;                    painter = painterResource(R.drawable.coin),&#10;                    contentDescription = null,&#10;                    modifier = Modifier&#10;                        .absoluteOffset { IntOffset(c.x.roundToInt(), c.y.value.roundToInt()) }&#10;                        .size(40.dp)&#10;                )&#10;            }&#10;&#10;            // BagCoin animated views&#10;            bagCoins.toList().forEach { bag -&gt;&#10;                BagCoinAnimatedView(bag = bag, onFinished = { finishedBag -&gt;&#10;                    bagCoins.remove(finishedBag)&#10;                })&#10;            }&#10;&#10;            // Bullets&#10;            bullets.forEach { b -&gt;&#10;                Image(&#10;                    painter = painterResource(R.drawable.dan2),&#10;                    contentDescription = null,&#10;                    modifier = Modifier&#10;                        .absoluteOffset { IntOffset(b.x.roundToInt(), b.y.roundToInt()) }&#10;                        .size(30.dp)&#10;                )&#10;            }&#10;&#10;            // Plane (using PlaneUI component)&#10;            PlaneUI(&#10;                planeX = planeX,&#10;                planeY = planeY,&#10;                planeHp = planeHp,&#10;                shieldActive = shieldActive,&#10;                level = 2&#10;            )&#10;&#10;            // Wall (using WallUI component)&#10;            if (wallActive) {&#10;                WallUI(planeY = planeY)&#10;            }&#10;&#10;            // Top bar&#10;            TopBarUI(&#10;                bagCoinScore = totalScore,&#10;                chestItems = chestItems,&#10;                onBuyItem = { item, price -&gt;&#10;                    if (totalScore &gt;= price) {&#10;                        totalScore -= price&#10;                        chestItems = chestItems + item&#10;                        if (!playerName.isNullOrBlank()) {&#10;                            FirebaseHelper.updateScore(playerName, totalScore)&#10;                            FirebaseHelper.updateChest(playerName, chestItems)&#10;                        }&#10;                    }&#10;                },&#10;                onUseChestItem = { useChestItem(it) }&#10;            )&#10;&#10;            // --- Sound Control Button (top-right corner) ---&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(16.dp),&#10;                contentAlignment = Alignment.TopEnd&#10;            ) {&#10;                SoundControlButton()&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Game End Dialog ---&#10;    if (showGameEndDialog) {&#10;        GameEndDialog(&#10;            isWin = isLevelClear,&#10;            score = currentSessionScore,&#10;            level = 2,&#10;            onDismiss = {&#10;                showGameEndDialog = false&#10;            },&#10;            onReplay = {&#10;                // Reset game state to replay&#10;                showGameEndDialog = false&#10;                isGameOver = false&#10;                isLevelClear = false&#10;                planeHp = 100&#10;                currentSessionScore = 0&#10;&#10;                // Reset monsters&#10;                monsterGroups.forEach { group -&gt;&#10;                    group.centerX = Random.nextFloat() * (screenWidthPx - 300f) + 150f&#10;                    group.centerY = -300f&#10;                    group.vx = if (Random.nextBoolean()) Random.nextFloat() * 2f + 2f else -(Random.nextFloat() * 2f + 2f)&#10;                    group.vy = Random.nextFloat() * 2f + 3f&#10;                    group.angleOffset = Random.nextFloat() * 360f&#10;                    group.monsters.forEach { m -&gt;&#10;                        m.hp.value = 100&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;&#10;                // Reset respawn times&#10;                for (i in groupRespawnTimes.indices) {&#10;                    groupRespawnTimes[i] = System.currentTimeMillis() + (i * 3000L)&#10;                }&#10;&#10;                // Reset coins&#10;                coins.forEach { c -&gt;&#10;                    c.collected.value = false&#10;                    c.y.value = -Random.nextInt(100, 800).toFloat()&#10;                    c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                }&#10;&#10;                // Clear bullets&#10;                bullets.clear()&#10;            },&#10;            onNextLevel = {&#10;                // Navigate to next level handled by GameEndDialog itself&#10;                onExit() // Close this activity&#10;            },&#10;            onExit = {&#10;                // Back to main menu&#10;                onExit()&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * Rotating Monster Group - 3 monsters rotating around a center point&#10; */&#10;class RotatingMonsterGroup(&#10;    var centerX: Float,&#10;    var centerY: Float,&#10;    var radius: Float,&#10;    var angleOffset: Float,&#10;    var vx: Float, // velocity X&#10;    var vy: Float  // velocity Y&#10;) {&#10;    val monsters = List(3) { i -&gt;&#10;        val angle = angleOffset + i * 120f&#10;        val rad = Math.toRadians(angle.toDouble())&#10;        BaseMonster(&#10;            x = (centerX + cos(rad) * radius).toFloat(),&#10;            y = mutableStateOf((centerY + sin(rad) * radius).toFloat()),&#10;            speed = 0f,&#10;            hp = mutableStateOf(100)&#10;        )&#10;    }&#10;&#10;    fun updatePositions() {&#10;        val angles = listOf(0f, 120f, 240f)&#10;        monsters.forEachIndexed { i, m -&gt;&#10;            if (m.alive.value) {&#10;                val rad = Math.toRadians((angleOffset + angles[i]).toDouble())&#10;                m.x = (centerX + cos(rad) * radius).toFloat()&#10;                m.y.value = (centerY + sin(rad) * radius).toFloat()&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.game&#10;&#10;import android.os.Bundle&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.TopBarComponent.TopBarUI&#10;import com.example.game.core.*&#10;import com.example.game.ui.PlaneUI&#10;import com.example.game.ui.MonsterUI&#10;import com.example.game.ui.WallUI&#10;import com.example.game.ui.SoundControlButton&#10;import com.example.game.ui.BagCoinAnimatedView&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.*&#10;import kotlin.random.Random&#10;&#10;class Level2Activity : BaseGameActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        initAudio()&#10;&#10;        // Initialize AI Avoidance Helper for smart bullet dodging&#10;        try {&#10;            AIAvoidanceHelper.init(this)&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;Level2Activity&quot;, &quot;AI init failed: ${e.message}&quot;, e)&#10;            // Continue without AI - game will still work with basic logic&#10;        }&#10;&#10;        setContent {&#10;            val density = LocalDensity.current&#10;            val screenWidthPx = with(density) { LocalConfiguration.current.screenWidthDp.dp.toPx() }&#10;            val screenHeightPx = with(density) { LocalConfiguration.current.screenHeightDp.dp.toPx() }&#10;&#10;            Level2Game(&#10;                screenWidthPx = screenWidthPx,&#10;                screenHeightPx = screenHeightPx,&#10;                soundPool = soundPool,&#10;                shootSoundId = shootSoundId,&#10;                hitSoundId = hitSoundId,&#10;                onExit = { finish() }&#10;            )&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        try {&#10;            AIAvoidanceHelper.release()&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;Level2Activity&quot;, &quot;AI release failed: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Level2Game(&#10;    screenWidthPx: Float,&#10;    screenHeightPx: Float,&#10;    soundPool: android.media.SoundPool,&#10;    shootSoundId: Int,&#10;    hitSoundId: Int,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val playerName = PrefManager.getPlayerName(context)&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // --- State ---&#10;    var totalScore by remember { mutableStateOf(0) }&#10;    var currentSessionScore by remember { mutableStateOf(0) }&#10;    var planeHp by remember { mutableStateOf(100) }&#10;&#10;    var shieldActive by remember { mutableStateOf(false) }&#10;    var wallActive by remember { mutableStateOf(false) }&#10;    var timeActive by remember { mutableStateOf(false) }&#10;&#10;    var isGameOver by remember { mutableStateOf(false) }&#10;    var isLevelClear by remember { mutableStateOf(false) }&#10;    var showGameEndDialog by remember { mutableStateOf(false) }&#10;&#10;    // Show dialog when game ends instead of navigating to new activity&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        if (isGameOver || isLevelClear) {&#10;            delay(500)&#10;            showGameEndDialog = true&#10;        }&#10;    }&#10;&#10;    // --- Plane setup ---&#10;    var planeX by remember { mutableStateOf(screenWidthPx / 2 - 50f) }&#10;    val planeY = screenHeightPx - 250f&#10;    val planeWidth = 100f&#10;    val planeHeight = 100f&#10;&#10;    // --- Background ---&#10;    var offsetY by remember { mutableStateOf(0f) }&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            offsetY += 4f&#10;            if (offsetY &gt;= screenHeightPx) {&#10;                offsetY %= screenHeightPx&#10;            }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Entities: 5 rotating monster groups ---&#10;    val monsterGroups = remember {&#10;        List(5) { i -&gt;&#10;            RotatingMonsterGroup(&#10;                centerX = Random.nextFloat() * (screenWidthPx - 300f) + 150f, // Random X position&#10;                centerY = -300f, // Start just above screen&#10;                radius = 100f,&#10;                angleOffset = Random.nextFloat() * 360f, // Random starting angle&#10;                vx = if (Random.nextBoolean()) Random.nextFloat() * 2f + 2f else -(Random.nextFloat() * 2f + 2f),&#10;                vy = Random.nextFloat() * 2f + 3f // Random vertical speed (3-5f)&#10;            ).apply {&#10;                // Initially set monsters as dead - they will spawn with delay&#10;                monsters.forEach { it.alive.value = false }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Track respawn times for each group&#10;    val groupRespawnTimes = remember { MutableList(monsterGroups.size) { i -&gt; System.currentTimeMillis() + (i * 3000L) } }&#10;&#10;    val coins = remember {&#10;        List(7) {&#10;            BaseCoin(&#10;                x = Random.nextFloat() * (screenWidthPx - 50f),&#10;                y = mutableStateOf(-Random.nextInt(100, 800).toFloat()),&#10;                speed = Random.nextFloat() * 2f + 1.5f&#10;            )&#10;        }&#10;    }&#10;&#10;    val bullets = remember { mutableStateListOf&lt;Bullet&gt;() }&#10;    val bagCoins = remember { mutableStateListOf&lt;BagCoinDisplay&gt;() }&#10;    var chestItems by remember { mutableStateOf&lt;List&lt;ChestItem&gt;&gt;(emptyList()) }&#10;&#10;    // --- Load player data ---&#10;    LaunchedEffect(Unit) {&#10;        if (!playerName.isNullOrBlank()) {&#10;            FirebaseHelper.syncNewPlayer(playerName)&#10;            FirebaseHelper.getScore(playerName) { totalScore = it }&#10;            FirebaseHelper.getChestItems(playerName) { chestItems = it }&#10;        }&#10;    }&#10;&#10;    // --- Shooting ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.add(Bullet(planeX + planeWidth / 2 - 15f, planeY))&#10;            SoundManager.playSoundEffect(soundPool, shootSoundId, 0.5f)&#10;            delay(300)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.forEach { it.y -= 25f }&#10;            bullets.removeAll { it.y &lt; -50f }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Monster groups movement + rotation ---&#10;    monsterGroups.forEachIndexed { index, group -&gt;&#10;        LaunchedEffect(group, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                // Check if group needs to respawn&#10;                val allDead = group.monsters.all { !it.alive.value }&#10;                if (allDead &amp;&amp; System.currentTimeMillis() &gt;= groupRespawnTimes[index]) {&#10;                    // Respawn group at random position&#10;                    group.centerX = Random.nextFloat() * (screenWidthPx - 300f) + 150f&#10;                    group.centerY = -300f&#10;                    group.vx = if (Random.nextBoolean()) Random.nextFloat() * 2f + 2f else -(Random.nextFloat() * 2f + 2f)&#10;                    group.vy = Random.nextFloat() * 2f + 3f&#10;                    group.angleOffset = Random.nextFloat() * 360f // Random rotation angle&#10;                    group.monsters.forEach { m -&gt;&#10;                        m.hp.value = 100&#10;                        m.alive.value = true&#10;                    }&#10;                    // Update positions to match new center and angle&#10;                    group.updatePositions()&#10;                    // Set next respawn time with random delay (3-5 seconds)&#10;                    groupRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 5000)&#10;                }&#10;&#10;                if (!timeActive &amp;&amp; !allDead) {&#10;                    // Rotate monsters&#10;                    group.angleOffset += 3f&#10;&#10;                    // Move center&#10;                    group.centerX += group.vx&#10;                    group.centerY += group.vy&#10;&#10;                    // Bounce off LEFT wall - reverse to RIGHT&#10;                    if (group.centerX &lt;= 150f) {&#10;                        group.centerX = 150f&#10;                        group.vx = abs(group.vx) // Bounce to opposite direction (right)&#10;                    }&#10;&#10;                    // Bounce off RIGHT wall - reverse to LEFT&#10;                    if (group.centerX &gt;= screenWidthPx - 150f) {&#10;                        group.centerX = screenWidthPx - 150f&#10;                        group.vx = -abs(group.vx) // Bounce to opposite direction (left)&#10;                    }&#10;&#10;                    // Bounce off TOP - reverse to DOWN&#10;                    if (group.centerY &lt;= 150f) {&#10;                        group.centerY = 150f&#10;                        group.vy = abs(group.vy) // Bounce to opposite direction (down)&#10;                    }&#10;&#10;                    // Bounce off BOTTOM - reverse to UP&#10;                    if (group.centerY &gt;= screenHeightPx - 300f) {&#10;                        group.centerY = screenHeightPx - 300f&#10;                        group.vy = -abs(group.vy) // Bounce to opposite direction (up)&#10;                    }&#10;&#10;                    // Update monster positions&#10;                    group.updatePositions()&#10;&#10;                    // Respawn if group goes way off screen (safety check)&#10;                    if (group.centerY &gt; screenHeightPx + 500f || group.centerY &lt; -1000f) {&#10;                        groupRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(2000, 5000)&#10;                        group.monsters.forEach { it.alive.value = false }&#10;                    }&#10;                }&#10;                delay(16)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Coin movement ---&#10;    coins.forEach { c -&gt;&#10;        LaunchedEffect(c, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                if (!c.collected.value &amp;&amp; !timeActive) {&#10;                    c.y.value += c.speed&#10;                    if (c.y.value &gt; screenHeightPx) {&#10;                        c.y.value = -Random.nextInt(100, 800).toFloat()&#10;                        c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                    }&#10;                }&#10;                delay(32)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Bullet vs Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            val toRemove = mutableSetOf&lt;Bullet&gt;()&#10;            bullets.toList().forEach { b -&gt;&#10;                var shouldRemove = false&#10;                monsterGroups.forEach { group -&gt;&#10;                    group.monsters.forEach { m -&gt;&#10;                        if (m.alive.value &amp;&amp; CollisionUtils.checkCollisionBulletMonster(b, m)) {&#10;                            m.hp.value -= 25&#10;                            // Play hit sound&#10;                            SoundManager.playSoundEffect(soundPool, hitSoundId, 0.3f)&#10;                            shouldRemove = true&#10;                            if (m.hp.value &lt;= 0) {&#10;                                m.alive.value = false&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;                if (shouldRemove) {&#10;                    toRemove.add(b)&#10;                }&#10;            }&#10;            bullets.removeAll(toRemove)&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Coin collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            coins.forEach { c -&gt;&#10;                if (!c.collected.value &amp;&amp; CollisionUtils.checkCollisionPlaneCoin(planeX, planeY, planeWidth, planeHeight, c)) {&#10;                    c.collected.value = true&#10;                    totalScore += 1&#10;                    currentSessionScore += 1&#10;                    val bag = BagCoinDisplay(c.x, c.y.value, 1)&#10;                    bagCoins.add(bag)&#10;                    if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            monsterGroups.forEach { group -&gt;&#10;                group.monsters.forEach { m -&gt;&#10;                    if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp;&#10;                        CollisionUtils.checkCollisionPlaneMonster(planeX, planeY, planeWidth, planeHeight, m)&#10;                    ) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) planeHp -= 50&#10;                        m.hp.value = 0&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;            }&#10;            if (planeHp &lt;= 0) isGameOver = true&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Wall - Monster collision ---&#10;    LaunchedEffect(wallActive, isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            if (wallActive) {&#10;                monsterGroups.forEach { group -&gt;&#10;                    group.monsters.forEach { m -&gt;&#10;                        if (m.alive.value &amp;&amp; m.hp.value &gt; 0) {&#10;                            if (CollisionUtils.checkCollisionWallMonster(planeY, m)) {&#10;                                m.hp.value -= 2&#10;                                if (m.hp.value &lt;= 0) {&#10;                                    m.alive.value = false&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Use chest item ---&#10;    fun useChestItem(item: ChestItem) {&#10;        // Flatten all monsters from groups for ChestItemEffectsBase&#10;        val allMonsters = monsterGroups.flatMap { it.monsters }&#10;        ChestItemEffectsBase.applyItemEffect(&#10;            itemName = item.name,&#10;            monsters = allMonsters,&#10;            coins = coins,&#10;            bagCoins = bagCoins,&#10;            coroutineScope = coroutineScope,&#10;            screenHeightPx = screenHeightPx,&#10;            planeX = planeX,&#10;            onScoreUpdate = { add -&gt;&#10;                totalScore += add&#10;                currentSessionScore += add&#10;                if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;            },&#10;            onShieldToggle = { active -&gt; shieldActive = active },&#10;            onWallToggle = { active -&gt; wallActive = active },&#10;            onTimeToggle = { active -&gt; timeActive = active },&#10;            onLevelClear = { isLevelClear = true }&#10;        )&#10;        chestItems = chestItems - item&#10;        if (!playerName.isNullOrBlank()) FirebaseHelper.updateChest(playerName, chestItems)&#10;    }&#10;&#10;    // --- Drag plane ---&#10;    val dragModifier = Modifier.pointerInput(Unit) {&#10;        detectDragGestures { change, dragAmount -&gt;&#10;            planeX = (planeX + dragAmount.x).coerceIn(0f, screenWidthPx - planeWidth)&#10;            change.consume()&#10;        }&#10;    }&#10;&#10;    // --- UI ---&#10;    Box(modifier = Modifier.fillMaxSize()) {&#10;        // Background layer - separate from drag gestures&#10;        Box(modifier = Modifier.fillMaxSize()) {&#10;            // Hình nền chính&#10;            Image(&#10;                painter = painterResource(R.drawable.nen21),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .offset { IntOffset(0, offsetY.roundToInt()) },&#10;                contentScale = ContentScale.Crop&#10;            )&#10;            // Hình nền phụ để tạo hiệu ứng lặp&#10;            Image(&#10;                painter = painterResource(R.drawable.nen21),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .offset { IntOffset(0, (offsetY - screenHeightPx).roundToInt()) },&#10;                contentScale = ContentScale.Crop&#10;            )&#10;        }&#10;&#10;        // Game content with drag gesture&#10;        Box(modifier = Modifier.fillMaxSize().then(dragModifier)) {&#10;            // Monsters (using MonsterUI component)&#10;            monsterGroups.forEach { group -&gt;&#10;                group.monsters.forEach { m -&gt;&#10;                    MonsterUI(monster = m, level = 2)&#10;                }&#10;            }&#10;&#10;            // Coins&#10;            coins.filter { !it.collected.value }.forEach { c -&gt;&#10;                Image(&#10;                    painter = painterResource(R.drawable.coin),&#10;                    contentDescription = null,&#10;                    modifier = Modifier&#10;                        .absoluteOffset { IntOffset(c.x.roundToInt(), c.y.value.roundToInt()) }&#10;                        .size(40.dp)&#10;                )&#10;            }&#10;&#10;            // BagCoin animated views&#10;            bagCoins.toList().forEach { bag -&gt;&#10;                BagCoinAnimatedView(bag = bag, onFinished = { finishedBag -&gt;&#10;                    bagCoins.remove(finishedBag)&#10;                })&#10;            }&#10;&#10;            // Bullets&#10;            bullets.forEach { b -&gt;&#10;                Image(&#10;                    painter = painterResource(R.drawable.dan2),&#10;                    contentDescription = null,&#10;                    modifier = Modifier&#10;                        .absoluteOffset { IntOffset(b.x.roundToInt(), b.y.roundToInt()) }&#10;                        .size(30.dp)&#10;                )&#10;            }&#10;&#10;            // Plane (using PlaneUI component)&#10;            PlaneUI(&#10;                planeX = planeX,&#10;                planeY = planeY,&#10;                planeHp = planeHp,&#10;                shieldActive = shieldActive,&#10;                level = 2&#10;            )&#10;&#10;            // Wall (using WallUI component)&#10;            if (wallActive) {&#10;                WallUI(planeY = planeY)&#10;            }&#10;&#10;            // Top bar&#10;            TopBarUI(&#10;                bagCoinScore = totalScore,&#10;                chestItems = chestItems,&#10;                onBuyItem = { item, price -&gt;&#10;                    if (totalScore &gt;= price) {&#10;                        totalScore -= price&#10;                        chestItems = chestItems + item&#10;                        if (!playerName.isNullOrBlank()) {&#10;                            FirebaseHelper.updateScore(playerName, totalScore)&#10;                            FirebaseHelper.updateChest(playerName, chestItems)&#10;                        }&#10;                    }&#10;                },&#10;                onUseChestItem = { useChestItem(it) }&#10;            )&#10;&#10;            // --- Sound Control Button (top-right corner) ---&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(16.dp),&#10;                contentAlignment = Alignment.TopEnd&#10;            ) {&#10;                SoundControlButton()&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Game End Dialog ---&#10;    if (showGameEndDialog) {&#10;        GameEndDialog(&#10;            isWin = isLevelClear,&#10;            score = currentSessionScore,&#10;            level = 2,&#10;            onDismiss = {&#10;                showGameEndDialog = false&#10;            },&#10;            onReplay = {&#10;                // Reset game state to replay&#10;                showGameEndDialog = false&#10;                isGameOver = false&#10;                isLevelClear = false&#10;                planeHp = 100&#10;                currentSessionScore = 0&#10;&#10;                // Reset monsters&#10;                monsterGroups.forEach { group -&gt;&#10;                    group.centerX = Random.nextFloat() * (screenWidthPx - 300f) + 150f&#10;                    group.centerY = -300f&#10;                    group.vx = if (Random.nextBoolean()) Random.nextFloat() * 2f + 2f else -(Random.nextFloat() * 2f + 2f)&#10;                    group.vy = Random.nextFloat() * 2f + 3f&#10;                    group.angleOffset = Random.nextFloat() * 360f&#10;                    group.monsters.forEach { m -&gt;&#10;                        m.hp.value = 100&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;&#10;                // Reset respawn times&#10;                for (i in groupRespawnTimes.indices) {&#10;                    groupRespawnTimes[i] = System.currentTimeMillis() + (i * 3000L)&#10;                }&#10;&#10;                // Reset coins&#10;                coins.forEach { c -&gt;&#10;                    c.collected.value = false&#10;                    c.y.value = -Random.nextInt(100, 800).toFloat()&#10;                    c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                }&#10;&#10;                // Clear bullets&#10;                bullets.clear()&#10;            },&#10;            onNextLevel = {&#10;                // Navigate to next level handled by GameEndDialog itself&#10;                onExit() // Close this activity&#10;            },&#10;            onExit = {&#10;                // Back to main menu&#10;                onExit()&#10;            },&#10;            playerName = playerName,&#10;            totalScore = totalScore&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * Rotating Monster Group - 3 monsters rotating around a center point&#10; */&#10;class RotatingMonsterGroup(&#10;    var centerX: Float,&#10;    var centerY: Float,&#10;    var radius: Float,&#10;    var angleOffset: Float,&#10;    var vx: Float, // velocity X&#10;    var vy: Float  // velocity Y&#10;) {&#10;    val monsters = List(3) { i -&gt;&#10;        val angle = angleOffset + i * 120f&#10;        val rad = Math.toRadians(angle.toDouble())&#10;        BaseMonster(&#10;            x = (centerX + cos(rad) * radius).toFloat(),&#10;            y = mutableStateOf((centerY + sin(rad) * radius).toFloat()),&#10;            speed = 0f,&#10;            hp = mutableStateOf(100)&#10;        )&#10;    }&#10;&#10;    fun updatePositions() {&#10;        val angles = listOf(0f, 120f, 240f)&#10;        monsters.forEachIndexed { i, m -&gt;&#10;            if (m.alive.value) {&#10;                val rad = Math.toRadians((angleOffset + angles[i]).toDouble())&#10;                m.x = (centerX + cos(rad) * radius).toFloat()&#10;                m.y.value = (centerY + sin(rad) * radius).toFloat()&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/game/Level3Activity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/game/Level3Activity.kt" />
              <option name="originalContent" value="package com.example.game&#10;&#10;import android.os.Bundle&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.TopBarComponent.TopBarUI&#10;import com.example.game.core.*&#10;import com.example.game.ui.PlaneUI&#10;import com.example.game.ui.WallUI&#10;import com.example.game.ui.InvisibleMonsterUI&#10;import com.example.game.ui.SoundControlButton&#10;import com.example.game.ui.BagCoinAnimatedView&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.roundToInt&#10;import kotlin.random.Random&#10;&#10;class Level3Activity : BaseGameActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        try {&#10;            initAudio()&#10;&#10;            // Initialize AI Avoidance Helper for smart bullet dodging&#10;            try {&#10;                AIAvoidanceHelper.init(this)&#10;            } catch (e: Exception) {&#10;                e.printStackTrace()&#10;                // Continue without AI if it fails&#10;            }&#10;&#10;            setContent {&#10;                val density = LocalDensity.current&#10;                val screenWidthPx = with(density) { LocalConfiguration.current.screenWidthDp.dp.toPx() }&#10;                val screenHeightPx = with(density) { LocalConfiguration.current.screenHeightDp.dp.toPx() }&#10;&#10;                Level3Game(&#10;                    screenWidthPx = screenWidthPx,&#10;                    screenHeightPx = screenHeightPx,&#10;                    soundPool = soundPool,&#10;                    shootSoundId = shootSoundId,&#10;                    hitSoundId = hitSoundId,&#10;                    onExit = { finish() }&#10;                )&#10;            }&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            finish() // Exit gracefully if something goes wrong&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        try {&#10;            AIAvoidanceHelper.release()&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Level3Game(&#10;    screenWidthPx: Float,&#10;    screenHeightPx: Float,&#10;    soundPool: android.media.SoundPool,&#10;    shootSoundId: Int,&#10;    hitSoundId: Int,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val playerName = PrefManager.getPlayerName(context)&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // --- State ---&#10;    var totalScore by remember { mutableStateOf(0) }&#10;    var currentSessionScore by remember { mutableStateOf(0) }&#10;    var planeHp by remember { mutableStateOf(100) }&#10;&#10;    var shieldActive by remember { mutableStateOf(false) }&#10;    var wallActive by remember { mutableStateOf(false) }&#10;    var timeActive by remember { mutableStateOf(false) }&#10;&#10;    var isGameOver by remember { mutableStateOf(false) }&#10;    var isLevelClear by remember { mutableStateOf(false) }&#10;    var showGameEndDialog by remember { mutableStateOf(false) }&#10;&#10;    // Show dialog when game ends&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        if (isGameOver || isLevelClear) {&#10;            delay(500)&#10;            showGameEndDialog = true&#10;        }&#10;    }&#10;&#10;    // --- Plane setup ---&#10;    var planeX by remember { mutableStateOf(screenWidthPx / 2 - 50f) }&#10;    val planeY = screenHeightPx - 250f&#10;    val planeWidth = 100f&#10;    val planeHeight = 100f&#10;&#10;    // --- Background ---&#10;    var offsetY by remember { mutableStateOf(0f) }&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            offsetY += 4f&#10;            if (offsetY &gt;= screenHeightPx) {&#10;                offsetY %= screenHeightPx&#10;            }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Invisible Monsters ---&#10;    val invisibleMonsters = remember {&#10;        List(12) {&#10;            InvisibleMonster(&#10;                x = Random.nextFloat() * (screenWidthPx - 100f),&#10;                y = mutableStateOf(-Random.nextInt(200, 3000).toFloat()),&#10;                speed = Random.nextFloat() * 1.5f + 1.5f,&#10;                hp = mutableStateOf(100),&#10;                invisibleDuration = 2000L, // Invisible for 2 seconds&#10;                visibleDuration = 1500L     // Visible for 1.5 seconds&#10;            )&#10;        }&#10;    }&#10;&#10;    // Track respawn times&#10;    val monsterRespawnTimes = remember { MutableList(invisibleMonsters.size) { 0L } }&#10;&#10;    val coins = remember {&#10;        List(6) {&#10;            BaseCoin(&#10;                x = Random.nextFloat() * (screenWidthPx - 50f),&#10;                y = mutableStateOf(-Random.nextInt(100, 600).toFloat()),&#10;                speed = Random.nextFloat() * 2f + 1f&#10;            )&#10;        }&#10;    }&#10;&#10;    val bullets = remember { mutableStateListOf&lt;Bullet&gt;() }&#10;    val bagCoins = remember { mutableStateListOf&lt;BagCoinDisplay&gt;() }&#10;    var chestItems by remember { mutableStateOf&lt;List&lt;ChestItem&gt;&gt;(emptyList()) }&#10;&#10;    // --- Load player data ---&#10;    LaunchedEffect(Unit) {&#10;        if (!playerName.isNullOrBlank()) {&#10;            FirebaseHelper.syncNewPlayer(playerName)&#10;            FirebaseHelper.getScore(playerName) { totalScore = it }&#10;            FirebaseHelper.getChestItems(playerName) { chestItems = it }&#10;        }&#10;    }&#10;&#10;    // --- Shooting ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.add(Bullet(planeX + planeWidth / 2f - 15f, planeY))&#10;            SoundManager.playSoundEffect(soundPool, shootSoundId, 0.5f)&#10;            delay(300)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.forEach { it.y -= 25f }&#10;            bullets.removeAll { it.y &lt; -50f }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Monster movement + invisible toggle ---&#10;    invisibleMonsters.forEachIndexed { index, m -&gt;&#10;        LaunchedEffect(m, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                // Check if monster needs to respawn&#10;                if (!m.alive.value &amp;&amp; System.currentTimeMillis() &gt;= monsterRespawnTimes[index]) {&#10;                    m.y.value = -Random.nextInt(200, 1500).toFloat()&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 100f)&#10;                    m.hp.value = 100&#10;                    m.alive.value = true&#10;                    m.lastToggleTime = System.currentTimeMillis()&#10;                    m.isVisible.value = Random.nextBoolean() // Random start state&#10;                }&#10;&#10;                if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp; !timeActive) {&#10;                    // AI-based evasion: monster tries to dodge bullets intelligently&#10;                    val evasion = AIAvoidanceHelper.calculateEvasion(&#10;                        monsterX = m.x,&#10;                        monsterY = m.y.value,&#10;                        monsterSize = 100f,&#10;                        bullets = bullets,&#10;                        screenWidth = screenWidthPx&#10;                    )&#10;&#10;                    // Apply AI evasion (combines with zigzag movement)&#10;                    val aiDodgeX = evasion.first&#10;&#10;                    // Toggle visibility&#10;                    val currentTime = System.currentTimeMillis()&#10;                    val elapsed = currentTime - m.lastToggleTime&#10;                    val threshold = if (m.isVisible.value) m.visibleDuration else m.invisibleDuration&#10;&#10;                    if (elapsed &gt;= threshold) {&#10;                        m.isVisible.value = !m.isVisible.value&#10;                        m.lastToggleTime = currentTime&#10;                    }&#10;&#10;                    // Wall collision check&#10;                    val wallTop = planeY - 60f&#10;                    val monsterBottom = m.y.value + 80f&#10;&#10;                    if (wallActive &amp;&amp; monsterBottom &gt;= wallTop) {&#10;                        // Stop at wall&#10;                    } else {&#10;                        // Normal movement&#10;                        m.y.value += m.speed&#10;                    }&#10;&#10;                    // Zigzag movement combined with AI evasion&#10;                    val combinedX = (m.horizontalSpeed * m.direction) + aiDodgeX&#10;                    m.x = (m.x + combinedX).coerceIn(0f, screenWidthPx - 100f)&#10;&#10;                    if (m.x &lt;= 0 || m.x &gt;= screenWidthPx - 100f) {&#10;                        m.direction *= -1&#10;                    }&#10;&#10;                    // If monster passes plane&#10;                    if (m.y.value &gt; planeY + planeHeight / 2f) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) planeHp -= 50&#10;                        monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 8000)&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;                delay(16)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Coin movement ---&#10;    coins.forEach { c -&gt;&#10;        LaunchedEffect(c, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                if (!c.collected.value &amp;&amp; !timeActive) {&#10;                    c.y.value += c.speed&#10;                    if (c.y.value &gt; screenHeightPx) {&#10;                        c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                        c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                    }&#10;                }&#10;                delay(32)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Bullet vs Monster collision (only when visible) ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            val iter = bullets.iterator()&#10;            while (iter.hasNext()) {&#10;                val b = iter.next()&#10;                invisibleMonsters.forEach { m -&gt;&#10;                    // Can only hit visible monsters&#10;                    if (m.isVisible.value &amp;&amp; CollisionUtils.checkCollisionBulletInvisibleMonster(b, m)) {&#10;                        m.hp.value -= 25&#10;                        // Play hit sound&#10;                        SoundManager.playSoundEffect(soundPool, hitSoundId, 0.3f)&#10;                        iter.remove()&#10;                        if (m.hp.value &lt;= 0) {&#10;                            m.alive.value = false&#10;                            val index = invisibleMonsters.indexOf(m)&#10;                            if (index &gt;= 0) {&#10;                                monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 8000)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Coin collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            coins.forEach { c -&gt;&#10;                if (!c.collected.value &amp;&amp; CollisionUtils.checkCollisionPlaneCoin(planeX, planeY, planeWidth, planeHeight, c)) {&#10;                    c.collected.value = true&#10;                    totalScore += 1&#10;                    currentSessionScore += 1&#10;                    val bag = BagCoinDisplay(c.x, c.y.value, 1)&#10;                    bagCoins.add(bag)&#10;                    if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Monster collision (only when visible) ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            invisibleMonsters.forEach { m -&gt;&#10;                if (m.isVisible.value &amp;&amp; CollisionUtils.checkCollisionPlaneInvisibleMonster(planeX, planeY, planeWidth, planeHeight, m)) {&#10;                    if (!shieldActive &amp;&amp; !wallActive) planeHp -= 50&#10;                    m.hp.value = 0&#10;                    m.alive.value = false&#10;                }&#10;            }&#10;            if (planeHp &lt;= 0) isGameOver = true&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Wall - Monster collision ---&#10;    LaunchedEffect(wallActive, isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            if (wallActive) {&#10;                invisibleMonsters.forEach { m -&gt;&#10;                    if (m.isVisible.value &amp;&amp; CollisionUtils.checkCollisionWallInvisibleMonster(planeY, m)) {&#10;                        m.hp.value -= 2&#10;                        if (m.hp.value &lt;= 0) {&#10;                            m.alive.value = false&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Use chest item ---&#10;    fun useChestItem(item: ChestItem) {&#10;        ChestItemEffectsBase.applyItemEffect(&#10;            itemName = item.name,&#10;            monsters = invisibleMonsters,&#10;            coins = coins,&#10;            bagCoins = bagCoins,&#10;            coroutineScope = coroutineScope,&#10;            screenHeightPx = screenHeightPx,&#10;            planeX = planeX,&#10;            onScoreUpdate = { add -&gt;&#10;                totalScore += add&#10;                currentSessionScore += add&#10;                if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;            },&#10;            onShieldToggle = { active -&gt; shieldActive = active },&#10;            onWallToggle = { active -&gt; wallActive = active },&#10;            onTimeToggle = { active -&gt; timeActive = active },&#10;            onLevelClear = { isLevelClear = true }&#10;        )&#10;        chestItems = chestItems - item&#10;        if (!playerName.isNullOrBlank()) FirebaseHelper.updateChest(playerName, chestItems)&#10;    }&#10;&#10;    // --- Drag plane ---&#10;    val dragModifier = Modifier.pointerInput(Unit) {&#10;        detectDragGestures { change, dragAmount -&gt;&#10;            planeX = (planeX + dragAmount.x).coerceIn(0f, screenWidthPx - planeWidth)&#10;            change.consume()&#10;        }&#10;    }&#10;&#10;    // --- UI ---&#10;    Box(modifier = Modifier.fillMaxSize()) {&#10;        // Background layer - separate from drag gestures&#10;        Box(modifier = Modifier.fillMaxSize()) {&#10;            // Hình nền chính&#10;            Image(&#10;                painter = painterResource(R.drawable.nen3),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .offset { IntOffset(0, offsetY.roundToInt()) },&#10;                contentScale = ContentScale.Crop&#10;            )&#10;            // Hình nền phụ để tạo hiệu ứng lặp&#10;            Image(&#10;                painter = painterResource(R.drawable.nen3),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .offset { IntOffset(0, (offsetY - screenHeightPx).roundToInt()) },&#10;                contentScale = ContentScale.Crop&#10;            )&#10;        }&#10;&#10;        // Game content with drag gesture&#10;        Box(modifier = Modifier.fillMaxSize().then(dragModifier)) {&#10;            // Monsters (Level 3 uses InvisibleMonsterUI)&#10;            invisibleMonsters.forEach { m -&gt;&#10;                InvisibleMonsterUI(monster = m, level = 3)&#10;            }&#10;&#10;            // Coins&#10;            coins.filter { !it.collected.value }.forEach { c -&gt;&#10;                Image(&#10;                    painter = painterResource(R.drawable.coin),&#10;                    contentDescription = null,&#10;                    modifier = Modifier&#10;                        .absoluteOffset { IntOffset(c.x.roundToInt(), c.y.value.roundToInt()) }&#10;                        .size(40.dp)&#10;                )&#10;            }&#10;&#10;            // BagCoin animated views&#10;            bagCoins.toList().forEach { bag -&gt;&#10;                BagCoinAnimatedView(bag = bag, onFinished = { finishedBag -&gt;&#10;                    bagCoins.remove(finishedBag)&#10;                })&#10;            }&#10;&#10;            // Bullets&#10;            bullets.forEach { b -&gt;&#10;                Image(&#10;                    painter = painterResource(R.drawable.dan2),&#10;                    contentDescription = null,&#10;                    modifier = Modifier&#10;                        .absoluteOffset { IntOffset(b.x.roundToInt(), b.y.roundToInt()) }&#10;                        .size(30.dp)&#10;                )&#10;            }&#10;&#10;            // Plane&#10;            PlaneUI(&#10;                planeX = planeX,&#10;                planeY = planeY,&#10;                planeHp = planeHp,&#10;                shieldActive = shieldActive,&#10;                level = 3&#10;            )&#10;&#10;            // Wall&#10;            if (wallActive) {&#10;                WallUI(planeY = planeY)&#10;            }&#10;&#10;            // Top bar&#10;            TopBarUI(&#10;                bagCoinScore = totalScore,&#10;                chestItems = chestItems,&#10;                onBuyItem = { item, price -&gt;&#10;                    if (totalScore &gt;= price) {&#10;                        totalScore -= price&#10;                        chestItems = chestItems + item&#10;                        if (!playerName.isNullOrBlank()) {&#10;                            FirebaseHelper.updateScore(playerName, totalScore)&#10;                            FirebaseHelper.updateChest(playerName, chestItems)&#10;                        }&#10;                    }&#10;                },&#10;                onUseChestItem = { useChestItem(it) }&#10;            )&#10;&#10;            // --- Sound Control Button (top-right corner) ---&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(16.dp),&#10;                contentAlignment = androidx.compose.ui.Alignment.TopEnd&#10;            ) {&#10;                SoundControlButton()&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Game End Dialog ---&#10;    if (showGameEndDialog) {&#10;        GameEndDialog(&#10;            isWin = isLevelClear,&#10;            score = currentSessionScore,&#10;            level = 3,&#10;            onDismiss = {&#10;                showGameEndDialog = false&#10;            },&#10;            onReplay = {&#10;                // Reset game&#10;                showGameEndDialog = false&#10;                isGameOver = false&#10;                isLevelClear = false&#10;                planeHp = 100&#10;                currentSessionScore = 0&#10;&#10;                invisibleMonsters.forEachIndexed { index, m -&gt;&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 100f)&#10;                    m.y.value = -Random.nextInt(200, 3000).toFloat()&#10;                    m.hp.value = 100&#10;                    m.alive.value = true&#10;                    m.isVisible.value = Random.nextBoolean()&#10;                    m.lastToggleTime = System.currentTimeMillis()&#10;                    monsterRespawnTimes[index] = 0L&#10;                }&#10;&#10;                coins.forEach { c -&gt;&#10;                    c.collected.value = false&#10;                    c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                    c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                }&#10;&#10;                bullets.clear()&#10;            },&#10;            onNextLevel = {&#10;                onExit()&#10;            },&#10;            onExit = {&#10;                onExit()&#10;            }&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.game&#10;&#10;import android.os.Bundle&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.TopBarComponent.TopBarUI&#10;import com.example.game.core.*&#10;import com.example.game.ui.PlaneUI&#10;import com.example.game.ui.WallUI&#10;import com.example.game.ui.InvisibleMonsterUI&#10;import com.example.game.ui.SoundControlButton&#10;import com.example.game.ui.BagCoinAnimatedView&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.roundToInt&#10;import kotlin.random.Random&#10;&#10;class Level3Activity : BaseGameActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        try {&#10;            initAudio()&#10;&#10;            // Initialize AI Avoidance Helper for smart bullet dodging&#10;            try {&#10;                AIAvoidanceHelper.init(this)&#10;            } catch (e: Exception) {&#10;                e.printStackTrace()&#10;                // Continue without AI if it fails&#10;            }&#10;&#10;            setContent {&#10;                val density = LocalDensity.current&#10;                val screenWidthPx = with(density) { LocalConfiguration.current.screenWidthDp.dp.toPx() }&#10;                val screenHeightPx = with(density) { LocalConfiguration.current.screenHeightDp.dp.toPx() }&#10;&#10;                Level3Game(&#10;                    screenWidthPx = screenWidthPx,&#10;                    screenHeightPx = screenHeightPx,&#10;                    soundPool = soundPool,&#10;                    shootSoundId = shootSoundId,&#10;                    hitSoundId = hitSoundId,&#10;                    onExit = { finish() }&#10;                )&#10;            }&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            finish() // Exit gracefully if something goes wrong&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        try {&#10;            AIAvoidanceHelper.release()&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Level3Game(&#10;    screenWidthPx: Float,&#10;    screenHeightPx: Float,&#10;    soundPool: android.media.SoundPool,&#10;    shootSoundId: Int,&#10;    hitSoundId: Int,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val playerName = PrefManager.getPlayerName(context)&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // --- State ---&#10;    var totalScore by remember { mutableStateOf(0) }&#10;    var currentSessionScore by remember { mutableStateOf(0) }&#10;    var planeHp by remember { mutableStateOf(100) }&#10;&#10;    var shieldActive by remember { mutableStateOf(false) }&#10;    var wallActive by remember { mutableStateOf(false) }&#10;    var timeActive by remember { mutableStateOf(false) }&#10;&#10;    var isGameOver by remember { mutableStateOf(false) }&#10;    var isLevelClear by remember { mutableStateOf(false) }&#10;    var showGameEndDialog by remember { mutableStateOf(false) }&#10;&#10;    // Show dialog when game ends&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        if (isGameOver || isLevelClear) {&#10;            delay(500)&#10;            showGameEndDialog = true&#10;        }&#10;    }&#10;&#10;    // --- Plane setup ---&#10;    var planeX by remember { mutableStateOf(screenWidthPx / 2 - 50f) }&#10;    val planeY = screenHeightPx - 250f&#10;    val planeWidth = 100f&#10;    val planeHeight = 100f&#10;&#10;    // --- Background ---&#10;    var offsetY by remember { mutableStateOf(0f) }&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            offsetY += 4f&#10;            if (offsetY &gt;= screenHeightPx) {&#10;                offsetY %= screenHeightPx&#10;            }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Invisible Monsters ---&#10;    val invisibleMonsters = remember {&#10;        List(12) {&#10;            InvisibleMonster(&#10;                x = Random.nextFloat() * (screenWidthPx - 100f),&#10;                y = mutableStateOf(-Random.nextInt(200, 3000).toFloat()),&#10;                speed = Random.nextFloat() * 1.5f + 1.5f,&#10;                hp = mutableStateOf(100),&#10;                invisibleDuration = 2000L, // Invisible for 2 seconds&#10;                visibleDuration = 1500L     // Visible for 1.5 seconds&#10;            )&#10;        }&#10;    }&#10;&#10;    // Track respawn times&#10;    val monsterRespawnTimes = remember { MutableList(invisibleMonsters.size) { 0L } }&#10;&#10;    val coins = remember {&#10;        List(6) {&#10;            BaseCoin(&#10;                x = Random.nextFloat() * (screenWidthPx - 50f),&#10;                y = mutableStateOf(-Random.nextInt(100, 600).toFloat()),&#10;                speed = Random.nextFloat() * 2f + 1f&#10;            )&#10;        }&#10;    }&#10;&#10;    val bullets = remember { mutableStateListOf&lt;Bullet&gt;() }&#10;    val bagCoins = remember { mutableStateListOf&lt;BagCoinDisplay&gt;() }&#10;    var chestItems by remember { mutableStateOf&lt;List&lt;ChestItem&gt;&gt;(emptyList()) }&#10;&#10;    // --- Load player data ---&#10;    LaunchedEffect(Unit) {&#10;        if (!playerName.isNullOrBlank()) {&#10;            FirebaseHelper.syncNewPlayer(playerName)&#10;            FirebaseHelper.getScore(playerName) { totalScore = it }&#10;            FirebaseHelper.getChestItems(playerName) { chestItems = it }&#10;        }&#10;    }&#10;&#10;    // --- Shooting ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.add(Bullet(planeX + planeWidth / 2f - 15f, planeY))&#10;            SoundManager.playSoundEffect(soundPool, shootSoundId, 0.5f)&#10;            delay(300)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.forEach { it.y -= 25f }&#10;            bullets.removeAll { it.y &lt; -50f }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Monster movement + invisible toggle ---&#10;    invisibleMonsters.forEachIndexed { index, m -&gt;&#10;        LaunchedEffect(m, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                // Check if monster needs to respawn&#10;                if (!m.alive.value &amp;&amp; System.currentTimeMillis() &gt;= monsterRespawnTimes[index]) {&#10;                    m.y.value = -Random.nextInt(200, 1500).toFloat()&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 100f)&#10;                    m.hp.value = 100&#10;                    m.alive.value = true&#10;                    m.lastToggleTime = System.currentTimeMillis()&#10;                    m.isVisible.value = Random.nextBoolean() // Random start state&#10;                }&#10;&#10;                if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp; !timeActive) {&#10;                    // AI-based evasion: monster tries to dodge bullets intelligently&#10;                    val evasion = AIAvoidanceHelper.calculateEvasion(&#10;                        monsterX = m.x,&#10;                        monsterY = m.y.value,&#10;                        monsterSize = 100f,&#10;                        bullets = bullets,&#10;                        screenWidth = screenWidthPx&#10;                    )&#10;&#10;                    // Apply AI evasion (combines with zigzag movement)&#10;                    val aiDodgeX = evasion.first&#10;&#10;                    // Toggle visibility&#10;                    val currentTime = System.currentTimeMillis()&#10;                    val elapsed = currentTime - m.lastToggleTime&#10;                    val threshold = if (m.isVisible.value) m.visibleDuration else m.invisibleDuration&#10;&#10;                    if (elapsed &gt;= threshold) {&#10;                        m.isVisible.value = !m.isVisible.value&#10;                        m.lastToggleTime = currentTime&#10;                    }&#10;&#10;                    // Wall collision check&#10;                    val wallTop = planeY - 60f&#10;                    val monsterBottom = m.y.value + 80f&#10;&#10;                    if (wallActive &amp;&amp; monsterBottom &gt;= wallTop) {&#10;                        // Stop at wall&#10;                    } else {&#10;                        // Normal movement&#10;                        m.y.value += m.speed&#10;                    }&#10;&#10;                    // Zigzag movement combined with AI evasion&#10;                    val combinedX = (m.horizontalSpeed * m.direction) + aiDodgeX&#10;                    m.x = (m.x + combinedX).coerceIn(0f, screenWidthPx - 100f)&#10;&#10;                    if (m.x &lt;= 0 || m.x &gt;= screenWidthPx - 100f) {&#10;                        m.direction *= -1&#10;                    }&#10;&#10;                    // If monster passes plane&#10;                    if (m.y.value &gt; planeY + planeHeight / 2f) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) planeHp -= 50&#10;                        monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 8000)&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;                delay(16)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Coin movement ---&#10;    coins.forEach { c -&gt;&#10;        LaunchedEffect(c, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                if (!c.collected.value &amp;&amp; !timeActive) {&#10;                    c.y.value += c.speed&#10;                    if (c.y.value &gt; screenHeightPx) {&#10;                        c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                        c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                    }&#10;                }&#10;                delay(32)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Bullet vs Monster collision (only when visible) ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            val iter = bullets.iterator()&#10;            while (iter.hasNext()) {&#10;                val b = iter.next()&#10;                invisibleMonsters.forEach { m -&gt;&#10;                    // Can only hit visible monsters&#10;                    if (m.isVisible.value &amp;&amp; CollisionUtils.checkCollisionBulletInvisibleMonster(b, m)) {&#10;                        m.hp.value -= 25&#10;                        // Play hit sound&#10;                        SoundManager.playSoundEffect(soundPool, hitSoundId, 0.3f)&#10;                        iter.remove()&#10;                        if (m.hp.value &lt;= 0) {&#10;                            m.alive.value = false&#10;                            val index = invisibleMonsters.indexOf(m)&#10;                            if (index &gt;= 0) {&#10;                                monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 8000)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Coin collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            coins.forEach { c -&gt;&#10;                if (!c.collected.value &amp;&amp; CollisionUtils.checkCollisionPlaneCoin(planeX, planeY, planeWidth, planeHeight, c)) {&#10;                    c.collected.value = true&#10;                    totalScore += 1&#10;                    currentSessionScore += 1&#10;                    val bag = BagCoinDisplay(c.x, c.y.value, 1)&#10;                    bagCoins.add(bag)&#10;                    if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Monster collision (only when visible) ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            invisibleMonsters.forEach { m -&gt;&#10;                if (m.isVisible.value &amp;&amp; CollisionUtils.checkCollisionPlaneInvisibleMonster(planeX, planeY, planeWidth, planeHeight, m)) {&#10;                    if (!shieldActive &amp;&amp; !wallActive) planeHp -= 50&#10;                    m.hp.value = 0&#10;                    m.alive.value = false&#10;                }&#10;            }&#10;            if (planeHp &lt;= 0) isGameOver = true&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Wall - Monster collision ---&#10;    LaunchedEffect(wallActive, isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            if (wallActive) {&#10;                invisibleMonsters.forEach { m -&gt;&#10;                    if (m.isVisible.value &amp;&amp; CollisionUtils.checkCollisionWallInvisibleMonster(planeY, m)) {&#10;                        m.hp.value -= 2&#10;                        if (m.hp.value &lt;= 0) {&#10;                            m.alive.value = false&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Use chest item ---&#10;    fun useChestItem(item: ChestItem) {&#10;        ChestItemEffectsBase.applyItemEffect(&#10;            itemName = item.name,&#10;            monsters = invisibleMonsters,&#10;            coins = coins,&#10;            bagCoins = bagCoins,&#10;            coroutineScope = coroutineScope,&#10;            screenHeightPx = screenHeightPx,&#10;            planeX = planeX,&#10;            onScoreUpdate = { add -&gt;&#10;                totalScore += add&#10;                currentSessionScore += add&#10;                if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;            },&#10;            onShieldToggle = { active -&gt; shieldActive = active },&#10;            onWallToggle = { active -&gt; wallActive = active },&#10;            onTimeToggle = { active -&gt; timeActive = active },&#10;            onLevelClear = { isLevelClear = true }&#10;        )&#10;        chestItems = chestItems - item&#10;        if (!playerName.isNullOrBlank()) FirebaseHelper.updateChest(playerName, chestItems)&#10;    }&#10;&#10;    // --- Drag plane ---&#10;    val dragModifier = Modifier.pointerInput(Unit) {&#10;        detectDragGestures { change, dragAmount -&gt;&#10;            planeX = (planeX + dragAmount.x).coerceIn(0f, screenWidthPx - planeWidth)&#10;            change.consume()&#10;        }&#10;    }&#10;&#10;    // --- UI ---&#10;    Box(modifier = Modifier.fillMaxSize()) {&#10;        // Background layer - separate from drag gestures&#10;        Box(modifier = Modifier.fillMaxSize()) {&#10;            // Hình nền chính&#10;            Image(&#10;                painter = painterResource(R.drawable.nen3),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .offset { IntOffset(0, offsetY.roundToInt()) },&#10;                contentScale = ContentScale.Crop&#10;            )&#10;            // Hình nền phụ để tạo hiệu ứng lặp&#10;            Image(&#10;                painter = painterResource(R.drawable.nen3),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .offset { IntOffset(0, (offsetY - screenHeightPx).roundToInt()) },&#10;                contentScale = ContentScale.Crop&#10;            )&#10;        }&#10;&#10;        // Game content with drag gesture&#10;        Box(modifier = Modifier.fillMaxSize().then(dragModifier)) {&#10;            // Monsters (Level 3 uses InvisibleMonsterUI)&#10;            invisibleMonsters.forEach { m -&gt;&#10;                InvisibleMonsterUI(monster = m, level = 3)&#10;            }&#10;&#10;            // Coins&#10;            coins.filter { !it.collected.value }.forEach { c -&gt;&#10;                Image(&#10;                    painter = painterResource(R.drawable.coin),&#10;                    contentDescription = null,&#10;                    modifier = Modifier&#10;                        .absoluteOffset { IntOffset(c.x.roundToInt(), c.y.value.roundToInt()) }&#10;                        .size(40.dp)&#10;                )&#10;            }&#10;&#10;            // BagCoin animated views&#10;            bagCoins.toList().forEach { bag -&gt;&#10;                BagCoinAnimatedView(bag = bag, onFinished = { finishedBag -&gt;&#10;                    bagCoins.remove(finishedBag)&#10;                })&#10;            }&#10;&#10;            // Bullets&#10;            bullets.forEach { b -&gt;&#10;                Image(&#10;                    painter = painterResource(R.drawable.dan2),&#10;                    contentDescription = null,&#10;                    modifier = Modifier&#10;                        .absoluteOffset { IntOffset(b.x.roundToInt(), b.y.roundToInt()) }&#10;                        .size(30.dp)&#10;                )&#10;            }&#10;&#10;            // Plane&#10;            PlaneUI(&#10;                planeX = planeX,&#10;                planeY = planeY,&#10;                planeHp = planeHp,&#10;                shieldActive = shieldActive,&#10;                level = 3&#10;            )&#10;&#10;            // Wall&#10;            if (wallActive) {&#10;                WallUI(planeY = planeY)&#10;            }&#10;&#10;            // Top bar&#10;            TopBarUI(&#10;                bagCoinScore = totalScore,&#10;                chestItems = chestItems,&#10;                onBuyItem = { item, price -&gt;&#10;                    if (totalScore &gt;= price) {&#10;                        totalScore -= price&#10;                        chestItems = chestItems + item&#10;                        if (!playerName.isNullOrBlank()) {&#10;                            FirebaseHelper.updateScore(playerName, totalScore)&#10;                            FirebaseHelper.updateChest(playerName, chestItems)&#10;                        }&#10;                    }&#10;                },&#10;                onUseChestItem = { useChestItem(it) }&#10;            )&#10;&#10;            // --- Sound Control Button (top-right corner) ---&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(16.dp),&#10;                contentAlignment = androidx.compose.ui.Alignment.TopEnd&#10;            ) {&#10;                SoundControlButton()&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Game End Dialog ---&#10;    if (showGameEndDialog) {&#10;        GameEndDialog(&#10;            isWin = isLevelClear,&#10;            score = currentSessionScore,&#10;            level = 3,&#10;            onDismiss = {&#10;                showGameEndDialog = false&#10;            },&#10;            onReplay = {&#10;                // Reset game&#10;                showGameEndDialog = false&#10;                isGameOver = false&#10;                isLevelClear = false&#10;                planeHp = 100&#10;                currentSessionScore = 0&#10;&#10;                invisibleMonsters.forEachIndexed { index, m -&gt;&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 100f)&#10;                    m.y.value = -Random.nextInt(200, 3000).toFloat()&#10;                    m.hp.value = 100&#10;                    m.alive.value = true&#10;                    m.isVisible.value = Random.nextBoolean()&#10;                    m.lastToggleTime = System.currentTimeMillis()&#10;                    monsterRespawnTimes[index] = 0L&#10;                }&#10;&#10;                coins.forEach { c -&gt;&#10;                    c.collected.value = false&#10;                    c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                    c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                }&#10;&#10;                bullets.clear()&#10;            },&#10;            onNextLevel = {&#10;                onExit()&#10;            },&#10;            onExit = {&#10;                onExit()&#10;            },&#10;            playerName = playerName,&#10;            totalScore = totalScore&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/game/Level5Activity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/game/Level5Activity.kt" />
              <option name="originalContent" value="package com.example.game&#10;&#10;import android.os.Bundle&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.TopBarComponent.TopBarUI&#10;import com.example.game.core.*&#10;import com.example.game.ui.PlaneUI&#10;import com.example.game.ui.WallUI&#10;import com.example.game.ui.SplittingMonsterUI&#10;import com.example.game.ui.SoundControlButton&#10;import com.example.game.ui.BagCoinAnimatedView&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.roundToInt&#10;import kotlin.random.Random&#10;&#10;class Level5Activity : BaseGameActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        initAudio()&#10;&#10;        // Initialize AI Avoidance Helper for smart bullet dodging&#10;        try {&#10;            AIAvoidanceHelper.init(this)&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            // Continue without AI if it fails&#10;        }&#10;&#10;        setContent {&#10;            val density = LocalDensity.current&#10;            val screenWidthPx = with(density) { LocalConfiguration.current.screenWidthDp.dp.toPx() }&#10;            val screenHeightPx = with(density) { LocalConfiguration.current.screenHeightDp.dp.toPx() }&#10;&#10;            Level5Game(&#10;                screenWidthPx = screenWidthPx,&#10;                screenHeightPx = screenHeightPx,&#10;                soundPool = soundPool,&#10;                shootSoundId = shootSoundId,&#10;                hitSoundId = hitSoundId,&#10;                onExit = { finish() }&#10;            )&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        try {&#10;            AIAvoidanceHelper.release()&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Level5Game(&#10;    screenWidthPx: Float,&#10;    screenHeightPx: Float,&#10;    soundPool: android.media.SoundPool,&#10;    shootSoundId: Int,&#10;    hitSoundId: Int,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val playerName = PrefManager.getPlayerName(context)&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // --- State ---&#10;    var totalScore by remember { mutableStateOf(0) }&#10;    var currentSessionScore by remember { mutableStateOf(0) }&#10;    var planeHp by remember { mutableStateOf(100) }&#10;&#10;    var shieldActive by remember { mutableStateOf(false) }&#10;    var wallActive by remember { mutableStateOf(false) }&#10;    var timeActive by remember { mutableStateOf(false) }&#10;&#10;    var isGameOver by remember { mutableStateOf(false) }&#10;    var isLevelClear by remember { mutableStateOf(false) }&#10;    var showGameEndDialog by remember { mutableStateOf(false) }&#10;&#10;    // Show dialog when game ends&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        if (isGameOver || isLevelClear) {&#10;            delay(500)&#10;            showGameEndDialog = true&#10;        }&#10;    }&#10;&#10;    // --- Plane setup ---&#10;    var planeX by remember { mutableStateOf(screenWidthPx / 2 - 50f) }&#10;    val planeY = screenHeightPx - 250f&#10;    val planeWidth = 100f&#10;    val planeHeight = 100f&#10;&#10;    // --- Background ---&#10;    var bg1Y by remember { mutableStateOf(0f) }&#10;    var bg2Y by remember { mutableStateOf(-screenHeightPx) }&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bg1Y += 4f&#10;            bg2Y += 4f&#10;            if (bg1Y &gt;= screenHeightPx) bg1Y = bg2Y - screenHeightPx&#10;            if (bg2Y &gt;= screenHeightPx) bg2Y = bg1Y - screenHeightPx&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Splitting Monsters (dynamic list) ---&#10;    val splittingMonsters = remember { mutableStateListOf&lt;SplittingMonster&gt;() }&#10;&#10;    // Initialize with some parent monsters&#10;    LaunchedEffect(Unit) {&#10;        repeat(8) {&#10;            splittingMonsters.add(&#10;                SplittingMonster(&#10;                    x = Random.nextFloat() * (screenWidthPx - 80f),&#10;                    y = mutableStateOf(-Random.nextInt(200, 2000).toFloat()),&#10;                    speed = Random.nextFloat() * 1.5f + 1.5f,&#10;                    hp = mutableStateOf(100),&#10;                    size = 80f,&#10;                    generation = 1&#10;                )&#10;            )&#10;        }&#10;    }&#10;&#10;    val coins = remember {&#10;        List(6) {&#10;            BaseCoin(&#10;                x = Random.nextFloat() * (screenWidthPx - 50f),&#10;                y = mutableStateOf(-Random.nextInt(100, 600).toFloat()),&#10;                speed = Random.nextFloat() * 2f + 1f&#10;            )&#10;        }&#10;    }&#10;&#10;    val bullets = remember { mutableStateListOf&lt;Bullet&gt;() }&#10;    val bagCoins = remember { mutableStateListOf&lt;BagCoinDisplay&gt;() }&#10;    var chestItems by remember { mutableStateOf&lt;List&lt;ChestItem&gt;&gt;(emptyList()) }&#10;&#10;    // --- Load player data ---&#10;    LaunchedEffect(Unit) {&#10;        if (!playerName.isNullOrBlank()) {&#10;            FirebaseHelper.syncNewPlayer(playerName)&#10;            FirebaseHelper.getScore(playerName) { totalScore = it }&#10;            FirebaseHelper.getChestItems(playerName) { chestItems = it }&#10;        }&#10;    }&#10;&#10;    // --- Shooting ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.add(Bullet(planeX + planeWidth / 2f - 15f, planeY))&#10;            SoundManager.playSoundEffect(soundPool, shootSoundId, 0.5f)&#10;            delay(300)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.forEach { it.y -= 25f }&#10;            bullets.removeAll { it.y &lt; -50f }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Monster movement (zigzag or bounce) + AI evasion ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            // Create a snapshot to avoid concurrent modification&#10;            val currentMonsters = splittingMonsters.toList()&#10;            currentMonsters.forEach { m -&gt;&#10;                if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp; !timeActive) {&#10;                    // AI-based evasion: monster tries to dodge bullets intelligently&#10;                    val evasion = AIAvoidanceHelper.calculateEvasion(&#10;                        monsterX = m.x,&#10;                        monsterY = m.y.value,&#10;                        monsterSize = m.size,&#10;                        bullets = bullets,&#10;                        screenWidth = screenWidthPx&#10;                    )&#10;&#10;                    if (m.isZigzagMovement) {&#10;                        // Zigzag movement combined with AI evasion&#10;                        val combinedX = (m.horizontalSpeed * m.direction) + evasion.first&#10;                        m.x = (m.x + combinedX).coerceIn(0f, screenWidthPx - m.size)&#10;&#10;                        if (m.x &lt;= 0 || m.x &gt;= screenWidthPx - m.size) {&#10;                            m.direction *= -1&#10;                        }&#10;                        m.y.value += m.speed&#10;                    } else {&#10;                        // Bounce movement combined with AI evasion&#10;                        m.x = (m.x + m.velocityX + evasion.first).coerceIn(0f, screenWidthPx - m.size)&#10;                        m.y.value += m.velocityY&#10;&#10;                        // Bounce off walls&#10;                        if (m.x &lt;= 0 || m.x &gt;= screenWidthPx - m.size) {&#10;                            m.velocityX *= -1&#10;                        }&#10;&#10;                        // Bounce off top (optional)&#10;                        if (m.y.value &lt;= 0) {&#10;                            m.velocityY *= -1&#10;                            m.y.value = 0f&#10;                        }&#10;                    }&#10;&#10;                    // Wall collision check&#10;                    val wallTop = planeY - 60f&#10;                    val monsterBottom = m.y.value + m.size&#10;&#10;                    if (wallActive &amp;&amp; monsterBottom &gt;= wallTop) {&#10;                        // Bounce back from wall&#10;                        if (!m.isZigzagMovement) {&#10;                            m.velocityY *= -1&#10;                        }&#10;                    }&#10;&#10;                    // If monster passes plane&#10;                    if (m.y.value &gt; planeY + planeHeight / 2f) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) {&#10;                            val damage = when(m.generation) {&#10;                                1 -&gt; 50 // Large&#10;                                2 -&gt; 30 // Medium&#10;                                else -&gt; 20 // Small&#10;                            }&#10;                            planeHp -= damage&#10;                        }&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Remove dead monsters (but spawn children first)&#10;            splittingMonsters.removeAll { !it.alive.value &amp;&amp; it.hasSpawned.value }&#10;&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Split monsters when killed ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            // Create a snapshot to avoid concurrent modification&#10;            val currentMonsters = splittingMonsters.toList()&#10;            currentMonsters.forEach { m -&gt;&#10;                if (!m.alive.value &amp;&amp; m.canSplit &amp;&amp; !m.hasSpawned.value) {&#10;                    m.hasSpawned.value = true&#10;&#10;                    // Spawn 2-3 smaller monsters&#10;                    val childCount = Random.nextInt(2, 4) // 2 or 3&#10;                    val newSize = m.size * 0.6f // 60% of parent size&#10;                    val newGeneration = m.generation + 1&#10;&#10;                    repeat(childCount) {&#10;                        splittingMonsters.add(&#10;                            SplittingMonster(&#10;                                x = m.x + Random.nextFloat() * 20f - 10f,&#10;                                y = mutableStateOf(m.y.value),&#10;                                speed = m.speed * 1.2f,&#10;                                hp = mutableStateOf(60),&#10;                                size = newSize,&#10;                                generation = newGeneration&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Coin movement ---&#10;    coins.forEach { c -&gt;&#10;        LaunchedEffect(c, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                if (!c.collected.value &amp;&amp; !timeActive) {&#10;                    c.y.value += c.speed&#10;                    if (c.y.value &gt; screenHeightPx) {&#10;                        c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                        c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                    }&#10;                }&#10;                delay(32)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Bullet vs Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            val iter = bullets.iterator()&#10;            while (iter.hasNext()) {&#10;                val b = iter.next()&#10;                // Create snapshot to avoid concurrent modification&#10;                val currentMonsters = splittingMonsters.toList()&#10;                var bulletRemoved = false&#10;                currentMonsters.forEach { m -&gt;&#10;                    if (!bulletRemoved &amp;&amp; CollisionUtils.checkCollisionBulletSplittingMonster(b, m)) {&#10;                        m.hp.value -= 25&#10;                        bulletRemoved = true&#10;                        // Play hit sound when bullet hits monster&#10;                        SoundManager.playSoundEffect(soundPool, hitSoundId, 0.3f)&#10;                        if (m.hp.value &lt;= 0) {&#10;                            m.alive.value = false&#10;                        }&#10;                    }&#10;                }&#10;                if (bulletRemoved) {&#10;                    iter.remove()&#10;                }&#10;            }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Coin collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            coins.forEach { c -&gt;&#10;                if (!c.collected.value &amp;&amp; CollisionUtils.checkCollisionPlaneCoin(planeX, planeY, planeWidth, planeHeight, c)) {&#10;                    c.collected.value = true&#10;                    totalScore += 1&#10;                    currentSessionScore += 1&#10;                    val bag = BagCoinDisplay(c.x, c.y.value, 1)&#10;                    bagCoins.add(bag)&#10;                    if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            // Create snapshot to avoid concurrent modification&#10;            val currentMonsters = splittingMonsters.toList()&#10;            currentMonsters.forEach { m -&gt;&#10;                if (CollisionUtils.checkCollisionPlaneSplittingMonster(planeX, planeY, planeWidth, planeHeight, m)) {&#10;                    if (!shieldActive &amp;&amp; !wallActive) {&#10;                        val damage = when(m.generation) {&#10;                            1 -&gt; 50&#10;                            2 -&gt; 30&#10;                            else -&gt; 20&#10;                        }&#10;                        planeHp -= damage&#10;                    }&#10;                    m.hp.value = 0&#10;                    m.alive.value = false&#10;                }&#10;            }&#10;            if (planeHp &lt;= 0) isGameOver = true&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Wall - Monster collision ---&#10;    LaunchedEffect(wallActive, isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            if (wallActive) {&#10;                // Create snapshot to avoid concurrent modification&#10;                val currentMonsters = splittingMonsters.toList()&#10;                currentMonsters.forEach { m -&gt;&#10;                    if (CollisionUtils.checkCollisionWallSplittingMonster(planeY, m)) {&#10;                        m.hp.value -= 2&#10;                        if (m.hp.value &lt;= 0) {&#10;                            m.alive.value = false&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Use chest item ---&#10;    fun useChestItem(item: ChestItem) {&#10;        ChestItemEffectsBase.applyItemEffect(&#10;            itemName = item.name,&#10;            monsters = splittingMonsters,&#10;            coins = coins,&#10;            bagCoins = bagCoins,&#10;            coroutineScope = coroutineScope,&#10;            screenHeightPx = screenHeightPx,&#10;            planeX = planeX,&#10;            onScoreUpdate = { add -&gt;&#10;                totalScore += add&#10;                currentSessionScore += add&#10;                if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;            },&#10;            onShieldToggle = { active -&gt; shieldActive = active },&#10;            onWallToggle = { active -&gt; wallActive = active },&#10;            onTimeToggle = { active -&gt; timeActive = active },&#10;            onLevelClear = { isLevelClear = true }&#10;        )&#10;        chestItems = chestItems - item&#10;        if (!playerName.isNullOrBlank()) FirebaseHelper.updateChest(playerName, chestItems)&#10;    }&#10;&#10;    // --- Drag plane ---&#10;    val dragModifier = Modifier.pointerInput(Unit) {&#10;        detectDragGestures { change, dragAmount -&gt;&#10;            planeX = (planeX + dragAmount.x).coerceIn(0f, screenWidthPx - planeWidth)&#10;            change.consume()&#10;        }&#10;    }&#10;&#10;    // --- UI ---&#10;    Box(modifier = Modifier.fillMaxSize()) {&#10;        // Background layer - separate from drag gestures&#10;        Box(modifier = Modifier.fillMaxSize()) {&#10;            // Background&#10;            Image(&#10;                painter = painterResource(R.drawable.nen5),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .offset { IntOffset(0, bg1Y.roundToInt()) },&#10;                contentScale = ContentScale.Crop&#10;            )&#10;            Image(&#10;                painter = painterResource(R.drawable.nen5),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .offset { IntOffset(0, bg2Y.roundToInt()) },&#10;                contentScale = ContentScale.Crop&#10;            )&#10;        }&#10;&#10;        // Game content with drag gesture&#10;        Box(modifier = Modifier.fillMaxSize().then(dragModifier)) {&#10;            // Splitting Monsters&#10;            splittingMonsters.forEach { m -&gt;&#10;                SplittingMonsterUI(monster = m, level = 5)&#10;            }&#10;&#10;            // Coins&#10;            coins.filter { !it.collected.value }.forEach { c -&gt;&#10;                Image(&#10;                    painter = painterResource(R.drawable.coin),&#10;                    contentDescription = null,&#10;                    modifier = Modifier&#10;                        .absoluteOffset { IntOffset(c.x.roundToInt(), c.y.value.roundToInt()) }&#10;                        .size(40.dp)&#10;                )&#10;            }&#10;&#10;            // BagCoin animated views&#10;            bagCoins.toList().forEach { bag -&gt;&#10;                BagCoinAnimatedView(bag = bag, onFinished = { finishedBag -&gt;&#10;                    bagCoins.remove(finishedBag)&#10;                })&#10;            }&#10;&#10;            // Bullets&#10;            bullets.forEach { b -&gt;&#10;                Image(&#10;                    painter = painterResource(R.drawable.dan2),&#10;                    contentDescription = null,&#10;                    modifier = Modifier&#10;                        .absoluteOffset { IntOffset(b.x.roundToInt(), b.y.roundToInt()) }&#10;                        .size(30.dp)&#10;                )&#10;            }&#10;&#10;            // Plane&#10;            PlaneUI(&#10;                planeX = planeX,&#10;                planeY = planeY,&#10;                planeHp = planeHp,&#10;                shieldActive = shieldActive,&#10;                level = 5&#10;            )&#10;&#10;            // Wall&#10;            if (wallActive) {&#10;                WallUI(planeY = planeY)&#10;            }&#10;&#10;            // Top bar&#10;            TopBarUI(&#10;                bagCoinScore = totalScore,&#10;                chestItems = chestItems,&#10;                onBuyItem = { item, price -&gt;&#10;                    if (totalScore &gt;= price) {&#10;                        totalScore -= price&#10;                        chestItems = chestItems + item&#10;                        if (!playerName.isNullOrBlank()) {&#10;                            FirebaseHelper.updateScore(playerName, totalScore)&#10;                            FirebaseHelper.updateChest(playerName, chestItems)&#10;                        }&#10;                    }&#10;                },&#10;                onUseChestItem = { useChestItem(it) }&#10;            )&#10;&#10;            // --- Sound Control Button (top-right corner) ---&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(16.dp),&#10;                contentAlignment = Alignment.TopEnd&#10;            ) {&#10;                SoundControlButton()&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Game End Dialog ---&#10;    if (showGameEndDialog) {&#10;        GameEndDialog(&#10;            isWin = isLevelClear,&#10;            score = currentSessionScore,&#10;            level = 5,&#10;            onDismiss = {&#10;                showGameEndDialog = false&#10;            },&#10;            onReplay = {&#10;                showGameEndDialog = false&#10;                isGameOver = false&#10;                isLevelClear = false&#10;                planeHp = 100&#10;                currentSessionScore = 0&#10;&#10;                splittingMonsters.clear()&#10;                repeat(8) {&#10;                    splittingMonsters.add(&#10;                        SplittingMonster(&#10;                            x = Random.nextFloat() * (screenWidthPx - 80f),&#10;                            y = mutableStateOf(-Random.nextInt(200, 2000).toFloat()),&#10;                            speed = Random.nextFloat() * 1.5f + 1.5f,&#10;                            hp = mutableStateOf(100),&#10;                            size = 80f,&#10;                            generation = 1&#10;                        )&#10;                    )&#10;                }&#10;&#10;                coins.forEach { c -&gt;&#10;                    c.collected.value = false&#10;                    c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                    c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                }&#10;&#10;                bullets.clear()&#10;            },&#10;            onNextLevel = {&#10;                onExit()&#10;            },&#10;            onExit = {&#10;                onExit()&#10;            }&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.game&#10;&#10;import android.os.Bundle&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.TopBarComponent.TopBarUI&#10;import com.example.game.core.*&#10;import com.example.game.ui.PlaneUI&#10;import com.example.game.ui.WallUI&#10;import com.example.game.ui.SplittingMonsterUI&#10;import com.example.game.ui.SoundControlButton&#10;import com.example.game.ui.BagCoinAnimatedView&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.roundToInt&#10;import kotlin.random.Random&#10;&#10;class Level5Activity : BaseGameActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        initAudio()&#10;&#10;        // Initialize AI Avoidance Helper for smart bullet dodging&#10;        try {&#10;            AIAvoidanceHelper.init(this)&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            // Continue without AI if it fails&#10;        }&#10;&#10;        setContent {&#10;            val density = LocalDensity.current&#10;            val screenWidthPx = with(density) { LocalConfiguration.current.screenWidthDp.dp.toPx() }&#10;            val screenHeightPx = with(density) { LocalConfiguration.current.screenHeightDp.dp.toPx() }&#10;&#10;            Level5Game(&#10;                screenWidthPx = screenWidthPx,&#10;                screenHeightPx = screenHeightPx,&#10;                soundPool = soundPool,&#10;                shootSoundId = shootSoundId,&#10;                hitSoundId = hitSoundId,&#10;                onExit = { finish() }&#10;            )&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        try {&#10;            AIAvoidanceHelper.release()&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Level5Game(&#10;    screenWidthPx: Float,&#10;    screenHeightPx: Float,&#10;    soundPool: android.media.SoundPool,&#10;    shootSoundId: Int,&#10;    hitSoundId: Int,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val playerName = PrefManager.getPlayerName(context)&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // --- State ---&#10;    var totalScore by remember { mutableStateOf(0) }&#10;    var currentSessionScore by remember { mutableStateOf(0) }&#10;    var planeHp by remember { mutableStateOf(100) }&#10;&#10;    var shieldActive by remember { mutableStateOf(false) }&#10;    var wallActive by remember { mutableStateOf(false) }&#10;    var timeActive by remember { mutableStateOf(false) }&#10;&#10;    var isGameOver by remember { mutableStateOf(false) }&#10;    var isLevelClear by remember { mutableStateOf(false) }&#10;    var showGameEndDialog by remember { mutableStateOf(false) }&#10;&#10;    // Show dialog when game ends&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        if (isGameOver || isLevelClear) {&#10;            delay(500)&#10;            showGameEndDialog = true&#10;        }&#10;    }&#10;&#10;    // --- Plane setup ---&#10;    var planeX by remember { mutableStateOf(screenWidthPx / 2 - 50f) }&#10;    val planeY = screenHeightPx - 250f&#10;    val planeWidth = 100f&#10;    val planeHeight = 100f&#10;&#10;    // --- Background ---&#10;    var bg1Y by remember { mutableStateOf(0f) }&#10;    var bg2Y by remember { mutableStateOf(-screenHeightPx) }&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bg1Y += 4f&#10;            bg2Y += 4f&#10;            if (bg1Y &gt;= screenHeightPx) bg1Y = bg2Y - screenHeightPx&#10;            if (bg2Y &gt;= screenHeightPx) bg2Y = bg1Y - screenHeightPx&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Splitting Monsters (dynamic list) ---&#10;    val splittingMonsters = remember { mutableStateListOf&lt;SplittingMonster&gt;() }&#10;&#10;    // Initialize with some parent monsters&#10;    LaunchedEffect(Unit) {&#10;        repeat(8) {&#10;            splittingMonsters.add(&#10;                SplittingMonster(&#10;                    x = Random.nextFloat() * (screenWidthPx - 80f),&#10;                    y = mutableStateOf(-Random.nextInt(200, 2000).toFloat()),&#10;                    speed = Random.nextFloat() * 1.5f + 1.5f,&#10;                    hp = mutableStateOf(100),&#10;                    size = 80f,&#10;                    generation = 1&#10;                )&#10;            )&#10;        }&#10;    }&#10;&#10;    val coins = remember {&#10;        List(6) {&#10;            BaseCoin(&#10;                x = Random.nextFloat() * (screenWidthPx - 50f),&#10;                y = mutableStateOf(-Random.nextInt(100, 600).toFloat()),&#10;                speed = Random.nextFloat() * 2f + 1f&#10;            )&#10;        }&#10;    }&#10;&#10;    val bullets = remember { mutableStateListOf&lt;Bullet&gt;() }&#10;    val bagCoins = remember { mutableStateListOf&lt;BagCoinDisplay&gt;() }&#10;    var chestItems by remember { mutableStateOf&lt;List&lt;ChestItem&gt;&gt;(emptyList()) }&#10;&#10;    // --- Load player data ---&#10;    LaunchedEffect(Unit) {&#10;        if (!playerName.isNullOrBlank()) {&#10;            FirebaseHelper.syncNewPlayer(playerName)&#10;            FirebaseHelper.getScore(playerName) { totalScore = it }&#10;            FirebaseHelper.getChestItems(playerName) { chestItems = it }&#10;        }&#10;    }&#10;&#10;    // --- Shooting ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.add(Bullet(planeX + planeWidth / 2f - 15f, planeY))&#10;            SoundManager.playSoundEffect(soundPool, shootSoundId, 0.5f)&#10;            delay(300)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.forEach { it.y -= 25f }&#10;            bullets.removeAll { it.y &lt; -50f }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Monster movement (zigzag or bounce) + AI evasion ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            // Create a snapshot to avoid concurrent modification&#10;            val currentMonsters = splittingMonsters.toList()&#10;            currentMonsters.forEach { m -&gt;&#10;                if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp; !timeActive) {&#10;                    // AI-based evasion: monster tries to dodge bullets intelligently&#10;                    val evasion = AIAvoidanceHelper.calculateEvasion(&#10;                        monsterX = m.x,&#10;                        monsterY = m.y.value,&#10;                        monsterSize = m.size,&#10;                        bullets = bullets,&#10;                        screenWidth = screenWidthPx&#10;                    )&#10;&#10;                    if (m.isZigzagMovement) {&#10;                        // Zigzag movement combined with AI evasion&#10;                        val combinedX = (m.horizontalSpeed * m.direction) + evasion.first&#10;                        m.x = (m.x + combinedX).coerceIn(0f, screenWidthPx - m.size)&#10;&#10;                        if (m.x &lt;= 0 || m.x &gt;= screenWidthPx - m.size) {&#10;                            m.direction *= -1&#10;                        }&#10;                        m.y.value += m.speed&#10;                    } else {&#10;                        // Bounce movement combined with AI evasion&#10;                        m.x = (m.x + m.velocityX + evasion.first).coerceIn(0f, screenWidthPx - m.size)&#10;                        m.y.value += m.velocityY&#10;&#10;                        // Bounce off walls&#10;                        if (m.x &lt;= 0 || m.x &gt;= screenWidthPx - m.size) {&#10;                            m.velocityX *= -1&#10;                        }&#10;&#10;                        // Bounce off top (optional)&#10;                        if (m.y.value &lt;= 0) {&#10;                            m.velocityY *= -1&#10;                            m.y.value = 0f&#10;                        }&#10;                    }&#10;&#10;                    // Wall collision check&#10;                    val wallTop = planeY - 60f&#10;                    val monsterBottom = m.y.value + m.size&#10;&#10;                    if (wallActive &amp;&amp; monsterBottom &gt;= wallTop) {&#10;                        // Bounce back from wall&#10;                        if (!m.isZigzagMovement) {&#10;                            m.velocityY *= -1&#10;                        }&#10;                    }&#10;&#10;                    // If monster passes plane&#10;                    if (m.y.value &gt; planeY + planeHeight / 2f) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) {&#10;                            val damage = when(m.generation) {&#10;                                1 -&gt; 50 // Large&#10;                                2 -&gt; 30 // Medium&#10;                                else -&gt; 20 // Small&#10;                            }&#10;                            planeHp -= damage&#10;                        }&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Remove dead monsters (but spawn children first)&#10;            splittingMonsters.removeAll { !it.alive.value &amp;&amp; it.hasSpawned.value }&#10;&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Split monsters when killed ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            // Create a snapshot to avoid concurrent modification&#10;            val currentMonsters = splittingMonsters.toList()&#10;            currentMonsters.forEach { m -&gt;&#10;                if (!m.alive.value &amp;&amp; m.canSplit &amp;&amp; !m.hasSpawned.value) {&#10;                    m.hasSpawned.value = true&#10;&#10;                    // Spawn 2-3 smaller monsters&#10;                    val childCount = Random.nextInt(2, 4) // 2 or 3&#10;                    val newSize = m.size * 0.6f // 60% of parent size&#10;                    val newGeneration = m.generation + 1&#10;&#10;                    repeat(childCount) {&#10;                        splittingMonsters.add(&#10;                            SplittingMonster(&#10;                                x = m.x + Random.nextFloat() * 20f - 10f,&#10;                                y = mutableStateOf(m.y.value),&#10;                                speed = m.speed * 1.2f,&#10;                                hp = mutableStateOf(60),&#10;                                size = newSize,&#10;                                generation = newGeneration&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Coin movement ---&#10;    coins.forEach { c -&gt;&#10;        LaunchedEffect(c, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                if (!c.collected.value &amp;&amp; !timeActive) {&#10;                    c.y.value += c.speed&#10;                    if (c.y.value &gt; screenHeightPx) {&#10;                        c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                        c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                    }&#10;                }&#10;                delay(32)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Bullet vs Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            val iter = bullets.iterator()&#10;            while (iter.hasNext()) {&#10;                val b = iter.next()&#10;                // Create snapshot to avoid concurrent modification&#10;                val currentMonsters = splittingMonsters.toList()&#10;                var bulletRemoved = false&#10;                currentMonsters.forEach { m -&gt;&#10;                    if (!bulletRemoved &amp;&amp; CollisionUtils.checkCollisionBulletSplittingMonster(b, m)) {&#10;                        m.hp.value -= 25&#10;                        bulletRemoved = true&#10;                        // Play hit sound when bullet hits monster&#10;                        SoundManager.playSoundEffect(soundPool, hitSoundId, 0.3f)&#10;                        if (m.hp.value &lt;= 0) {&#10;                            m.alive.value = false&#10;                        }&#10;                    }&#10;                }&#10;                if (bulletRemoved) {&#10;                    iter.remove()&#10;                }&#10;            }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Coin collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            coins.forEach { c -&gt;&#10;                if (!c.collected.value &amp;&amp; CollisionUtils.checkCollisionPlaneCoin(planeX, planeY, planeWidth, planeHeight, c)) {&#10;                    c.collected.value = true&#10;                    totalScore += 1&#10;                    currentSessionScore += 1&#10;                    val bag = BagCoinDisplay(c.x, c.y.value, 1)&#10;                    bagCoins.add(bag)&#10;                    if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            // Create snapshot to avoid concurrent modification&#10;            val currentMonsters = splittingMonsters.toList()&#10;            currentMonsters.forEach { m -&gt;&#10;                if (CollisionUtils.checkCollisionPlaneSplittingMonster(planeX, planeY, planeWidth, planeHeight, m)) {&#10;                    if (!shieldActive &amp;&amp; !wallActive) {&#10;                        val damage = when(m.generation) {&#10;                            1 -&gt; 50&#10;                            2 -&gt; 30&#10;                            else -&gt; 20&#10;                        }&#10;                        planeHp -= damage&#10;                    }&#10;                    m.hp.value = 0&#10;                    m.alive.value = false&#10;                }&#10;            }&#10;            if (planeHp &lt;= 0) isGameOver = true&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Wall - Monster collision ---&#10;    LaunchedEffect(wallActive, isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            if (wallActive) {&#10;                // Create snapshot to avoid concurrent modification&#10;                val currentMonsters = splittingMonsters.toList()&#10;                currentMonsters.forEach { m -&gt;&#10;                    if (CollisionUtils.checkCollisionWallSplittingMonster(planeY, m)) {&#10;                        m.hp.value -= 2&#10;                        if (m.hp.value &lt;= 0) {&#10;                            m.alive.value = false&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Use chest item ---&#10;    fun useChestItem(item: ChestItem) {&#10;        ChestItemEffectsBase.applyItemEffect(&#10;            itemName = item.name,&#10;            monsters = splittingMonsters,&#10;            coins = coins,&#10;            bagCoins = bagCoins,&#10;            coroutineScope = coroutineScope,&#10;            screenHeightPx = screenHeightPx,&#10;            planeX = planeX,&#10;            onScoreUpdate = { add -&gt;&#10;                totalScore += add&#10;                currentSessionScore += add&#10;                if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;            },&#10;            onShieldToggle = { active -&gt; shieldActive = active },&#10;            onWallToggle = { active -&gt; wallActive = active },&#10;            onTimeToggle = { active -&gt; timeActive = active },&#10;            onLevelClear = { isLevelClear = true }&#10;        )&#10;        chestItems = chestItems - item&#10;        if (!playerName.isNullOrBlank()) FirebaseHelper.updateChest(playerName, chestItems)&#10;    }&#10;&#10;    // --- Drag plane ---&#10;    val dragModifier = Modifier.pointerInput(Unit) {&#10;        detectDragGestures { change, dragAmount -&gt;&#10;            planeX = (planeX + dragAmount.x).coerceIn(0f, screenWidthPx - planeWidth)&#10;            change.consume()&#10;        }&#10;    }&#10;&#10;    // --- UI ---&#10;    Box(modifier = Modifier.fillMaxSize()) {&#10;        // Background layer - separate from drag gestures&#10;        Box(modifier = Modifier.fillMaxSize()) {&#10;            // Background&#10;            Image(&#10;                painter = painterResource(R.drawable.nen5),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .offset { IntOffset(0, bg1Y.roundToInt()) },&#10;                contentScale = ContentScale.Crop&#10;            )&#10;            Image(&#10;                painter = painterResource(R.drawable.nen5),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .offset { IntOffset(0, bg2Y.roundToInt()) },&#10;                contentScale = ContentScale.Crop&#10;            )&#10;        }&#10;&#10;        // Game content with drag gesture&#10;        Box(modifier = Modifier.fillMaxSize().then(dragModifier)) {&#10;            // Splitting Monsters&#10;            splittingMonsters.forEach { m -&gt;&#10;                SplittingMonsterUI(monster = m, level = 5)&#10;            }&#10;&#10;            // Coins&#10;            coins.filter { !it.collected.value }.forEach { c -&gt;&#10;                Image(&#10;                    painter = painterResource(R.drawable.coin),&#10;                    contentDescription = null,&#10;                    modifier = Modifier&#10;                        .absoluteOffset { IntOffset(c.x.roundToInt(), c.y.value.roundToInt()) }&#10;                        .size(40.dp)&#10;                )&#10;            }&#10;&#10;            // BagCoin animated views&#10;            bagCoins.toList().forEach { bag -&gt;&#10;                BagCoinAnimatedView(bag = bag, onFinished = { finishedBag -&gt;&#10;                    bagCoins.remove(finishedBag)&#10;                })&#10;            }&#10;&#10;            // Bullets&#10;            bullets.forEach { b -&gt;&#10;                Image(&#10;                    painter = painterResource(R.drawable.dan2),&#10;                    contentDescription = null,&#10;                    modifier = Modifier&#10;                        .absoluteOffset { IntOffset(b.x.roundToInt(), b.y.roundToInt()) }&#10;                        .size(30.dp)&#10;                )&#10;            }&#10;&#10;            // Plane&#10;            PlaneUI(&#10;                planeX = planeX,&#10;                planeY = planeY,&#10;                planeHp = planeHp,&#10;                shieldActive = shieldActive,&#10;                level = 5&#10;            )&#10;&#10;            // Wall&#10;            if (wallActive) {&#10;                WallUI(planeY = planeY)&#10;            }&#10;&#10;            // Top bar&#10;            TopBarUI(&#10;                bagCoinScore = totalScore,&#10;                chestItems = chestItems,&#10;                onBuyItem = { item, price -&gt;&#10;                    if (totalScore &gt;= price) {&#10;                        totalScore -= price&#10;                        chestItems = chestItems + item&#10;                        if (!playerName.isNullOrBlank()) {&#10;                            FirebaseHelper.updateScore(playerName, totalScore)&#10;                            FirebaseHelper.updateChest(playerName, chestItems)&#10;                        }&#10;                    }&#10;                },&#10;                onUseChestItem = { useChestItem(it) }&#10;            )&#10;&#10;            // --- Sound Control Button (top-right corner) ---&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(16.dp),&#10;                contentAlignment = Alignment.TopEnd&#10;            ) {&#10;                SoundControlButton()&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Game End Dialog ---&#10;    if (showGameEndDialog) {&#10;        GameEndDialog(&#10;            isWin = isLevelClear,&#10;            score = currentSessionScore,&#10;            level = 5,&#10;            onDismiss = {&#10;                showGameEndDialog = false&#10;            },&#10;            onReplay = {&#10;                showGameEndDialog = false&#10;                isGameOver = false&#10;                isLevelClear = false&#10;                planeHp = 100&#10;                currentSessionScore = 0&#10;&#10;                splittingMonsters.clear()&#10;                repeat(8) {&#10;                    splittingMonsters.add(&#10;                        SplittingMonster(&#10;                            x = Random.nextFloat() * (screenWidthPx - 80f),&#10;                            y = mutableStateOf(-Random.nextInt(200, 2000).toFloat()),&#10;                            speed = Random.nextFloat() * 1.5f + 1.5f,&#10;                            hp = mutableStateOf(100),&#10;                            size = 80f,&#10;                            generation = 1&#10;                        )&#10;                    )&#10;                }&#10;&#10;                coins.forEach { c -&gt;&#10;                    c.collected.value = false&#10;                    c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                    c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                }&#10;&#10;                bullets.clear()&#10;            },&#10;            onNextLevel = {&#10;                onExit()&#10;            },&#10;            onExit = {&#10;                onExit()&#10;            },&#10;            playerName = playerName,&#10;            totalScore = totalScore&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/game/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/game/MainActivity.kt" />
              <option name="originalContent" value="package com.example.game&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.widget.Toast&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.example.game.TopBarComponent.TopBarUI&#10;class MainActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        FirebaseHelper.syncAllPlayers()&#10;        FirebaseHelper.syncAllPlayers()&#10;            ?: &quot;Người chơi&quot;&#10;        val playerName = intent.getStringExtra(&quot;PLAYER_NAME&quot;)&#10;            ?: PrefManager.getPlayerName(this)&#10;            ?: &quot;Người chơi&quot;&#10;        setContent {&#10;        FirebaseHelper.syncNewPlayer(playerName)&#10;                var showLevelScreen by remember { mutableStateOf(false) }&#10;        setContent {&#10;            MaterialTheme {&#10;                var showLevelScreen by remember { mutableStateOf(false) }&#10;                    })&#10;                if (showLevelScreen) {&#10;                    LevelPathScreen(onExit = {&#10;                        showLevelScreen = false&#10;                    })&#10;                } else {&#10;                    MainScreen(&#10;                        playerName = playerName,&#10;                        onPlayClicked = { showLevelScreen = true }&#10;                    )&#10;                }&#10;    Box(modifier = Modifier.fillMaxSize()) {&#10;        // Background&#10;        Image(&#10;            painter = painterResource(R.drawable.nen1),&#10;            contentDescription = null,&#10;            modifier = Modifier.fillMaxSize()&#10;        )&#10;&#10;        // Welcome text&#10;        Text(&#10;            text = &quot;Xin chào, $playerName!&quot;,&#10;            color = androidx.compose.ui.graphics.Color.White,&#10;            fontSize = 24.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            modifier = Modifier&#10;                .align(Alignment.TopCenter)&#10;                .padding(top = 40.dp)&#10;        )&#10;&#10;        // Top bar UI (Store, Chest, BagCoin) ở góc trên trái&#10;        Column(&#10;            modifier = Modifier&#10;                .align(Alignment.TopStart)&#10;                .padding(top = 16.dp, start = 16.dp)&#10;        ) {&#10;            TopBarUI(&#10;                bagCoinScore = bagCoinScore.value,&#10;                chestItems = chestItems,&#10;                onBuyItem = { item: ChestItem, price: Int -&gt;&#10;                    if (bagCoinScore.value &gt;= price) {&#10;                        val newScore = bagCoinScore.value - price&#10;                        bagCoinScore.value = newScore&#10;                        chestItems.add(item)&#10;                        if (playerName.isNotBlank()) {&#10;                            FirebaseHelper.updateScore(playerName, newScore)&#10;                            FirebaseHelper.updateChest(playerName, chestItems.toList())&#10;                        }&#10;                        Toast.makeText(context, &quot;Mua ${item.name} thành công!&quot;, Toast.LENGTH_SHORT).show()&#10;                    } else {&#10;                        Toast.makeText(context, &quot;Không đủ coins để mua ${item.name}&quot;, Toast.LENGTH_SHORT).show()&#10;                    }&#10;                },&#10;                onUseChestItem = { item: ChestItem -&gt;&#10;                    // Handle chest item usage if needed&#10;                }&#10;            )&#10;        }&#10;&#10;        // Buttons: Play / Rank / Settings&#10;        Column(&#10;            modifier = Modifier&#10;                .align(Alignment.BottomCenter)&#10;                .padding(bottom = 64.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            Button(onClick = onPlayClicked) {&#10;                Text(&quot;Play&quot;)&#10;            }&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;            Button(&#10;                onClick = { context.startActivity(Intent(context, RankScreenActivity::class.java)) }&#10;            ) { Text(&quot;Rank&quot;) }&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;            Button(&#10;                onClick = { context.startActivity(Intent(context, SettingScreenActivity::class.java)) }&#10;            ) { Text(&quot;Settings&quot;) }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.game&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.util.Log&#10;import android.widget.Toast&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.example.game.TopBarComponent.TopBarUI&#10;&#10;class MainActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        try {&#10;            FirebaseHelper.syncAllPlayers()&#10;&#10;            // Debug: Log all sources of player name&#10;            val nameFromIntent = intent.getStringExtra(&quot;PLAYER_NAME&quot;)&#10;            val nameFromPrefs = PrefManager.getPlayerName(this)&#10;&#10;            Log.d(&quot;MainActivity&quot;, &quot;Name from Intent: $nameFromIntent&quot;)&#10;            Log.d(&quot;MainActivity&quot;, &quot;Name from SharedPreferences: $nameFromPrefs&quot;)&#10;&#10;            val playerName = nameFromIntent ?: nameFromPrefs ?: &quot;Người chơi&quot;&#10;&#10;            Log.d(&quot;MainActivity&quot;, &quot;Final playerName used: $playerName&quot;)&#10;&#10;            FirebaseHelper.syncNewPlayer(playerName)&#10;&#10;            setContent {&#10;                MaterialTheme {&#10;                    var showLevelScreen by remember { mutableStateOf(false) }&#10;&#10;                    if (showLevelScreen) {&#10;                        LevelPathScreen(onExit = {&#10;                            showLevelScreen = false&#10;                        })&#10;                    } else {&#10;                        MainScreen(&#10;                            playerName = playerName,&#10;                            onPlayClicked = { showLevelScreen = true }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;MainActivity&quot;, &quot;onCreate failed&quot;, e)&#10;            // Fallback UI&#10;            setContent {&#10;                Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {&#10;                    Text(&quot;Error loading app&quot;, color = androidx.compose.ui.graphics.Color.White)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun MainScreen(&#10;    playerName: String,&#10;    onPlayClicked: () -&gt; Unit&#10;) {&#10;    // State cho BagCoin &amp; Chest&#10;    val bagCoinScore = remember { mutableStateOf(0) }&#10;    val chestItems = remember { mutableStateListOf&lt;ChestItem&gt;() }&#10;    val context = LocalContext.current&#10;&#10;    // Load score + chest từ Firebase (khôi phục hệ thống cũ)&#10;    LaunchedEffect(playerName) {&#10;        if (playerName.isNotBlank()) {&#10;            FirebaseHelper.getScore(playerName) { score -&gt; bagCoinScore.value = score }&#10;            FirebaseHelper.getChestItems(playerName) { items -&gt;&#10;                chestItems.clear()&#10;                chestItems.addAll(items)&#10;            }&#10;        }&#10;    }&#10;&#10;    Box(modifier = Modifier.fillMaxSize()) {&#10;        // Background&#10;        Image(&#10;            painter = painterResource(R.drawable.nen1),&#10;            contentDescription = null,&#10;            modifier = Modifier.fillMaxSize()&#10;        )&#10;&#10;        // Welcome text&#10;        Text(&#10;            text = &quot;Xin chào, $playerName!&quot;,&#10;            color = androidx.compose.ui.graphics.Color.White,&#10;            fontSize = 24.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            modifier = Modifier&#10;                .align(Alignment.TopCenter)&#10;                .padding(top = 40.dp)&#10;        )&#10;&#10;        // Top bar UI (Store, Chest, BagCoin) ở góc trên trái&#10;        Column(&#10;            modifier = Modifier&#10;                .align(Alignment.TopStart)&#10;                .padding(top = 16.dp, start = 16.dp)&#10;        ) {&#10;            TopBarUI(&#10;                bagCoinScore = bagCoinScore.value,&#10;                chestItems = chestItems,&#10;                onBuyItem = { item: ChestItem, price: Int -&gt;&#10;                    if (bagCoinScore.value &gt;= price) {&#10;                        val newScore = bagCoinScore.value - price&#10;                        bagCoinScore.value = newScore&#10;                        chestItems.add(item)&#10;                        if (playerName.isNotBlank()) {&#10;                            FirebaseHelper.updateScore(playerName, newScore)&#10;                            FirebaseHelper.updateChest(playerName, chestItems.toList())&#10;                        }&#10;                        Toast.makeText(context, &quot;Mua ${item.name} thành công!&quot;, Toast.LENGTH_SHORT).show()&#10;                    } else {&#10;                        Toast.makeText(context, &quot;Không đủ coins để mua ${item.name}&quot;, Toast.LENGTH_SHORT).show()&#10;                    }&#10;                },&#10;                onUseChestItem = { item: ChestItem -&gt;&#10;                    // Handle chest item usage if needed&#10;                }&#10;            )&#10;        }&#10;&#10;        // Buttons: Play / Rank / Settings&#10;        Column(&#10;            modifier = Modifier&#10;                .align(Alignment.BottomCenter)&#10;                .padding(bottom = 64.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            Button(onClick = onPlayClicked) {&#10;                Text(&quot;Play&quot;)&#10;            }&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;            Button(&#10;                onClick = { context.startActivity(Intent(context, RankScreenActivity::class.java)) }&#10;            ) { Text(&quot;Rank&quot;) }&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;            Button(&#10;                onClick = { context.startActivity(Intent(context, SettingScreenActivity::class.java)) }&#10;            ) { Text(&quot;Settings&quot;) }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/game/NameInputActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/game/NameInputActivity.kt" />
              <option name="originalContent" value="package com.example.game&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.util.Log&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;&#10;class NameInputActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContent {&#10;            Box(modifier = Modifier.fillMaxSize()) {&#10;                Image(&#10;                    painter = painterResource(id = R.drawable.nen1),&#10;                    contentDescription = null,&#10;                    modifier = Modifier.fillMaxSize()&#10;                )&#10;&#10;                Box(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .background(&#10;                            Brush.verticalGradient(&#10;                                colors = listOf(&#10;                                    Color.Black.copy(alpha = 0.7f),&#10;                                    Color.Black.copy(alpha = 0.5f),&#10;                                    Color.Transparent&#10;                                )&#10;                            )&#10;                        )&#10;                )&#10;&#10;                Column(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .padding(horizontal = 24.dp),&#10;                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                    verticalArrangement = Arrangement.Center&#10;                ) {&#10;                    Text(&#10;                        text = &quot;NHẬP TÊN CỦA BẠN&quot;,&#10;                        color = Color.Cyan,&#10;                        fontSize = 34.sp,&#10;                        fontWeight = FontWeight.ExtraBold,&#10;                        textAlign = TextAlign.Center,&#10;                        modifier = Modifier.padding(bottom = 32.dp)&#10;                    )&#10;&#10;                    val playerName = remember { mutableStateOf(&quot;&quot;) }&#10;&#10;                    OutlinedTextField(&#10;                        value = playerName.value,&#10;                        onValueChange = { playerName.value = it },&#10;                        label = { Text(&quot;Tên người chơi&quot;, color = Color.White.copy(0.8f)) },&#10;                        singleLine = true,&#10;                        shape = RoundedCornerShape(20.dp),&#10;                        colors = OutlinedTextFieldDefaults.colors(&#10;                            focusedBorderColor = Color.Cyan,&#10;                            unfocusedBorderColor = Color.White.copy(alpha = 0.5f),&#10;                            cursorColor = Color.Cyan,&#10;                            focusedTextColor = Color.White,&#10;                            unfocusedTextColor = Color.White&#10;                        ),&#10;                        modifier = Modifier&#10;                            .fillMaxWidth(0.8f)&#10;                            .background(Color.Black.copy(alpha = 0.3f), RoundedCornerShape(20.dp))&#10;                    )&#10;&#10;                    Spacer(modifier = Modifier.height(40.dp))&#10;&#10;                    Button(&#10;                        onClick = {&#10;                            if (playerName.value.isNotBlank()) {&#10;                                val name = playerName.value&#10;                                PrefManager.savePlayerName(this@NameInputActivity, name)&#10;&#10;                                val db = FirebaseFirestore.getInstance()&#10;                                val playerData = hashMapOf(&#10;                                    &quot;name&quot; to name,&#10;                                    &quot;score&quot; to 0&#10;                                )&#10;&#10;                                db.collection(&quot;rankings&quot;)&#10;                                    .add(playerData)&#10;                                    .addOnSuccessListener { documentReference -&gt;&#10;                                        Log.d(&quot;Firebase&quot;, &quot;Người chơi được lưu: ${documentReference.id}&quot;)&#10;                                        PrefManager.savePlayerDocId(this@NameInputActivity, documentReference.id)&#10;                                    }&#10;                                    .addOnFailureListener { e -&gt;&#10;                                        Log.w(&quot;Firebase&quot;, &quot;Lỗi khi lưu người chơi&quot;, e)&#10;                                    }&#10;&#10;                                val intent = Intent(this@NameInputActivity, MainActivity::class.java)&#10;                                intent.putExtra(&quot;PLAYER_NAME&quot;, name)&#10;                                startActivity(intent)&#10;                                finish()&#10;                            }&#10;                        },&#10;                        enabled = playerName.value.isNotBlank(),&#10;                        shape = RoundedCornerShape(30.dp),&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = Color.White.copy(alpha = 0.15f),&#10;                            contentColor = Color.Cyan&#10;                        ),&#10;                        modifier = Modifier&#10;                            .fillMaxWidth(0.6f)&#10;                            .height(60.dp)&#10;                    ) {&#10;                        Text(&#10;                            &quot;XÁC NHẬN&quot;,&#10;                            fontSize = 20.sp,&#10;                            fontWeight = FontWeight.Bold&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.game&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.util.Log&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;&#10;class NameInputActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContent {&#10;            Box(modifier = Modifier.fillMaxSize()) {&#10;                Image(&#10;                    painter = painterResource(id = R.drawable.nen1),&#10;                    contentDescription = null,&#10;                    modifier = Modifier.fillMaxSize()&#10;                )&#10;&#10;                Box(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .background(&#10;                            Brush.verticalGradient(&#10;                                colors = listOf(&#10;                                    Color.Black.copy(alpha = 0.7f),&#10;                                    Color.Black.copy(alpha = 0.5f),&#10;                                    Color.Transparent&#10;                                )&#10;                            )&#10;                        )&#10;                )&#10;&#10;                Column(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .padding(horizontal = 24.dp),&#10;                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                    verticalArrangement = Arrangement.Center&#10;                ) {&#10;                    Text(&#10;                        text = &quot;NHẬP TÊN CỦA BẠN&quot;,&#10;                        color = Color.Cyan,&#10;                        fontSize = 34.sp,&#10;                        fontWeight = FontWeight.ExtraBold,&#10;                        textAlign = TextAlign.Center,&#10;                        modifier = Modifier.padding(bottom = 32.dp)&#10;                    )&#10;&#10;                    val playerName = remember { mutableStateOf(&quot;&quot;) }&#10;&#10;                    OutlinedTextField(&#10;                        value = playerName.value,&#10;                        onValueChange = { playerName.value = it },&#10;                        label = { Text(&quot;Tên người chơi&quot;, color = Color.White.copy(0.8f)) },&#10;                        singleLine = true,&#10;                        shape = RoundedCornerShape(20.dp),&#10;                        colors = OutlinedTextFieldDefaults.colors(&#10;                            focusedBorderColor = Color.Cyan,&#10;                            unfocusedBorderColor = Color.White.copy(alpha = 0.5f),&#10;                            cursorColor = Color.Cyan,&#10;                            focusedTextColor = Color.White,&#10;                            unfocusedTextColor = Color.White&#10;                        ),&#10;                        modifier = Modifier&#10;                            .fillMaxWidth(0.8f)&#10;                            .background(Color.Black.copy(alpha = 0.3f), RoundedCornerShape(20.dp))&#10;                    )&#10;&#10;                    Spacer(modifier = Modifier.height(40.dp))&#10;&#10;                    Button(&#10;                        onClick = {&#10;                            if (playerName.value.isNotBlank()) {&#10;                                val name = playerName.value.trim()&#10;&#10;                                // LƯU TÊN VÀO SHAREDPREFERENCES NGAY LẬP TỨC&#10;                                Log.d(&quot;NameInputActivity&quot;, &quot;Saving player name: $name&quot;)&#10;                                PrefManager.savePlayerName(this@NameInputActivity, name)&#10;&#10;                                // Verify it was saved&#10;                                val savedName = PrefManager.getPlayerName(this@NameInputActivity)&#10;                                Log.d(&quot;NameInputActivity&quot;, &quot;Verified saved name: $savedName&quot;)&#10;&#10;                                // Lưu vào Firebase&#10;                                val db = FirebaseFirestore.getInstance()&#10;                                val playerData = hashMapOf(&#10;                                    &quot;name&quot; to name,&#10;                                    &quot;score&quot; to 0&#10;                                )&#10;&#10;                                db.collection(&quot;rankings&quot;)&#10;                                    .add(playerData)&#10;                                    .addOnSuccessListener { documentReference -&gt;&#10;                                        Log.d(&quot;NameInputActivity&quot;, &quot;Player saved to Firebase: ${documentReference.id}&quot;)&#10;                                        PrefManager.savePlayerDocId(this@NameInputActivity, documentReference.id)&#10;                                    }&#10;                                    .addOnFailureListener { e -&gt;&#10;                                        Log.w(&quot;NameInputActivity&quot;, &quot;Error saving player to Firebase&quot;, e)&#10;                                    }&#10;&#10;                                // Chuyển sang MainActivity VỚI TÊN&#10;                                val intent = Intent(this@NameInputActivity, MainActivity::class.java)&#10;                                intent.putExtra(&quot;PLAYER_NAME&quot;, name)&#10;                                Log.d(&quot;NameInputActivity&quot;, &quot;Starting MainActivity with name: $name&quot;)&#10;                                startActivity(intent)&#10;                                finish()&#10;                            }&#10;                        },&#10;                        enabled = playerName.value.isNotBlank(),&#10;                        shape = RoundedCornerShape(30.dp),&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = Color.White.copy(alpha = 0.15f),&#10;                            contentColor = Color.Cyan&#10;                        ),&#10;                        modifier = Modifier&#10;                            .fillMaxWidth(0.6f)&#10;                            .height(60.dp)&#10;                    ) {&#10;                        Text(&#10;                            &quot;XÁC NHẬN&quot;,&#10;                            fontSize = 20.sp,&#10;                            fontWeight = FontWeight.Bold&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/game/Splashactivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/game/Splashactivity.kt" />
              <option name="originalContent" value="package com.example.game&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.animation.core.Animatable&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.scale&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.lifecycleScope&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;&#10;class SplashActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContent {&#10;            Box(&#10;                modifier = Modifier.fillMaxSize(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                // Ảnh nền&#10;                Image(&#10;                    painter = painterResource(id = R.drawable.nen1),&#10;                    contentDescription = null,&#10;                    modifier = Modifier.fillMaxSize()&#10;                )&#10;&#10;                // Animatable để scale mượt&#10;                val scale = remember { Animatable(0.8f) }&#10;&#10;                LaunchedEffect(Unit) {&#10;                    scale.animateTo(&#10;                        targetValue = 1.3f,&#10;                        animationSpec = tween(durationMillis = 1800)&#10;                    )&#10;                }&#10;&#10;                // Tên game&#10;                Text(&#10;                    text = &quot;My Game&quot;,&#10;                    color = Color.White,&#10;                    style = MaterialTheme.typography.headlineLarge.copy(&#10;                        fontSize = 50.sp,&#10;                        fontWeight = FontWeight.Bold&#10;                    ),&#10;                    modifier = Modifier.scale(scale.value)&#10;                )&#10;            }&#10;        }&#10;&#10;        lifecycleScope.launch {&#10;            delay(2500)&#10;&#10;            val savedName = PrefManager.getPlayerName(this@SplashActivity)&#10;            if (savedName.isNullOrBlank()) {&#10;                // Nếu chưa có tên → sang màn nhập&#10;                startActivity(Intent(this@SplashActivity, NameInputActivity::class.java))&#10;            } else {&#10;                // Nếu đã có tên → sang Main luôn&#10;                val intent = Intent(this@SplashActivity, MainActivity::class.java)&#10;                intent.putExtra(&quot;PLAYER_NAME&quot;, savedName)&#10;                startActivity(intent)&#10;            }&#10;            finish()&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.game&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.util.Log&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.animation.core.Animatable&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.scale&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.lifecycleScope&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;&#10;class SplashActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContent {&#10;            Box(&#10;                modifier = Modifier.fillMaxSize(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                // Ảnh nền&#10;                Image(&#10;                    painter = painterResource(id = R.drawable.nen1),&#10;                    contentDescription = null,&#10;                    modifier = Modifier.fillMaxSize()&#10;                )&#10;&#10;                // Animatable để scale mượt&#10;                val scale = remember { Animatable(0.8f) }&#10;&#10;                LaunchedEffect(Unit) {&#10;                    scale.animateTo(&#10;                        targetValue = 1.3f,&#10;                        animationSpec = tween(durationMillis = 1800)&#10;                    )&#10;                }&#10;&#10;                // Tên game&#10;                Text(&#10;                    text = &quot;My Game&quot;,&#10;                    color = Color.White,&#10;                    style = MaterialTheme.typography.headlineLarge.copy(&#10;                        fontSize = 50.sp,&#10;                        fontWeight = FontWeight.Bold&#10;                    ),&#10;                    modifier = Modifier.scale(scale.value)&#10;                )&#10;            }&#10;        }&#10;&#10;        lifecycleScope.launch {&#10;            delay(2500)&#10;&#10;            val savedName = PrefManager.getPlayerName(this@SplashActivity)&#10;            Log.d(&quot;SplashActivity&quot;, &quot;Saved name from SharedPreferences: $savedName&quot;)&#10;&#10;            if (savedName.isNullOrBlank()) {&#10;                // Nếu chưa có tên → sang màn nhập&#10;                Log.d(&quot;SplashActivity&quot;, &quot;No saved name, going to NameInputActivity&quot;)&#10;                startActivity(Intent(this@SplashActivity, NameInputActivity::class.java))&#10;            } else {&#10;                // Nếu đã có tên → sang Main luôn VỚI TÊN&#10;                Log.d(&quot;SplashActivity&quot;, &quot;Found saved name: $savedName, going to MainActivity&quot;)&#10;                val intent = Intent(this@SplashActivity, MainActivity::class.java)&#10;                intent.putExtra(&quot;PLAYER_NAME&quot;, savedName)&#10;                startActivity(intent)&#10;            }&#10;            finish()&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/game/core/GameOverlays.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/game/core/GameOverlays.kt" />
              <option name="originalContent" value="package com.example.game.core&#10;&#10;import android.content.Intent&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.fadeIn&#10;import androidx.compose.animation.fadeOut&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.window.Dialog&#10;import androidx.compose.ui.window.DialogProperties&#10;import com.example.game.GameScreenActivity&#10;import com.example.game.Level2Activity&#10;import com.example.game.Level3Activity&#10;import com.example.game.Level4Activity&#10;import com.example.game.Level5Activity&#10;import com.example.game.MainActivity&#10;import com.example.game.R&#10;import com.example.game.Top6Activity&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.roundToInt&#10;&#10;enum class OverlayType { WIN, GAME_OVER }&#10;&#10;@Composable&#10;fun GameOverlay(type: OverlayType, score: Int, onExit: () -&gt; Unit) {&#10;    val context = LocalContext.current&#10;    var visible by remember { mutableStateOf(false) }&#10;    LaunchedEffect(Unit) { visible = true }&#10;&#10;    AnimatedVisibility(visible, enter = fadeIn(), exit = fadeOut()) {&#10;        Box(&#10;            Modifier.fillMaxSize().background(Color(0xAA000000)),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                val img = if (type == OverlayType.WIN) R.drawable.win else R.drawable.game_over&#10;                Image(painterResource(img), null, Modifier.size(300.dp))&#10;                Spacer(Modifier.height(16.dp))&#10;                Text(&quot;Bạn thu thêm được $score xu&quot;, color = Color.Yellow, fontSize = 24.sp)&#10;                Spacer(Modifier.height(24.dp))&#10;                if (type == OverlayType.WIN) {&#10;                    Row(horizontalArrangement = Arrangement.spacedBy(16.dp)) {&#10;                        Button(onClick = { onExit() }) { Text(&quot;Thoát&quot;, fontSize = 20.sp) }&#10;                        Button(onClick = {&#10;                            val intent = Intent(context, Top6Activity::class.java)&#10;                            context.startActivity(intent)&#10;                        }) { Text(&quot;Top 6&quot;, fontSize = 20.sp) }&#10;                    }&#10;                } else Button(onClick = { onExit() }) { Text(&quot;Thoát&quot;, fontSize = 20.sp) }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * GameEndDialog - Reusable dialog for game end screen&#10; * Displays as an overlay without navigating to a new activity&#10; */&#10;@Composable&#10;fun GameEndDialog(&#10;    isWin: Boolean,&#10;    score: Int,&#10;    level: Int,&#10;    onDismiss: () -&gt; Unit,&#10;    onReplay: () -&gt; Unit,&#10;    onNextLevel: () -&gt; Unit,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;&#10;    Dialog(&#10;        onDismissRequest = { /* Prevent dismissing by clicking outside */ },&#10;        properties = DialogProperties(&#10;            dismissOnBackPress = false,&#10;            dismissOnClickOutside = false,&#10;            usePlatformDefaultWidth = false&#10;        )&#10;    ) {&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .background(Color(0xDD000000)),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            Column(&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.Center,&#10;                modifier = Modifier.padding(32.dp)&#10;            ) {&#10;                // Game End Image (Win or Game Over)&#10;                val imageRes = if (isWin) R.drawable.win else R.drawable.game_over&#10;                Image(&#10;                    painter = painterResource(imageRes),&#10;                    contentDescription = if (isWin) &quot;Win&quot; else &quot;Game Over&quot;,&#10;                    modifier = Modifier.size(300.dp)&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                // Level info&#10;                Text(&#10;                    text = &quot;Level $level&quot;,&#10;                    color = Color.White,&#10;                    fontSize = 28.sp&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                // Score info&#10;                Text(&#10;                    text = &quot;Bạn thu thêm được $score xu&quot;,&#10;                    color = Color.Yellow,&#10;                    fontSize = 24.sp&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(32.dp))&#10;&#10;                // Buttons&#10;                if (isWin) {&#10;                    // WIN buttons&#10;                    Column(&#10;                        horizontalAlignment = Alignment.CenterHorizontally,&#10;                        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                    ) {&#10;                        // Next Level button (if not last level)&#10;                        if (level &lt; 5) {&#10;                            Button(&#10;                                onClick = {&#10;                                    val nextLevelIntent = when (level) {&#10;                                        1 -&gt; Intent(context, Level2Activity::class.java)&#10;                                        2 -&gt; Intent(context, Level3Activity::class.java)&#10;                                        3 -&gt; Intent(context, Level4Activity::class.java)&#10;                                        4 -&gt; Intent(context, Level5Activity::class.java)&#10;                                        else -&gt; null&#10;                                    }&#10;                                    nextLevelIntent?.let {&#10;                                        it.flags = Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_NEW_TASK&#10;                                        context.startActivity(it)&#10;                                        onNextLevel()&#10;                                    }&#10;                                },&#10;                                modifier = Modifier.width(200.dp)&#10;                            ) {&#10;                                Text(&quot;Level tiếp theo&quot;, fontSize = 20.sp)&#10;                            }&#10;                        }&#10;&#10;                        // Replay button&#10;                        Button(&#10;                            onClick = onReplay,&#10;                            modifier = Modifier.width(200.dp)&#10;                        ) {&#10;                            Text(&quot;Chơi lại&quot;, fontSize = 20.sp)&#10;                        }&#10;&#10;                        // Top 6 button&#10;                        Button(&#10;                            onClick = {&#10;                                val intent = Intent(context, Top6Activity::class.java)&#10;                                context.startActivity(intent)&#10;                            },&#10;                            modifier = Modifier.width(200.dp)&#10;                        ) {&#10;                            Text(&quot;Top 6&quot;, fontSize = 20.sp)&#10;                        }&#10;&#10;                        // Exit button&#10;                        Button(&#10;                            onClick = onExit,&#10;                            modifier = Modifier.width(200.dp)&#10;                        ) {&#10;                            Text(&quot;Thoát&quot;, fontSize = 20.sp)&#10;                        }&#10;                    }&#10;                } else {&#10;                    // GAME OVER buttons&#10;                    Column(&#10;                        horizontalAlignment = Alignment.CenterHorizontally,&#10;                        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                    ) {&#10;                        // Replay button&#10;                        Button(&#10;                            onClick = onReplay,&#10;                            modifier = Modifier.width(200.dp)&#10;                        ) {&#10;                            Text(&quot;Chơi lại&quot;, fontSize = 20.sp)&#10;                        }&#10;&#10;                        // Exit button&#10;                        Button(&#10;                            onClick = onExit,&#10;                            modifier = Modifier.width(200.dp)&#10;                        ) {&#10;                            Text(&quot;Thoát&quot;, fontSize = 20.sp)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.game.core&#13;&#10;&#13;&#10;import android.content.Intent&#13;&#10;import androidx.compose.animation.AnimatedVisibility&#13;&#10;import androidx.compose.animation.fadeIn&#13;&#10;import androidx.compose.animation.fadeOut&#13;&#10;import androidx.compose.foundation.Image&#13;&#10;import androidx.compose.foundation.background&#13;&#10;import androidx.compose.foundation.layout.*&#13;&#10;import androidx.compose.material3.Button&#13;&#10;import androidx.compose.material3.Text&#13;&#10;import androidx.compose.runtime.*&#13;&#10;import androidx.compose.ui.Alignment&#13;&#10;import androidx.compose.ui.Modifier&#13;&#10;import androidx.compose.ui.graphics.Color&#13;&#10;import androidx.compose.ui.graphics.graphicsLayer&#13;&#10;import androidx.compose.ui.platform.LocalContext&#13;&#10;import androidx.compose.ui.res.painterResource&#13;&#10;import androidx.compose.ui.unit.IntOffset&#13;&#10;import androidx.compose.ui.unit.dp&#13;&#10;import androidx.compose.ui.unit.sp&#13;&#10;import androidx.compose.ui.window.Dialog&#13;&#10;import androidx.compose.ui.window.DialogProperties&#13;&#10;import com.example.game.GameScreenActivity&#13;&#10;import com.example.game.Level2Activity&#13;&#10;import com.example.game.Level3Activity&#13;&#10;import com.example.game.Level4Activity&#13;&#10;import com.example.game.Level5Activity&#13;&#10;import com.example.game.MainActivity&#13;&#10;import com.example.game.R&#13;&#10;import com.example.game.Top6Activity&#13;&#10;import kotlinx.coroutines.delay&#13;&#10;import kotlin.math.roundToInt&#13;&#10;&#13;&#10;enum class OverlayType { WIN, GAME_OVER }&#13;&#10;&#13;&#10;@Composable&#13;&#10;fun GameOverlay(type: OverlayType, score: Int, onExit: () -&gt; Unit) {&#13;&#10;    val context = LocalContext.current&#13;&#10;    var visible by remember { mutableStateOf(false) }&#13;&#10;    LaunchedEffect(Unit) { visible = true }&#13;&#10;&#13;&#10;    AnimatedVisibility(visible, enter = fadeIn(), exit = fadeOut()) {&#13;&#10;        Box(&#13;&#10;            Modifier.fillMaxSize().background(Color(0xAA000000)),&#13;&#10;            contentAlignment = Alignment.Center&#13;&#10;        ) {&#13;&#10;            Column(horizontalAlignment = Alignment.CenterHorizontally) {&#13;&#10;                val img = if (type == OverlayType.WIN) R.drawable.win else R.drawable.game_over&#13;&#10;                Image(painterResource(img), null, Modifier.size(300.dp))&#13;&#10;                Spacer(Modifier.height(16.dp))&#13;&#10;                Text(&quot;Bạn thu thêm được $score xu&quot;, color = Color.Yellow, fontSize = 24.sp)&#13;&#10;                Spacer(Modifier.height(24.dp))&#13;&#10;                if (type == OverlayType.WIN) {&#13;&#10;                    Row(horizontalArrangement = Arrangement.spacedBy(16.dp)) {&#13;&#10;                        Button(onClick = { onExit() }) { Text(&quot;Thoát&quot;, fontSize = 20.sp) }&#13;&#10;                        Button(onClick = {&#13;&#10;                            val intent = Intent(context, Top6Activity::class.java)&#13;&#10;                            context.startActivity(intent)&#13;&#10;                        }) { Text(&quot;Top 6&quot;, fontSize = 20.sp) }&#13;&#10;                    }&#13;&#10;                } else Button(onClick = { onExit() }) { Text(&quot;Thoát&quot;, fontSize = 20.sp) }&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;/**&#13;&#10; * GameEndDialog - Reusable dialog for game end screen&#13;&#10; * Displays as an overlay without navigating to a new activity&#13;&#10; */&#13;&#10;@Composable&#13;&#10;fun GameEndDialog(&#13;&#10;    isWin: Boolean,&#13;&#10;    score: Int,&#13;&#10;    level: Int,&#13;&#10;    onDismiss: () -&gt; Unit,&#13;&#10;    onReplay: () -&gt; Unit,&#13;&#10;    onNextLevel: () -&gt; Unit,&#13;&#10;    onExit: () -&gt; Unit,&#13;&#10;    playerName: String? = null,&#13;&#10;    totalScore: Int = 0&#13;&#10;) {&#13;&#10;    val context = LocalContext.current&#13;&#10;&#13;&#10;    // LƯU ĐIỂM CUỐI TRẬN vào Firebase (chỉ một lần khi dialog hiển thị)&#13;&#10;    LaunchedEffect(Unit) {&#13;&#10;        if (!playerName.isNullOrBlank() &amp;&amp; totalScore &gt; 0) {&#13;&#10;            com.example.game.FirebaseHelper.saveMatchScore(playerName, totalScore)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    Dialog(&#13;&#10;        onDismissRequest = { /* Prevent dismissing by clicking outside */ },&#13;&#10;        properties = DialogProperties(&#13;&#10;            dismissOnBackPress = false,&#13;&#10;            dismissOnClickOutside = false,&#13;&#10;            usePlatformDefaultWidth = false&#13;&#10;        )&#13;&#10;    ) {&#13;&#10;        Box(&#13;&#10;            modifier = Modifier&#13;&#10;                .fillMaxSize()&#13;&#10;                .background(Color(0xDD000000)),&#13;&#10;            contentAlignment = Alignment.Center&#13;&#10;        ) {&#13;&#10;            Column(&#13;&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#13;&#10;                verticalArrangement = Arrangement.Center,&#13;&#10;                modifier = Modifier.padding(32.dp)&#13;&#10;            ) {&#13;&#10;                // Game End Image (Win or Game Over)&#13;&#10;                val imageRes = if (isWin) R.drawable.win else R.drawable.game_over&#13;&#10;                Image(&#13;&#10;                    painter = painterResource(imageRes),&#13;&#10;                    contentDescription = if (isWin) &quot;Win&quot; else &quot;Game Over&quot;,&#13;&#10;                    modifier = Modifier.size(300.dp)&#13;&#10;                )&#13;&#10;&#13;&#10;                Spacer(modifier = Modifier.height(16.dp))&#13;&#10;&#13;&#10;                // Level info&#13;&#10;                Text(&#13;&#10;                    text = &quot;Level $level&quot;,&#13;&#10;                    color = Color.White,&#13;&#10;                    fontSize = 28.sp&#13;&#10;                )&#13;&#10;&#13;&#10;                Spacer(modifier = Modifier.height(8.dp))&#13;&#10;&#13;&#10;                // Score info&#13;&#10;                Text(&#13;&#10;                    text = &quot;Bạn thu thêm được $score xu&quot;,&#13;&#10;                    color = Color.Yellow,&#13;&#10;                    fontSize = 24.sp&#13;&#10;                )&#13;&#10;&#13;&#10;                Spacer(modifier = Modifier.height(32.dp))&#13;&#10;&#13;&#10;                // Buttons&#13;&#10;                if (isWin) {&#13;&#10;                    // WIN buttons&#13;&#10;                    Column(&#13;&#10;                        horizontalAlignment = Alignment.CenterHorizontally,&#13;&#10;                        verticalArrangement = Arrangement.spacedBy(12.dp)&#13;&#10;                    ) {&#13;&#10;                        // Next Level button (if not last level)&#13;&#10;                        if (level &lt; 5) {&#13;&#10;                            Button(&#13;&#10;                                onClick = {&#13;&#10;                                    val nextLevelIntent = when (level) {&#13;&#10;                                        1 -&gt; Intent(context, Level2Activity::class.java)&#13;&#10;                                        2 -&gt; Intent(context, Level3Activity::class.java)&#13;&#10;                                        3 -&gt; Intent(context, Level4Activity::class.java)&#13;&#10;                                        4 -&gt; Intent(context, Level5Activity::class.java)&#13;&#10;                                        else -&gt; null&#13;&#10;                                    }&#13;&#10;                                    nextLevelIntent?.let {&#13;&#10;                                        it.flags = Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_NEW_TASK&#13;&#10;                                        context.startActivity(it)&#13;&#10;                                        onNextLevel()&#13;&#10;                                    }&#13;&#10;                                },&#13;&#10;                                modifier = Modifier.width(200.dp)&#13;&#10;                            ) {&#13;&#10;                                Text(&quot;Level tiếp theo&quot;, fontSize = 20.sp)&#13;&#10;                            }&#13;&#10;                        }&#13;&#10;&#13;&#10;                        // Replay button&#13;&#10;                        Button(&#13;&#10;                            onClick = onReplay,&#13;&#10;                            modifier = Modifier.width(200.dp)&#13;&#10;                        ) {&#13;&#10;                            Text(&quot;Chơi lại&quot;, fontSize = 20.sp)&#13;&#10;                        }&#13;&#10;&#13;&#10;                        // Top 6 button&#13;&#10;                        Button(&#13;&#10;                            onClick = {&#13;&#10;                                val intent = Intent(context, Top6Activity::class.java)&#13;&#10;                                context.startActivity(intent)&#13;&#10;                            },&#13;&#10;                            modifier = Modifier.width(200.dp)&#13;&#10;                        ) {&#13;&#10;                            Text(&quot;Top 6&quot;, fontSize = 20.sp)&#13;&#10;                        }&#13;&#10;&#13;&#10;                        // Exit button&#13;&#10;                        Button(&#13;&#10;                            onClick = onExit,&#13;&#10;                            modifier = Modifier.width(200.dp)&#13;&#10;                        ) {&#13;&#10;                            Text(&quot;Thoát&quot;, fontSize = 20.sp)&#13;&#10;                        }&#13;&#10;                    }&#13;&#10;                } else {&#13;&#10;                    // GAME OVER buttons&#13;&#10;                    Column(&#13;&#10;                        horizontalAlignment = Alignment.CenterHorizontally,&#13;&#10;                        verticalArrangement = Arrangement.spacedBy(12.dp)&#13;&#10;                    ) {&#13;&#10;                        // Replay button&#13;&#10;                        Button(&#13;&#10;                            onClick = onReplay,&#13;&#10;                            modifier = Modifier.width(200.dp)&#13;&#10;                        ) {&#13;&#10;                            Text(&quot;Chơi lại&quot;, fontSize = 20.sp)&#13;&#10;                        }&#13;&#10;&#13;&#10;                        // Exit button&#13;&#10;                        Button(&#13;&#10;                            onClick = onExit,&#13;&#10;                            modifier = Modifier.width(200.dp)&#13;&#10;                        ) {&#13;&#10;                            Text(&quot;Thoát&quot;, fontSize = 20.sp)&#13;&#10;                        }&#13;&#10;                    }&#13;&#10;                }&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/game/GameScreenActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/game/GameScreenActivity.kt" />
              <option name="originalContent" value="package com.example.game&#10;&#10;import android.os.Bundle&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.TopBarComponent.TopBarUI&#10;import com.example.game.core.*&#10;import com.example.game.ui.PlaneUI&#10;import com.example.game.ui.MonsterUI&#10;import com.example.game.ui.WallUI&#10;import com.example.game.ui.SoundControlButton&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.roundToInt&#10;import kotlin.random.Random&#10;&#10;class GameScreenActivity : BaseGameActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        initAudio()&#10;&#10;        setContent {&#10;            val density = LocalDensity.current&#10;            val screenWidthPx = with(density) { LocalConfiguration.current.screenWidthDp.dp.toPx() }&#10;            val screenHeightPx = with(density) { LocalConfiguration.current.screenHeightDp.dp.toPx() }&#10;&#10;            GameScreen(&#10;                screenWidthPx = screenWidthPx,&#10;                screenHeightPx = screenHeightPx,&#10;                soundPool = soundPool,&#10;                shootSoundId = shootSoundId,&#10;                onExit = { finish() }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun GameScreen(&#10;    screenWidthPx: Float,&#10;    screenHeightPx: Float,&#10;    soundPool: android.media.SoundPool,&#10;    shootSoundId: Int,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val playerName = PrefManager.getPlayerName(context)&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // --- State ---&#10;    var totalScore by remember { mutableStateOf(0) }&#10;    var currentSessionScore by remember { mutableStateOf(0) }&#10;    var planeHp by remember { mutableStateOf(100) } // 0..100&#10;&#10;    var shieldActive by remember { mutableStateOf(false) }&#10;    var wallActive by remember { mutableStateOf(false) }&#10;    var timeActive by remember { mutableStateOf(false) }&#10;&#10;    var isGameOver by remember { mutableStateOf(false) }&#10;    var isLevelClear by remember { mutableStateOf(false) }&#10;    var showGameEndDialog by remember { mutableStateOf(false) }&#10;&#10;    // Show dialog when game ends instead of navigating to new activity&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        if (isGameOver || isLevelClear) {&#10;            delay(500)&#10;            showGameEndDialog = true&#10;        }&#10;    }&#10;&#10;    // --- Plane ---&#10;    var planeX by remember { mutableStateOf(screenWidthPx / 2 - 50f) }&#10;    val planeY = screenHeightPx - 250f&#10;    val planeWidth = 100f&#10;    val planeHeight = 100f&#10;&#10;    // --- Background (2 images loop) ---&#10;    var bg1Y by remember { mutableStateOf(0f) }&#10;    var bg2Y by remember { mutableStateOf(-screenHeightPx) }&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bg1Y += 4f&#10;            bg2Y += 4f&#10;&#10;            // Fix: When an image scrolls completely off screen, place it right above the other one&#10;            if (bg1Y &gt;= screenHeightPx) {&#10;                bg1Y = bg2Y - screenHeightPx&#10;            }&#10;            if (bg2Y &gt;= screenHeightPx) {&#10;                bg2Y = bg1Y - screenHeightPx&#10;            }&#10;&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Entities ---&#10;    val monsters = remember {&#10;        List(10) {&#10;            BaseMonster(&#10;                x = Random.nextFloat() * (screenWidthPx - 100f),&#10;                // Spawn monsters at different Y positions (more spread out)&#10;                y = mutableStateOf(-Random.nextInt(200, 2000).toFloat()), // Increased range&#10;                speed = Random.nextFloat() * 1.5f + 1.5f,&#10;                hp = mutableStateOf(100)&#10;            )&#10;        }&#10;    }&#10;&#10;    // Track respawn times for each monster&#10;    val monsterRespawnTimes = remember { MutableList(monsters.size) { 0L } }&#10;&#10;    val coins = remember {&#10;        List(6) {&#10;            BaseCoin(&#10;                x = Random.nextFloat() * (screenWidthPx - 50f),&#10;                y = mutableStateOf(-Random.nextInt(100, 600).toFloat()),&#10;                speed = Random.nextFloat() * 2f + 1f&#10;            )&#10;        }&#10;    }&#10;&#10;    val bullets = remember { mutableStateListOf&lt;Bullet&gt;() }&#10;    val bagCoins = remember { mutableStateListOf&lt;BagCoinDisplay&gt;() } // uses core.BagCoinDisplay&#10;    var chestItems by remember { mutableStateOf&lt;List&lt;ChestItem&gt;&gt;(emptyList()) }&#10;&#10;    // --- Load player data (score / chest) ---&#10;    LaunchedEffect(Unit) {&#10;        if (!playerName.isNullOrBlank()) {&#10;            FirebaseHelper.syncNewPlayer(playerName)&#10;            FirebaseHelper.getScore(playerName) { totalScore = it }&#10;            FirebaseHelper.getChestItems(playerName) { chestItems = it }&#10;        }&#10;    }&#10;&#10;    // --- Shooting ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.add(Bullet(planeX + planeWidth / 2f - 15f, planeY))&#10;            soundPool.play(shootSoundId, 0.5f, 0.5f, 1, 0, 1f)&#10;            delay(350)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.forEach { it.y -= 20f }&#10;            bullets.removeAll { it.y &lt; -40f }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Monster movement ---&#10;    monsters.forEachIndexed { index, m -&gt;&#10;        LaunchedEffect(m, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                // Check if monster needs to respawn after death&#10;                if (!m.alive.value &amp;&amp; System.currentTimeMillis() &gt;= monsterRespawnTimes[index]) {&#10;                    // Respawn the monster at a random position&#10;                    m.y.value = -Random.nextInt(200, 1500).toFloat()&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 100f)&#10;                    m.hp.value = 100&#10;                    m.alive.value = true&#10;                }&#10;&#10;                if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp; !timeActive) {&#10;                    // Wall is at planeY - 60f, so stop monsters closer to actually touch it&#10;                    val wallTop = planeY - 60f&#10;                    val monsterBottom = m.y.value + 80f // Monster height is 80px&#10;&#10;                    if (wallActive &amp;&amp; monsterBottom &gt;= wallTop) {&#10;                        // Monster has reached wall - STOP here&#10;                        // Wall collision check will drain HP&#10;                    } else {&#10;                        // Normal movement&#10;                        m.y.value += m.speed&#10;                    }&#10;&#10;                    // If monster falls below plane (passed), damage plane and respawn&#10;                    if (m.y.value &gt; planeY + planeHeight / 2f) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) planeHp -= 50&#10;                        // Schedule respawn with random delay (3-8 seconds)&#10;                        monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 8000)&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;                delay(16)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Coin movement ---&#10;    coins.forEach { c -&gt;&#10;        LaunchedEffect(c, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                if (!c.collected.value &amp;&amp; !timeActive) {&#10;                    c.y.value += c.speed&#10;                    if (c.y.value &gt; screenHeightPx) {&#10;                        c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                        c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                    }&#10;                }&#10;                delay(32)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Bullet vs Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            val iter = bullets.iterator()&#10;            while (iter.hasNext()) {&#10;                val b = iter.next()&#10;                monsters.forEach { m -&gt;&#10;                    if (CollisionUtils.checkCollisionBulletMonster(b, m)) {&#10;                        // hit: reduce monster HP&#10;                        m.hp.value -= 25&#10;                        iter.remove()&#10;                        if (m.hp.value &lt;= 0) {&#10;                            m.alive.value = false&#10;                            // Schedule respawn with random delay (3-8 seconds)&#10;                            val index = monsters.indexOf(m)&#10;                            if (index &gt;= 0) {&#10;                                monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 8000)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            // DON'T check for level clear here - let monsters respawn naturally&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Coin collision (collect coin) ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            coins.forEach { c -&gt;&#10;                if (!c.collected.value &amp;&amp; CollisionUtils.checkCollisionPlaneCoin(planeX, planeY, planeWidth, planeHeight, c)) {&#10;                    c.collected.value = true&#10;                    totalScore += 1&#10;                    currentSessionScore += 1&#10;                    // add bag coin display (will be animated in UI)&#10;                    val bag = BagCoinDisplay(c.x, c.y.value, 1)&#10;                    bagCoins.add(bag)&#10;                    // update backend&#10;                    if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Monster collision (direct hit) ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            monsters.forEach { m -&gt;&#10;                if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp;&#10;                    CollisionUtils.checkCollisionPlaneMonster(planeX, planeY, planeWidth, planeHeight, m)&#10;                ) {&#10;                    if (!shieldActive &amp;&amp; !wallActive) planeHp -= 50&#10;                    // kill this monster&#10;                    m.hp.value = 0&#10;                    m.alive.value = false&#10;                }&#10;            }&#10;            if (planeHp &lt;= 0) isGameOver = true&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Wall - Monster collision (wall damages monsters) ---&#10;    LaunchedEffect(wallActive, isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            if (wallActive) {&#10;                monsters.forEach { m -&gt;&#10;                    if (m.alive.value &amp;&amp; m.hp.value &gt; 0) {&#10;                        val isColliding = CollisionUtils.checkCollisionWallMonster(planeY, m)&#10;                        if (isColliding) {&#10;                            // Wall drains monster HP continuously&#10;                            m.hp.value -= 2 // Drain 2 HP per tick&#10;                            if (m.hp.value &lt;= 0) {&#10;                                m.alive.value = false&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(50) // Check every 50ms&#10;        }&#10;    }&#10;&#10;    // --- Use chest item wrapper ---&#10;    fun useChestItem(item: ChestItem) {&#10;        ChestItemEffectsBase.applyItemEffect(&#10;            itemName = item.name,&#10;            monsters = monsters,&#10;            coins = coins,&#10;            bagCoins = bagCoins,&#10;            coroutineScope = coroutineScope,&#10;            screenHeightPx = screenHeightPx,&#10;            planeX = planeX,&#10;            onScoreUpdate = { add -&gt;&#10;                totalScore += add&#10;                currentSessionScore += add&#10;                if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;            },&#10;            onShieldToggle = { active -&gt; shieldActive = active },&#10;            onWallToggle = { active -&gt; wallActive = active },&#10;            onTimeToggle = { active -&gt; timeActive = active },&#10;            onLevelClear = { isLevelClear = true }&#10;        )&#10;        chestItems = chestItems - item&#10;        if (!playerName.isNullOrBlank()) FirebaseHelper.updateChest(playerName, chestItems)&#10;    }&#10;&#10;    // --- Drag plane ---&#10;    val dragModifier = Modifier.pointerInput(Unit) {&#10;        detectDragGestures { change, dragAmount -&gt;&#10;            planeX = (planeX + dragAmount.x).coerceIn(0f, screenWidthPx - planeWidth)&#10;            change.consume()&#10;        }&#10;    }&#10;&#10;    // --- UI ---&#10;    Box(modifier = Modifier.fillMaxSize().then(dragModifier)) {&#10;        // background layers (sliding)&#10;        Image(&#10;            painter = painterResource(R.drawable.nen2),&#10;            contentDescription = null,&#10;            modifier = Modifier&#10;                .absoluteOffset { IntOffset(0, bg1Y.roundToInt()) }&#10;                .fillMaxSize()&#10;        )&#10;        Image(&#10;            painter = painterResource(R.drawable.nen2),&#10;            contentDescription = null,&#10;            modifier = Modifier&#10;                .absoluteOffset { IntOffset(0, bg2Y.roundToInt()) }&#10;                .fillMaxSize()&#10;        )&#10;&#10;        // --- Monsters (using MonsterUI component) ---&#10;        monsters.forEach { m -&gt;&#10;            MonsterUI(monster = m)&#10;        }&#10;&#10;        // --- Coins ---&#10;        coins.filter { !it.collected.value }.forEach { c -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.coin),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(c.x.roundToInt(), c.y.value.roundToInt()) }&#10;                    .size(40.dp)&#10;            )&#10;        }&#10;&#10;        // --- BagCoin animated views (spawned when coin collected) ---&#10;        bagCoins.toList().forEach { bag -&gt;&#10;            BagCoinAnimatedView(bag = bag, onFinished = { finishedBag -&gt;&#10;                bagCoins.remove(finishedBag)&#10;            })&#10;        }&#10;&#10;        // --- Bullets ---&#10;        bullets.forEach { b -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.dan2),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(b.x.roundToInt(), b.y.roundToInt()) }&#10;                    .size(30.dp)&#10;            )&#10;        }&#10;&#10;        // --- Plane (using PlaneUI component) ---&#10;        PlaneUI(&#10;            planeX = planeX,&#10;            planeY = planeY,&#10;            planeHp = planeHp,&#10;            shieldActive = shieldActive&#10;        )&#10;&#10;        // --- Wall effect (using WallUI component) ---&#10;        if (wallActive) {&#10;            WallUI(planeY = planeY)&#10;        }&#10;&#10;        // --- Top bar with chest items and score ---&#10;        TopBarUI(&#10;            bagCoinScore = totalScore,&#10;            chestItems = chestItems,&#10;            onBuyItem = { item, price -&gt;&#10;                if (totalScore &gt;= price) {&#10;                    totalScore -= price&#10;                    chestItems = chestItems + item&#10;                    if (!playerName.isNullOrBlank()) {&#10;                        FirebaseHelper.updateScore(playerName, totalScore)&#10;                        FirebaseHelper.updateChest(playerName, chestItems)&#10;                    }&#10;                }&#10;            },&#10;            onUseChestItem = { useChestItem(it) }&#10;        )&#10;&#10;        // --- Sound Control Button (top-right corner) ---&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp),&#10;            contentAlignment = Alignment.TopEnd&#10;        ) {&#10;            SoundControlButton()&#10;        }&#10;    }&#10;&#10;    // --- Game End Dialog ---&#10;    if (showGameEndDialog) {&#10;        GameEndDialog(&#10;            isWin = isLevelClear,&#10;            score = currentSessionScore,&#10;            level = 1,&#10;            onDismiss = {&#10;                showGameEndDialog = false&#10;            },&#10;            onReplay = {&#10;                // Reset game state to replay&#10;                showGameEndDialog = false&#10;                isGameOver = false&#10;                isLevelClear = false&#10;                planeHp = 100&#10;                currentSessionScore = 0&#10;&#10;                // Reset monsters&#10;                monsters.forEachIndexed { index, m -&gt;&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 100f)&#10;                    m.y.value = -Random.nextInt(200, 2000).toFloat()&#10;                    m.hp.value = 100&#10;                    m.alive.value = true&#10;                    monsterRespawnTimes[index] = 0L&#10;                }&#10;&#10;                // Reset coins&#10;                coins.forEach { c -&gt;&#10;                    c.collected.value = false&#10;                    c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                    c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                }&#10;&#10;                // Clear bullets&#10;                bullets.clear()&#10;            },&#10;            onNextLevel = {&#10;                // Navigate to next level handled by GameEndDialog itself&#10;                onExit() // Close this activity&#10;            },&#10;            onExit = {&#10;                // Back to main menu&#10;                onExit()&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * BagCoinAnimatedView&#10; * - Animates a bag coin sprite moving slightly up and fading out.&#10; * - Calls onFinished(bag) when animation done so caller can remove it.&#10; */&#10;@Composable&#10;private fun BagCoinAnimatedView(bag: BagCoinDisplay, onFinished: (BagCoinDisplay) -&gt; Unit) {&#10;    // local state for animation&#10;    var offsetY by remember { mutableStateOf(bag.y) }&#10;    var alpha by remember { mutableStateOf(1f) }&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // animate once when composition enters&#10;    LaunchedEffect(bag) {&#10;        val duration = 800L&#10;        val steps = 40&#10;        repeat(steps) { i -&gt;&#10;            offsetY -= 2f // move up total ~80 px over duration&#10;            alpha = 1f - (i / steps.toFloat())&#10;            delay(duration / steps)&#10;        }&#10;        // finished -&gt; notify parent to remove&#10;        onFinished(bag)&#10;    }&#10;&#10;    // Render image with graphicsLayer alpha&#10;    Image(&#10;        painter = painterResource(R.drawable.bagcoin),&#10;        contentDescription = null,&#10;        modifier = Modifier&#10;            .absoluteOffset { IntOffset(bag.x.roundToInt(), offsetY.roundToInt()) }&#10;            .size(60.dp)&#10;            .graphicsLayer { this.alpha = alpha }&#10;    )&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.game&#10;&#10;import android.os.Bundle&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.TopBarComponent.TopBarUI&#10;import com.example.game.core.*&#10;import com.example.game.ui.PlaneUI&#10;import com.example.game.ui.MonsterUI&#10;import com.example.game.ui.WallUI&#10;import com.example.game.ui.SoundControlButton&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.roundToInt&#10;import kotlin.random.Random&#10;&#10;class GameScreenActivity : BaseGameActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        initAudio()&#10;&#10;        setContent {&#10;            val density = LocalDensity.current&#10;            val screenWidthPx = with(density) { LocalConfiguration.current.screenWidthDp.dp.toPx() }&#10;            val screenHeightPx = with(density) { LocalConfiguration.current.screenHeightDp.dp.toPx() }&#10;&#10;            GameScreen(&#10;                screenWidthPx = screenWidthPx,&#10;                screenHeightPx = screenHeightPx,&#10;                soundPool = soundPool,&#10;                shootSoundId = shootSoundId,&#10;                hitSoundId = hitSoundId,&#10;                onExit = { finish() }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun GameScreen(&#10;    screenWidthPx: Float,&#10;    screenHeightPx: Float,&#10;    soundPool: android.media.SoundPool,&#10;    shootSoundId: Int,&#10;    hitSoundId: Int,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val playerName = PrefManager.getPlayerName(context)&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // --- State ---&#10;    var totalScore by remember { mutableStateOf(0) }&#10;    var currentSessionScore by remember { mutableStateOf(0) }&#10;    var planeHp by remember { mutableStateOf(100) } // 0..100&#10;&#10;    var shieldActive by remember { mutableStateOf(false) }&#10;    var wallActive by remember { mutableStateOf(false) }&#10;    var timeActive by remember { mutableStateOf(false) }&#10;&#10;    var isGameOver by remember { mutableStateOf(false) }&#10;    var isLevelClear by remember { mutableStateOf(false) }&#10;    var showGameEndDialog by remember { mutableStateOf(false) }&#10;&#10;    // Show dialog when game ends instead of navigating to new activity&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        if (isGameOver || isLevelClear) {&#10;            delay(500)&#10;            showGameEndDialog = true&#10;        }&#10;    }&#10;&#10;    // --- Plane ---&#10;    var planeX by remember { mutableStateOf(screenWidthPx / 2 - 50f) }&#10;    val planeY = screenHeightPx - 250f&#10;    val planeWidth = 100f&#10;    val planeHeight = 100f&#10;&#10;    // --- Background (2 images loop) ---&#10;    var bg1Y by remember { mutableStateOf(0f) }&#10;    var bg2Y by remember { mutableStateOf(-screenHeightPx) }&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bg1Y += 4f&#10;            bg2Y += 4f&#10;&#10;            // Fix: When an image scrolls completely off screen, place it right above the other one&#10;            if (bg1Y &gt;= screenHeightPx) {&#10;                bg1Y = bg2Y - screenHeightPx&#10;            }&#10;            if (bg2Y &gt;= screenHeightPx) {&#10;                bg2Y = bg1Y - screenHeightPx&#10;            }&#10;&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Entities ---&#10;    val monsters = remember {&#10;        List(10) {&#10;            BaseMonster(&#10;                x = Random.nextFloat() * (screenWidthPx - 100f),&#10;                // Spawn monsters at different Y positions (more spread out)&#10;                y = mutableStateOf(-Random.nextInt(200, 2000).toFloat()), // Increased range&#10;                speed = Random.nextFloat() * 1.5f + 1.5f,&#10;                hp = mutableStateOf(100)&#10;            )&#10;        }&#10;    }&#10;&#10;    // Track respawn times for each monster&#10;    val monsterRespawnTimes = remember { MutableList(monsters.size) { 0L } }&#10;&#10;    val coins = remember {&#10;        List(6) {&#10;            BaseCoin(&#10;                x = Random.nextFloat() * (screenWidthPx - 50f),&#10;                y = mutableStateOf(-Random.nextInt(100, 600).toFloat()),&#10;                speed = Random.nextFloat() * 2f + 1f&#10;            )&#10;        }&#10;    }&#10;&#10;    val bullets = remember { mutableStateListOf&lt;Bullet&gt;() }&#10;    val bagCoins = remember { mutableStateListOf&lt;BagCoinDisplay&gt;() } // uses core.BagCoinDisplay&#10;    var chestItems by remember { mutableStateOf&lt;List&lt;ChestItem&gt;&gt;(emptyList()) }&#10;&#10;    // --- Load player data (score / chest) ---&#10;    LaunchedEffect(Unit) {&#10;        if (!playerName.isNullOrBlank()) {&#10;            FirebaseHelper.syncNewPlayer(playerName)&#10;            FirebaseHelper.getScore(playerName) { totalScore = it }&#10;            FirebaseHelper.getChestItems(playerName) { chestItems = it }&#10;        }&#10;    }&#10;&#10;    // --- Shooting ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.add(Bullet(planeX + planeWidth / 2f - 15f, planeY))&#10;            SoundManager.playSoundEffect(soundPool, shootSoundId, 0.5f)&#10;            delay(350)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.forEach { it.y -= 20f }&#10;            bullets.removeAll { it.y &lt; -40f }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Monster movement ---&#10;    monsters.forEachIndexed { index, m -&gt;&#10;        LaunchedEffect(m, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                // Check if monster needs to respawn after death&#10;                if (!m.alive.value &amp;&amp; System.currentTimeMillis() &gt;= monsterRespawnTimes[index]) {&#10;                    // Respawn the monster at a random position&#10;                    m.y.value = -Random.nextInt(200, 1500).toFloat()&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 100f)&#10;                    m.hp.value = 100&#10;                    m.alive.value = true&#10;                }&#10;&#10;                if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp; !timeActive) {&#10;                    // Wall is at planeY - 60f, so stop monsters closer to actually touch it&#10;                    val wallTop = planeY - 60f&#10;                    val monsterBottom = m.y.value + 80f // Monster height is 80px&#10;&#10;                    if (wallActive &amp;&amp; monsterBottom &gt;= wallTop) {&#10;                        // Monster has reached wall - STOP here&#10;                        // Wall collision check will drain HP&#10;                    } else {&#10;                        // Normal movement&#10;                        m.y.value += m.speed&#10;                    }&#10;&#10;                    // If monster falls below plane (passed), damage plane and respawn&#10;                    if (m.y.value &gt; planeY + planeHeight / 2f) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) planeHp -= 50&#10;                        // Schedule respawn with random delay (3-8 seconds)&#10;                        monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 8000)&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;                delay(16)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Coin movement ---&#10;    coins.forEach { c -&gt;&#10;        LaunchedEffect(c, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                if (!c.collected.value &amp;&amp; !timeActive) {&#10;                    c.y.value += c.speed&#10;                    if (c.y.value &gt; screenHeightPx) {&#10;                        c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                        c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                    }&#10;                }&#10;                delay(32)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Bullet vs Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            val iter = bullets.iterator()&#10;            while (iter.hasNext()) {&#10;                val b = iter.next()&#10;                monsters.forEach { m -&gt;&#10;                    if (CollisionUtils.checkCollisionBulletMonster(b, m)) {&#10;                        // hit: reduce monster HP&#10;                        m.hp.value -= 25&#10;                        // Play hit sound&#10;                        SoundManager.playSoundEffect(soundPool, hitSoundId, 0.3f)&#10;                        iter.remove()&#10;                        if (m.hp.value &lt;= 0) {&#10;                            m.alive.value = false&#10;                            // Schedule respawn with random delay (3-8 seconds)&#10;                            val index = monsters.indexOf(m)&#10;                            if (index &gt;= 0) {&#10;                                monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 8000)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            // DON'T check for level clear here - let monsters respawn naturally&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Coin collision (collect coin) ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            coins.forEach { c -&gt;&#10;                if (!c.collected.value &amp;&amp; CollisionUtils.checkCollisionPlaneCoin(planeX, planeY, planeWidth, planeHeight, c)) {&#10;                    c.collected.value = true&#10;                    totalScore += 1&#10;                    currentSessionScore += 1&#10;                    // add bag coin display (will be animated in UI)&#10;                    val bag = BagCoinDisplay(c.x, c.y.value, 1)&#10;                    bagCoins.add(bag)&#10;                    // update backend&#10;                    if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Monster collision (direct hit) ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            monsters.forEach { m -&gt;&#10;                if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp;&#10;                    CollisionUtils.checkCollisionPlaneMonster(planeX, planeY, planeWidth, planeHeight, m)&#10;                ) {&#10;                    if (!shieldActive &amp;&amp; !wallActive) planeHp -= 50&#10;                    // kill this monster&#10;                    m.hp.value = 0&#10;                    m.alive.value = false&#10;                }&#10;            }&#10;            if (planeHp &lt;= 0) isGameOver = true&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Wall - Monster collision (wall damages monsters) ---&#10;    LaunchedEffect(wallActive, isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            if (wallActive) {&#10;                monsters.forEach { m -&gt;&#10;                    if (m.alive.value &amp;&amp; m.hp.value &gt; 0) {&#10;                        val isColliding = CollisionUtils.checkCollisionWallMonster(planeY, m)&#10;                        if (isColliding) {&#10;                            // Wall drains monster HP continuously&#10;                            m.hp.value -= 2 // Drain 2 HP per tick&#10;                            if (m.hp.value &lt;= 0) {&#10;                                m.alive.value = false&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(50) // Check every 50ms&#10;        }&#10;    }&#10;&#10;    // --- Use chest item wrapper ---&#10;    fun useChestItem(item: ChestItem) {&#10;        ChestItemEffectsBase.applyItemEffect(&#10;            itemName = item.name,&#10;            monsters = monsters,&#10;            coins = coins,&#10;            bagCoins = bagCoins,&#10;            coroutineScope = coroutineScope,&#10;            screenHeightPx = screenHeightPx,&#10;            planeX = planeX,&#10;            onScoreUpdate = { add -&gt;&#10;                totalScore += add&#10;                currentSessionScore += add&#10;                if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;            },&#10;            onShieldToggle = { active -&gt; shieldActive = active },&#10;            onWallToggle = { active -&gt; wallActive = active },&#10;            onTimeToggle = { active -&gt; timeActive = active },&#10;            onLevelClear = { isLevelClear = true }&#10;        )&#10;        chestItems = chestItems - item&#10;        if (!playerName.isNullOrBlank()) FirebaseHelper.updateChest(playerName, chestItems)&#10;    }&#10;&#10;    // --- Drag plane ---&#10;    val dragModifier = Modifier.pointerInput(Unit) {&#10;        detectDragGestures { change, dragAmount -&gt;&#10;            planeX = (planeX + dragAmount.x).coerceIn(0f, screenWidthPx - planeWidth)&#10;            change.consume()&#10;        }&#10;    }&#10;&#10;    // --- UI ---&#10;    Box(modifier = Modifier.fillMaxSize().then(dragModifier)) {&#10;        // background layers (sliding)&#10;        Image(&#10;            painter = painterResource(R.drawable.nen2),&#10;            contentDescription = null,&#10;            modifier = Modifier&#10;                .absoluteOffset { IntOffset(0, bg1Y.roundToInt()) }&#10;                .fillMaxSize()&#10;        )&#10;        Image(&#10;            painter = painterResource(R.drawable.nen2),&#10;            contentDescription = null,&#10;            modifier = Modifier&#10;                .absoluteOffset { IntOffset(0, bg2Y.roundToInt()) }&#10;                .fillMaxSize()&#10;        )&#10;&#10;        // --- Monsters (using MonsterUI component) ---&#10;        monsters.forEach { m -&gt;&#10;            MonsterUI(monster = m)&#10;        }&#10;&#10;        // --- Coins ---&#10;        coins.filter { !it.collected.value }.forEach { c -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.coin),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(c.x.roundToInt(), c.y.value.roundToInt()) }&#10;                    .size(40.dp)&#10;            )&#10;        }&#10;&#10;        // --- BagCoin animated views (spawned when coin collected) ---&#10;        bagCoins.toList().forEach { bag -&gt;&#10;            BagCoinAnimatedView(bag = bag, onFinished = { finishedBag -&gt;&#10;                bagCoins.remove(finishedBag)&#10;            })&#10;        }&#10;&#10;        // --- Bullets ---&#10;        bullets.forEach { b -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.dan2),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(b.x.roundToInt(), b.y.roundToInt()) }&#10;                    .size(30.dp)&#10;            )&#10;        }&#10;&#10;        // --- Plane (using PlaneUI component) ---&#10;        PlaneUI(&#10;            planeX = planeX,&#10;            planeY = planeY,&#10;            planeHp = planeHp,&#10;            shieldActive = shieldActive&#10;        )&#10;&#10;        // --- Wall effect (using WallUI component) ---&#10;        if (wallActive) {&#10;            WallUI(planeY = planeY)&#10;        }&#10;&#10;        // --- Top bar with chest items and score ---&#10;        TopBarUI(&#10;            bagCoinScore = totalScore,&#10;            chestItems = chestItems,&#10;            onBuyItem = { item, price -&gt;&#10;                if (totalScore &gt;= price) {&#10;                    totalScore -= price&#10;                    chestItems = chestItems + item&#10;                    if (!playerName.isNullOrBlank()) {&#10;                        FirebaseHelper.updateScore(playerName, totalScore)&#10;                        FirebaseHelper.updateChest(playerName, chestItems)&#10;                    }&#10;                }&#10;            },&#10;            onUseChestItem = { useChestItem(it) }&#10;        )&#10;&#10;        // --- Sound Control Button (top-right corner) ---&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp),&#10;            contentAlignment = Alignment.TopEnd&#10;        ) {&#10;            SoundControlButton()&#10;        }&#10;    }&#10;&#10;    // --- Game End Dialog ---&#10;    if (showGameEndDialog) {&#10;        GameEndDialog(&#10;            isWin = isLevelClear,&#10;            score = currentSessionScore,&#10;            level = 1,&#10;            onDismiss = {&#10;                showGameEndDialog = false&#10;            },&#10;            onReplay = {&#10;                // Reset game state to replay&#10;                showGameEndDialog = false&#10;                isGameOver = false&#10;                isLevelClear = false&#10;                planeHp = 100&#10;                currentSessionScore = 0&#10;&#10;                // Reset monsters&#10;                monsters.forEachIndexed { index, m -&gt;&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 100f)&#10;                    m.y.value = -Random.nextInt(200, 2000).toFloat()&#10;                    m.hp.value = 100&#10;                    m.alive.value = true&#10;                    monsterRespawnTimes[index] = 0L&#10;                }&#10;&#10;                // Reset coins&#10;                coins.forEach { c -&gt;&#10;                    c.collected.value = false&#10;                    c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                    c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                }&#10;&#10;                // Clear bullets&#10;                bullets.clear()&#10;            },&#10;            onNextLevel = {&#10;                // Navigate to next level handled by GameEndDialog itself&#10;                onExit() // Close this activity&#10;            },&#10;            onExit = {&#10;                // Back to main menu&#10;                onExit()&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * BagCoinAnimatedView&#10; * - Animates a bag coin sprite moving slightly up and fading out.&#10; * - Calls onFinished(bag) when animation done so caller can remove it.&#10; */&#10;@Composable&#10;private fun BagCoinAnimatedView(bag: BagCoinDisplay, onFinished: (BagCoinDisplay) -&gt; Unit) {&#10;    // local state for animation&#10;    var offsetY by remember { mutableStateOf(bag.y) }&#10;    var alpha by remember { mutableStateOf(1f) }&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // animate once when composition enters&#10;    LaunchedEffect(bag) {&#10;        val duration = 800L&#10;        val steps = 40&#10;        repeat(steps) { i -&gt;&#10;            offsetY -= 2f // move up total ~80 px over duration&#10;            alpha = 1f - (i / steps.toFloat())&#10;            delay(duration / steps)&#10;        }&#10;        // finished -&gt; notify parent to remove&#10;        onFinished(bag)&#10;    }&#10;&#10;    // Render image with graphicsLayer alpha&#10;    Image(&#10;        painter = painterResource(R.drawable.bagcoin),&#10;        contentDescription = null,&#10;        modifier = Modifier&#10;            .absoluteOffset { IntOffset(bag.x.roundToInt(), offsetY.roundToInt()) }&#10;            .size(60.dp)&#10;            .graphicsLayer { this.alpha = alpha }&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/game/Level2Activity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/game/Level2Activity.kt" />
              <option name="originalContent" value="package com.example.game&#10;&#10;import android.os.Bundle&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.TopBarComponent.TopBarUI&#10;import com.example.game.core.*&#10;import com.example.game.ui.PlaneUI&#10;import com.example.game.ui.MonsterUI&#10;import com.example.game.ui.WallUI&#10;import com.example.game.ui.SoundControlButton&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.*&#10;import kotlin.random.Random&#10;&#10;class Level2Activity : BaseGameActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        initAudio()&#10;&#10;        setContent {&#10;            val density = LocalDensity.current&#10;            val screenWidthPx = with(density) { LocalConfiguration.current.screenWidthDp.dp.toPx() }&#10;            val screenHeightPx = with(density) { LocalConfiguration.current.screenHeightDp.dp.toPx() }&#10;&#10;            Level2Game(&#10;                screenWidthPx = screenWidthPx,&#10;                screenHeightPx = screenHeightPx,&#10;                soundPool = soundPool,&#10;                shootSoundId = shootSoundId,&#10;                onExit = { finish() }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Level2Game(&#10;    screenWidthPx: Float,&#10;    screenHeightPx: Float,&#10;    soundPool: android.media.SoundPool,&#10;    shootSoundId: Int,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val playerName = PrefManager.getPlayerName(context)&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // --- State ---&#10;    var totalScore by remember { mutableStateOf(0) }&#10;    var currentSessionScore by remember { mutableStateOf(0) }&#10;    var planeHp by remember { mutableStateOf(100) }&#10;&#10;    var shieldActive by remember { mutableStateOf(false) }&#10;    var wallActive by remember { mutableStateOf(false) }&#10;    var timeActive by remember { mutableStateOf(false) }&#10;&#10;    var isGameOver by remember { mutableStateOf(false) }&#10;    var isLevelClear by remember { mutableStateOf(false) }&#10;    var showGameEndDialog by remember { mutableStateOf(false) }&#10;&#10;    // Show dialog when game ends instead of navigating to new activity&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        if (isGameOver || isLevelClear) {&#10;            delay(500)&#10;            showGameEndDialog = true&#10;        }&#10;    }&#10;&#10;    // --- Plane setup ---&#10;    var planeX by remember { mutableStateOf(screenWidthPx / 2 - 50f) }&#10;    val planeY = screenHeightPx - 250f&#10;    val planeWidth = 100f&#10;    val planeHeight = 100f&#10;&#10;    // --- Background ---&#10;    var bg1Y by remember { mutableStateOf(0f) }&#10;    var bg2Y by remember { mutableStateOf(-screenHeightPx) }&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bg1Y += 4f&#10;            bg2Y += 4f&#10;            if (bg1Y &gt;= screenHeightPx) bg1Y = bg2Y - screenHeightPx&#10;            if (bg2Y &gt;= screenHeightPx) bg2Y = bg1Y - screenHeightPx&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Entities: 5 rotating monster groups ---&#10;    val monsterGroups = remember {&#10;        List(5) { i -&gt;&#10;            RotatingMonsterGroup(&#10;                centerX = Random.nextFloat() * (screenWidthPx - 300f) + 150f, // Random X position&#10;                centerY = -300f, // Start just above screen&#10;                radius = 100f,&#10;                angleOffset = Random.nextFloat() * 360f, // Random starting angle&#10;                vx = if (Random.nextBoolean()) Random.nextFloat() * 2f + 2f else -(Random.nextFloat() * 2f + 2f),&#10;                vy = Random.nextFloat() * 2f + 3f // Random vertical speed (3-5f)&#10;            ).apply {&#10;                // Initially set monsters as dead - they will spawn with delay&#10;                monsters.forEach { it.alive.value = false }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Track respawn times for each group&#10;    val groupRespawnTimes = remember { MutableList(monsterGroups.size) { i -&gt; System.currentTimeMillis() + (i * 3000L) } }&#10;&#10;    val coins = remember {&#10;        List(7) {&#10;            BaseCoin(&#10;                x = Random.nextFloat() * (screenWidthPx - 50f),&#10;                y = mutableStateOf(-Random.nextInt(100, 800).toFloat()),&#10;                speed = Random.nextFloat() * 2f + 1.5f&#10;            )&#10;        }&#10;    }&#10;&#10;    val bullets = remember { mutableStateListOf&lt;Bullet&gt;() }&#10;    val bagCoins = remember { mutableStateListOf&lt;BagCoinDisplay&gt;() }&#10;    var chestItems by remember { mutableStateOf&lt;List&lt;ChestItem&gt;&gt;(emptyList()) }&#10;&#10;    // --- Load player data ---&#10;    LaunchedEffect(Unit) {&#10;        if (!playerName.isNullOrBlank()) {&#10;            FirebaseHelper.syncNewPlayer(playerName)&#10;            FirebaseHelper.getScore(playerName) { totalScore = it }&#10;            FirebaseHelper.getChestItems(playerName) { chestItems = it }&#10;        }&#10;    }&#10;&#10;    // --- Shooting ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.add(Bullet(planeX + planeWidth / 2 - 15f, planeY))&#10;            soundPool.play(shootSoundId, 0.5f, 0.5f, 1, 0, 1f)&#10;            delay(300)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.forEach { it.y -= 25f }&#10;            bullets.removeAll { it.y &lt; -50f }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Monster groups movement + rotation ---&#10;    monsterGroups.forEachIndexed { index, group -&gt;&#10;        LaunchedEffect(group, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                // Check if group needs to respawn&#10;                val allDead = group.monsters.all { !it.alive.value }&#10;                if (allDead &amp;&amp; System.currentTimeMillis() &gt;= groupRespawnTimes[index]) {&#10;                    // Respawn group at random position&#10;                    group.centerX = Random.nextFloat() * (screenWidthPx - 300f) + 150f&#10;                    group.centerY = -300f&#10;                    group.vx = if (Random.nextBoolean()) Random.nextFloat() * 2f + 2f else -(Random.nextFloat() * 2f + 2f)&#10;                    group.vy = Random.nextFloat() * 2f + 3f&#10;                    group.angleOffset = Random.nextFloat() * 360f // Random rotation angle&#10;                    group.monsters.forEach { m -&gt;&#10;                        m.hp.value = 100&#10;                        m.alive.value = true&#10;                    }&#10;                    // Update positions to match new center and angle&#10;                    group.updatePositions()&#10;                    // Set next respawn time with random delay (3-5 seconds)&#10;                    groupRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 5000)&#10;                }&#10;&#10;                if (!timeActive &amp;&amp; !allDead) {&#10;                    // Rotate monsters&#10;                    group.angleOffset += 3f&#10;&#10;                    // Move center&#10;                    group.centerX += group.vx&#10;                    group.centerY += group.vy&#10;&#10;                    // Bounce off LEFT wall - reverse to RIGHT&#10;                    if (group.centerX &lt;= 150f) {&#10;                        group.centerX = 150f&#10;                        group.vx = abs(group.vx) // Bounce to opposite direction (right)&#10;                    }&#10;&#10;                    // Bounce off RIGHT wall - reverse to LEFT&#10;                    if (group.centerX &gt;= screenWidthPx - 150f) {&#10;                        group.centerX = screenWidthPx - 150f&#10;                        group.vx = -abs(group.vx) // Bounce to opposite direction (left)&#10;                    }&#10;&#10;                    // Bounce off TOP - reverse to DOWN&#10;                    if (group.centerY &lt;= 150f) {&#10;                        group.centerY = 150f&#10;                        group.vy = abs(group.vy) // Bounce to opposite direction (down)&#10;                    }&#10;&#10;                    // Bounce off BOTTOM - reverse to UP&#10;                    if (group.centerY &gt;= screenHeightPx - 300f) {&#10;                        group.centerY = screenHeightPx - 300f&#10;                        group.vy = -abs(group.vy) // Bounce to opposite direction (up)&#10;                    }&#10;&#10;                    // Update monster positions&#10;                    group.updatePositions()&#10;&#10;                    // Respawn if group goes way off screen (safety check)&#10;                    if (group.centerY &gt; screenHeightPx + 500f || group.centerY &lt; -1000f) {&#10;                        groupRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(2000, 5000)&#10;                        group.monsters.forEach { it.alive.value = false }&#10;                    }&#10;                }&#10;                delay(16)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Coin movement ---&#10;    coins.forEach { c -&gt;&#10;        LaunchedEffect(c, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                if (!c.collected.value &amp;&amp; !timeActive) {&#10;                    c.y.value += c.speed&#10;                    if (c.y.value &gt; screenHeightPx) {&#10;                        c.y.value = -Random.nextInt(100, 800).toFloat()&#10;                        c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                    }&#10;                }&#10;                delay(32)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Bullet vs Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            val iter = bullets.iterator()&#10;            while (iter.hasNext()) {&#10;                val b = iter.next()&#10;                monsterGroups.forEach { group -&gt;&#10;                    group.monsters.forEach { m -&gt;&#10;                        if (CollisionUtils.checkCollisionBulletMonster(b, m)) {&#10;                            m.hp.value -= 25&#10;                            iter.remove()&#10;                            if (m.hp.value &lt;= 0) {&#10;                                m.alive.value = false&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Coin collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            coins.forEach { c -&gt;&#10;                if (!c.collected.value &amp;&amp; CollisionUtils.checkCollisionPlaneCoin(planeX, planeY, planeWidth, planeHeight, c)) {&#10;                    c.collected.value = true&#10;                    totalScore += 1&#10;                    currentSessionScore += 1&#10;                    val bag = BagCoinDisplay(c.x, c.y.value, 1)&#10;                    bagCoins.add(bag)&#10;                    if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            monsterGroups.forEach { group -&gt;&#10;                group.monsters.forEach { m -&gt;&#10;                    if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp;&#10;                        CollisionUtils.checkCollisionPlaneMonster(planeX, planeY, planeWidth, planeHeight, m)&#10;                    ) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) planeHp -= 50&#10;                        m.hp.value = 0&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;            }&#10;            if (planeHp &lt;= 0) isGameOver = true&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Wall - Monster collision ---&#10;    LaunchedEffect(wallActive, isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            if (wallActive) {&#10;                monsterGroups.forEach { group -&gt;&#10;                    group.monsters.forEach { m -&gt;&#10;                        if (m.alive.value &amp;&amp; m.hp.value &gt; 0) {&#10;                            if (CollisionUtils.checkCollisionWallMonster(planeY, m)) {&#10;                                m.hp.value -= 2&#10;                                if (m.hp.value &lt;= 0) {&#10;                                    m.alive.value = false&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Use chest item ---&#10;    fun useChestItem(item: ChestItem) {&#10;        // Flatten all monsters from groups for ChestItemEffectsBase&#10;        val allMonsters = monsterGroups.flatMap { it.monsters }&#10;        ChestItemEffectsBase.applyItemEffect(&#10;            itemName = item.name,&#10;            monsters = allMonsters,&#10;            coins = coins,&#10;            bagCoins = bagCoins,&#10;            coroutineScope = coroutineScope,&#10;            screenHeightPx = screenHeightPx,&#10;            planeX = planeX,&#10;            onScoreUpdate = { add -&gt;&#10;                totalScore += add&#10;                currentSessionScore += add&#10;                if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;            },&#10;            onShieldToggle = { active -&gt; shieldActive = active },&#10;            onWallToggle = { active -&gt; wallActive = active },&#10;            onTimeToggle = { active -&gt; timeActive = active },&#10;            onLevelClear = { isLevelClear = true }&#10;        )&#10;        chestItems = chestItems - item&#10;        if (!playerName.isNullOrBlank()) FirebaseHelper.updateChest(playerName, chestItems)&#10;    }&#10;&#10;    // --- Drag plane ---&#10;    val dragModifier = Modifier.pointerInput(Unit) {&#10;        detectDragGestures { change, dragAmount -&gt;&#10;            planeX = (planeX + dragAmount.x).coerceIn(0f, screenWidthPx - planeWidth)&#10;            change.consume()&#10;        }&#10;    }&#10;&#10;    // --- UI ---&#10;    Box(modifier = Modifier.fillMaxSize().then(dragModifier)) {&#10;        // Background&#10;        Image(&#10;            painter = painterResource(R.drawable.nen2),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg1Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;        Image(&#10;            painter = painterResource(R.drawable.nen2),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg2Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;&#10;        // Monsters (using MonsterUI component)&#10;        monsterGroups.forEach { group -&gt;&#10;            group.monsters.forEach { m -&gt;&#10;                MonsterUI(monster = m)&#10;            }&#10;        }&#10;&#10;        // Coins&#10;        coins.filter { !it.collected.value }.forEach { c -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.coin),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(c.x.roundToInt(), c.y.value.roundToInt()) }&#10;                    .size(40.dp)&#10;            )&#10;        }&#10;&#10;        // BagCoin animated views&#10;        bagCoins.toList().forEach { bag -&gt;&#10;            BagCoinAnimatedView(bag = bag, onFinished = { finishedBag -&gt;&#10;                bagCoins.remove(finishedBag)&#10;            })&#10;        }&#10;&#10;        // Bullets&#10;        bullets.forEach { b -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.dan2),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(b.x.roundToInt(), b.y.roundToInt()) }&#10;                    .size(30.dp)&#10;            )&#10;        }&#10;&#10;        // Plane (using PlaneUI component)&#10;        PlaneUI(&#10;            planeX = planeX,&#10;            planeY = planeY,&#10;            planeHp = planeHp,&#10;            shieldActive = shieldActive&#10;        )&#10;&#10;        // Wall (using WallUI component)&#10;        if (wallActive) {&#10;            WallUI(planeY = planeY)&#10;        }&#10;&#10;        // Top bar&#10;        TopBarUI(&#10;            bagCoinScore = totalScore,&#10;            chestItems = chestItems,&#10;            onBuyItem = { item, price -&gt;&#10;                if (totalScore &gt;= price) {&#10;                    totalScore -= price&#10;                    chestItems = chestItems + item&#10;                    if (!playerName.isNullOrBlank()) {&#10;                        FirebaseHelper.updateScore(playerName, totalScore)&#10;                        FirebaseHelper.updateChest(playerName, chestItems)&#10;                    }&#10;                }&#10;            },&#10;            onUseChestItem = { useChestItem(it) }&#10;        )&#10;&#10;        // --- Sound Control Button (top-right corner) ---&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp),&#10;            contentAlignment = Alignment.TopEnd&#10;        ) {&#10;            SoundControlButton()&#10;        }&#10;    }&#10;&#10;    // --- Game End Dialog ---&#10;    if (showGameEndDialog) {&#10;        GameEndDialog(&#10;            isWin = isLevelClear,&#10;            score = currentSessionScore,&#10;            level = 2,&#10;            onDismiss = {&#10;                showGameEndDialog = false&#10;            },&#10;            onReplay = {&#10;                // Reset game state to replay&#10;                showGameEndDialog = false&#10;                isGameOver = false&#10;                isLevelClear = false&#10;                planeHp = 100&#10;                currentSessionScore = 0&#10;&#10;                // Reset monsters&#10;                monsterGroups.forEach { group -&gt;&#10;                    group.centerX = Random.nextFloat() * (screenWidthPx - 300f) + 150f&#10;                    group.centerY = -300f&#10;                    group.vx = if (Random.nextBoolean()) Random.nextFloat() * 2f + 2f else -(Random.nextFloat() * 2f + 2f)&#10;                    group.vy = Random.nextFloat() * 2f + 3f&#10;                    group.angleOffset = Random.nextFloat() * 360f&#10;                    group.monsters.forEach { m -&gt;&#10;                        m.hp.value = 100&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;&#10;                // Reset respawn times&#10;                for (i in groupRespawnTimes.indices) {&#10;                    groupRespawnTimes[i] = System.currentTimeMillis() + (i * 3000L)&#10;                }&#10;&#10;                // Reset coins&#10;                coins.forEach { c -&gt;&#10;                    c.collected.value = false&#10;                    c.y.value = -Random.nextInt(100, 800).toFloat()&#10;                    c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                }&#10;&#10;                // Clear bullets&#10;                bullets.clear()&#10;            },&#10;            onNextLevel = {&#10;                // Navigate to next level handled by GameEndDialog itself&#10;                onExit() // Close this activity&#10;            },&#10;            onExit = {&#10;                // Back to main menu&#10;                onExit()&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * BagCoinAnimatedView for Level 2&#10; * - Animates a bag coin sprite moving slightly up and fading out.&#10; * - Calls onFinished(bag) when animation done so caller can remove it.&#10; */&#10;@Composable&#10;private fun BagCoinAnimatedView(bag: BagCoinDisplay, onFinished: (BagCoinDisplay) -&gt; Unit) {&#10;    var offsetY by remember { mutableStateOf(bag.y) }&#10;    var alpha by remember { mutableStateOf(1f) }&#10;&#10;    LaunchedEffect(bag) {&#10;        val duration = 800L&#10;        val steps = 40&#10;        repeat(steps) { i -&gt;&#10;            offsetY -= 2f&#10;            alpha = 1f - (i / steps.toFloat())&#10;            delay(duration / steps)&#10;        }&#10;        onFinished(bag)&#10;    }&#10;&#10;    Image(&#10;        painter = painterResource(R.drawable.bagcoin),&#10;        contentDescription = null,&#10;        modifier = Modifier&#10;            .absoluteOffset { IntOffset(bag.x.roundToInt(), offsetY.roundToInt()) }&#10;            .size(60.dp)&#10;            .graphicsLayer { this.alpha = alpha }&#10;    )&#10;}&#10;&#10;/**&#10; * Rotating Monster Group - 3 monsters rotating around a center point&#10; */&#10;class RotatingMonsterGroup(&#10;    var centerX: Float,&#10;    var centerY: Float,&#10;    var radius: Float,&#10;    var angleOffset: Float,&#10;    var vx: Float, // velocity X&#10;    var vy: Float  // velocity Y&#10;) {&#10;    val monsters = List(3) { i -&gt;&#10;        val angle = angleOffset + i * 120f&#10;        val rad = Math.toRadians(angle.toDouble())&#10;        BaseMonster(&#10;            x = (centerX + cos(rad) * radius).toFloat(),&#10;            y = mutableStateOf((centerY + sin(rad) * radius).toFloat()),&#10;            speed = 0f,&#10;            hp = mutableStateOf(100)&#10;        )&#10;    }&#10;&#10;    fun updatePositions() {&#10;        val angles = listOf(0f, 120f, 240f)&#10;        monsters.forEachIndexed { i, m -&gt;&#10;            if (m.alive.value) {&#10;                val rad = Math.toRadians((angleOffset + angles[i]).toDouble())&#10;                m.x = (centerX + cos(rad) * radius).toFloat()&#10;                m.y.value = (centerY + sin(rad) * radius).toFloat()&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.game&#10;&#10;import android.os.Bundle&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.TopBarComponent.TopBarUI&#10;import com.example.game.core.*&#10;import com.example.game.ui.PlaneUI&#10;import com.example.game.ui.MonsterUI&#10;import com.example.game.ui.WallUI&#10;import com.example.game.ui.SoundControlButton&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.*&#10;import kotlin.random.Random&#10;&#10;class Level2Activity : BaseGameActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        initAudio()&#10;&#10;        setContent {&#10;            val density = LocalDensity.current&#10;            val screenWidthPx = with(density) { LocalConfiguration.current.screenWidthDp.dp.toPx() }&#10;            val screenHeightPx = with(density) { LocalConfiguration.current.screenHeightDp.dp.toPx() }&#10;&#10;            Level2Game(&#10;                screenWidthPx = screenWidthPx,&#10;                screenHeightPx = screenHeightPx,&#10;                soundPool = soundPool,&#10;                shootSoundId = shootSoundId,&#10;                hitSoundId = hitSoundId,&#10;                onExit = { finish() }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Level2Game(&#10;    screenWidthPx: Float,&#10;    screenHeightPx: Float,&#10;    soundPool: android.media.SoundPool,&#10;    shootSoundId: Int,&#10;    hitSoundId: Int,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val playerName = PrefManager.getPlayerName(context)&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // --- State ---&#10;    var totalScore by remember { mutableStateOf(0) }&#10;    var currentSessionScore by remember { mutableStateOf(0) }&#10;    var planeHp by remember { mutableStateOf(100) }&#10;&#10;    var shieldActive by remember { mutableStateOf(false) }&#10;    var wallActive by remember { mutableStateOf(false) }&#10;    var timeActive by remember { mutableStateOf(false) }&#10;&#10;    var isGameOver by remember { mutableStateOf(false) }&#10;    var isLevelClear by remember { mutableStateOf(false) }&#10;    var showGameEndDialog by remember { mutableStateOf(false) }&#10;&#10;    // Show dialog when game ends instead of navigating to new activity&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        if (isGameOver || isLevelClear) {&#10;            delay(500)&#10;            showGameEndDialog = true&#10;        }&#10;    }&#10;&#10;    // --- Plane setup ---&#10;    var planeX by remember { mutableStateOf(screenWidthPx / 2 - 50f) }&#10;    val planeY = screenHeightPx - 250f&#10;    val planeWidth = 100f&#10;    val planeHeight = 100f&#10;&#10;    // --- Background ---&#10;    var bg1Y by remember { mutableStateOf(0f) }&#10;    var bg2Y by remember { mutableStateOf(-screenHeightPx) }&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bg1Y += 4f&#10;            bg2Y += 4f&#10;            if (bg1Y &gt;= screenHeightPx) bg1Y = bg2Y - screenHeightPx&#10;            if (bg2Y &gt;= screenHeightPx) bg2Y = bg1Y - screenHeightPx&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Entities: 5 rotating monster groups ---&#10;    val monsterGroups = remember {&#10;        List(5) { i -&gt;&#10;            RotatingMonsterGroup(&#10;                centerX = Random.nextFloat() * (screenWidthPx - 300f) + 150f, // Random X position&#10;                centerY = -300f, // Start just above screen&#10;                radius = 100f,&#10;                angleOffset = Random.nextFloat() * 360f, // Random starting angle&#10;                vx = if (Random.nextBoolean()) Random.nextFloat() * 2f + 2f else -(Random.nextFloat() * 2f + 2f),&#10;                vy = Random.nextFloat() * 2f + 3f // Random vertical speed (3-5f)&#10;            ).apply {&#10;                // Initially set monsters as dead - they will spawn with delay&#10;                monsters.forEach { it.alive.value = false }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Track respawn times for each group&#10;    val groupRespawnTimes = remember { MutableList(monsterGroups.size) { i -&gt; System.currentTimeMillis() + (i * 3000L) } }&#10;&#10;    val coins = remember {&#10;        List(7) {&#10;            BaseCoin(&#10;                x = Random.nextFloat() * (screenWidthPx - 50f),&#10;                y = mutableStateOf(-Random.nextInt(100, 800).toFloat()),&#10;                speed = Random.nextFloat() * 2f + 1.5f&#10;            )&#10;        }&#10;    }&#10;&#10;    val bullets = remember { mutableStateListOf&lt;Bullet&gt;() }&#10;    val bagCoins = remember { mutableStateListOf&lt;BagCoinDisplay&gt;() }&#10;    var chestItems by remember { mutableStateOf&lt;List&lt;ChestItem&gt;&gt;(emptyList()) }&#10;&#10;    // --- Load player data ---&#10;    LaunchedEffect(Unit) {&#10;        if (!playerName.isNullOrBlank()) {&#10;            FirebaseHelper.syncNewPlayer(playerName)&#10;            FirebaseHelper.getScore(playerName) { totalScore = it }&#10;            FirebaseHelper.getChestItems(playerName) { chestItems = it }&#10;        }&#10;    }&#10;&#10;    // --- Shooting ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.add(Bullet(planeX + planeWidth / 2 - 15f, planeY))&#10;            SoundManager.playSoundEffect(soundPool, shootSoundId, 0.5f)&#10;            delay(300)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.forEach { it.y -= 25f }&#10;            bullets.removeAll { it.y &lt; -50f }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Monster groups movement + rotation ---&#10;    monsterGroups.forEachIndexed { index, group -&gt;&#10;        LaunchedEffect(group, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                // Check if group needs to respawn&#10;                val allDead = group.monsters.all { !it.alive.value }&#10;                if (allDead &amp;&amp; System.currentTimeMillis() &gt;= groupRespawnTimes[index]) {&#10;                    // Respawn group at random position&#10;                    group.centerX = Random.nextFloat() * (screenWidthPx - 300f) + 150f&#10;                    group.centerY = -300f&#10;                    group.vx = if (Random.nextBoolean()) Random.nextFloat() * 2f + 2f else -(Random.nextFloat() * 2f + 2f)&#10;                    group.vy = Random.nextFloat() * 2f + 3f&#10;                    group.angleOffset = Random.nextFloat() * 360f // Random rotation angle&#10;                    group.monsters.forEach { m -&gt;&#10;                        m.hp.value = 100&#10;                        m.alive.value = true&#10;                    }&#10;                    // Update positions to match new center and angle&#10;                    group.updatePositions()&#10;                    // Set next respawn time with random delay (3-5 seconds)&#10;                    groupRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 5000)&#10;                }&#10;&#10;                if (!timeActive &amp;&amp; !allDead) {&#10;                    // Rotate monsters&#10;                    group.angleOffset += 3f&#10;&#10;                    // Move center&#10;                    group.centerX += group.vx&#10;                    group.centerY += group.vy&#10;&#10;                    // Bounce off LEFT wall - reverse to RIGHT&#10;                    if (group.centerX &lt;= 150f) {&#10;                        group.centerX = 150f&#10;                        group.vx = abs(group.vx) // Bounce to opposite direction (right)&#10;                    }&#10;&#10;                    // Bounce off RIGHT wall - reverse to LEFT&#10;                    if (group.centerX &gt;= screenWidthPx - 150f) {&#10;                        group.centerX = screenWidthPx - 150f&#10;                        group.vx = -abs(group.vx) // Bounce to opposite direction (left)&#10;                    }&#10;&#10;                    // Bounce off TOP - reverse to DOWN&#10;                    if (group.centerY &lt;= 150f) {&#10;                        group.centerY = 150f&#10;                        group.vy = abs(group.vy) // Bounce to opposite direction (down)&#10;                    }&#10;&#10;                    // Bounce off BOTTOM - reverse to UP&#10;                    if (group.centerY &gt;= screenHeightPx - 300f) {&#10;                        group.centerY = screenHeightPx - 300f&#10;                        group.vy = -abs(group.vy) // Bounce to opposite direction (up)&#10;                    }&#10;&#10;                    // Update monster positions&#10;                    group.updatePositions()&#10;&#10;                    // Respawn if group goes way off screen (safety check)&#10;                    if (group.centerY &gt; screenHeightPx + 500f || group.centerY &lt; -1000f) {&#10;                        groupRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(2000, 5000)&#10;                        group.monsters.forEach { it.alive.value = false }&#10;                    }&#10;                }&#10;                delay(16)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Coin movement ---&#10;    coins.forEach { c -&gt;&#10;        LaunchedEffect(c, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                if (!c.collected.value &amp;&amp; !timeActive) {&#10;                    c.y.value += c.speed&#10;                    if (c.y.value &gt; screenHeightPx) {&#10;                        c.y.value = -Random.nextInt(100, 800).toFloat()&#10;                        c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                    }&#10;                }&#10;                delay(32)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Bullet vs Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            val iter = bullets.iterator()&#10;            while (iter.hasNext()) {&#10;                val b = iter.next()&#10;                monsterGroups.forEach { group -&gt;&#10;                    group.monsters.forEach { m -&gt;&#10;                        if (CollisionUtils.checkCollisionBulletMonster(b, m)) {&#10;                            m.hp.value -= 25&#10;                            // Play hit sound&#10;                            SoundManager.playSoundEffect(soundPool, hitSoundId, 0.3f)&#10;                            iter.remove()&#10;                            if (m.hp.value &lt;= 0) {&#10;                                m.alive.value = false&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Coin collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            coins.forEach { c -&gt;&#10;                if (!c.collected.value &amp;&amp; CollisionUtils.checkCollisionPlaneCoin(planeX, planeY, planeWidth, planeHeight, c)) {&#10;                    c.collected.value = true&#10;                    totalScore += 1&#10;                    currentSessionScore += 1&#10;                    val bag = BagCoinDisplay(c.x, c.y.value, 1)&#10;                    bagCoins.add(bag)&#10;                    if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            monsterGroups.forEach { group -&gt;&#10;                group.monsters.forEach { m -&gt;&#10;                    if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp;&#10;                        CollisionUtils.checkCollisionPlaneMonster(planeX, planeY, planeWidth, planeHeight, m)&#10;                    ) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) planeHp -= 50&#10;                        m.hp.value = 0&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;            }&#10;            if (planeHp &lt;= 0) isGameOver = true&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Wall - Monster collision ---&#10;    LaunchedEffect(wallActive, isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            if (wallActive) {&#10;                monsterGroups.forEach { group -&gt;&#10;                    group.monsters.forEach { m -&gt;&#10;                        if (m.alive.value &amp;&amp; m.hp.value &gt; 0) {&#10;                            if (CollisionUtils.checkCollisionWallMonster(planeY, m)) {&#10;                                m.hp.value -= 2&#10;                                if (m.hp.value &lt;= 0) {&#10;                                    m.alive.value = false&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Use chest item ---&#10;    fun useChestItem(item: ChestItem) {&#10;        // Flatten all monsters from groups for ChestItemEffectsBase&#10;        val allMonsters = monsterGroups.flatMap { it.monsters }&#10;        ChestItemEffectsBase.applyItemEffect(&#10;            itemName = item.name,&#10;            monsters = allMonsters,&#10;            coins = coins,&#10;            bagCoins = bagCoins,&#10;            coroutineScope = coroutineScope,&#10;            screenHeightPx = screenHeightPx,&#10;            planeX = planeX,&#10;            onScoreUpdate = { add -&gt;&#10;                totalScore += add&#10;                currentSessionScore += add&#10;                if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;            },&#10;            onShieldToggle = { active -&gt; shieldActive = active },&#10;            onWallToggle = { active -&gt; wallActive = active },&#10;            onTimeToggle = { active -&gt; timeActive = active },&#10;            onLevelClear = { isLevelClear = true }&#10;        )&#10;        chestItems = chestItems - item&#10;        if (!playerName.isNullOrBlank()) FirebaseHelper.updateChest(playerName, chestItems)&#10;    }&#10;&#10;    // --- Drag plane ---&#10;    val dragModifier = Modifier.pointerInput(Unit) {&#10;        detectDragGestures { change, dragAmount -&gt;&#10;            planeX = (planeX + dragAmount.x).coerceIn(0f, screenWidthPx - planeWidth)&#10;            change.consume()&#10;        }&#10;    }&#10;&#10;    // --- UI ---&#10;    Box(modifier = Modifier.fillMaxSize().then(dragModifier)) {&#10;        // Background&#10;        Image(&#10;            painter = painterResource(R.drawable.nen2),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg1Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;        Image(&#10;            painter = painterResource(R.drawable.nen2),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg2Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;&#10;        // Monsters (using MonsterUI component)&#10;        monsterGroups.forEach { group -&gt;&#10;            group.monsters.forEach { m -&gt;&#10;                MonsterUI(monster = m)&#10;            }&#10;        }&#10;&#10;        // Coins&#10;        coins.filter { !it.collected.value }.forEach { c -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.coin),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(c.x.roundToInt(), c.y.value.roundToInt()) }&#10;                    .size(40.dp)&#10;            )&#10;        }&#10;&#10;        // BagCoin animated views&#10;        bagCoins.toList().forEach { bag -&gt;&#10;            BagCoinAnimatedView(bag = bag, onFinished = { finishedBag -&gt;&#10;                bagCoins.remove(finishedBag)&#10;            })&#10;        }&#10;&#10;        // Bullets&#10;        bullets.forEach { b -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.dan2),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(b.x.roundToInt(), b.y.roundToInt()) }&#10;                    .size(30.dp)&#10;            )&#10;        }&#10;&#10;        // Plane (using PlaneUI component)&#10;        PlaneUI(&#10;            planeX = planeX,&#10;            planeY = planeY,&#10;            planeHp = planeHp,&#10;            shieldActive = shieldActive&#10;        )&#10;&#10;        // Wall (using WallUI component)&#10;        if (wallActive) {&#10;            WallUI(planeY = planeY)&#10;        }&#10;&#10;        // Top bar&#10;        TopBarUI(&#10;            bagCoinScore = totalScore,&#10;            chestItems = chestItems,&#10;            onBuyItem = { item, price -&gt;&#10;                if (totalScore &gt;= price) {&#10;                    totalScore -= price&#10;                    chestItems = chestItems + item&#10;                    if (!playerName.isNullOrBlank()) {&#10;                        FirebaseHelper.updateScore(playerName, totalScore)&#10;                        FirebaseHelper.updateChest(playerName, chestItems)&#10;                    }&#10;                }&#10;            },&#10;            onUseChestItem = { useChestItem(it) }&#10;        )&#10;&#10;        // --- Sound Control Button (top-right corner) ---&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp),&#10;            contentAlignment = Alignment.TopEnd&#10;        ) {&#10;            SoundControlButton()&#10;        }&#10;    }&#10;&#10;    // --- Game End Dialog ---&#10;    if (showGameEndDialog) {&#10;        GameEndDialog(&#10;            isWin = isLevelClear,&#10;            score = currentSessionScore,&#10;            level = 2,&#10;            onDismiss = {&#10;                showGameEndDialog = false&#10;            },&#10;            onReplay = {&#10;                // Reset game state to replay&#10;                showGameEndDialog = false&#10;                isGameOver = false&#10;                isLevelClear = false&#10;                planeHp = 100&#10;                currentSessionScore = 0&#10;&#10;                // Reset monsters&#10;                monsterGroups.forEach { group -&gt;&#10;                    group.centerX = Random.nextFloat() * (screenWidthPx - 300f) + 150f&#10;                    group.centerY = -300f&#10;                    group.vx = if (Random.nextBoolean()) Random.nextFloat() * 2f + 2f else -(Random.nextFloat() * 2f + 2f)&#10;                    group.vy = Random.nextFloat() * 2f + 3f&#10;                    group.angleOffset = Random.nextFloat() * 360f&#10;                    group.monsters.forEach { m -&gt;&#10;                        m.hp.value = 100&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;&#10;                // Reset respawn times&#10;                for (i in groupRespawnTimes.indices) {&#10;                    groupRespawnTimes[i] = System.currentTimeMillis() + (i * 3000L)&#10;                }&#10;&#10;                // Reset coins&#10;                coins.forEach { c -&gt;&#10;                    c.collected.value = false&#10;                    c.y.value = -Random.nextInt(100, 800).toFloat()&#10;                    c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                }&#10;&#10;                // Clear bullets&#10;                bullets.clear()&#10;            },&#10;            onNextLevel = {&#10;                // Navigate to next level handled by GameEndDialog itself&#10;                onExit() // Close this activity&#10;            },&#10;            onExit = {&#10;                // Back to main menu&#10;                onExit()&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * BagCoinAnimatedView for Level 2&#10; * - Animates a bag coin sprite moving slightly up and fading out.&#10; * - Calls onFinished(bag) when animation done so caller can remove it.&#10; */&#10;@Composable&#10;private fun BagCoinAnimatedView(bag: BagCoinDisplay, onFinished: (BagCoinDisplay) -&gt; Unit) {&#10;    var offsetY by remember { mutableStateOf(bag.y) }&#10;    var alpha by remember { mutableStateOf(1f) }&#10;&#10;    LaunchedEffect(bag) {&#10;        val duration = 800L&#10;        val steps = 40&#10;        repeat(steps) { i -&gt;&#10;            offsetY -= 2f&#10;            alpha = 1f - (i / steps.toFloat())&#10;            delay(duration / steps)&#10;        }&#10;        onFinished(bag)&#10;    }&#10;&#10;    Image(&#10;        painter = painterResource(R.drawable.bagcoin),&#10;        contentDescription = null,&#10;        modifier = Modifier&#10;            .absoluteOffset { IntOffset(bag.x.roundToInt(), offsetY.roundToInt()) }&#10;            .size(60.dp)&#10;            .graphicsLayer { this.alpha = alpha }&#10;    )&#10;}&#10;&#10;/**&#10; * Rotating Monster Group - 3 monsters rotating around a center point&#10; */&#10;class RotatingMonsterGroup(&#10;    var centerX: Float,&#10;    var centerY: Float,&#10;    var radius: Float,&#10;    var angleOffset: Float,&#10;    var vx: Float, // velocity X&#10;    var vy: Float  // velocity Y&#10;) {&#10;    val monsters = List(3) { i -&gt;&#10;        val angle = angleOffset + i * 120f&#10;        val rad = Math.toRadians(angle.toDouble())&#10;        BaseMonster(&#10;            x = (centerX + cos(rad) * radius).toFloat(),&#10;            y = mutableStateOf((centerY + sin(rad) * radius).toFloat()),&#10;            speed = 0f,&#10;            hp = mutableStateOf(100)&#10;        )&#10;    }&#10;&#10;    fun updatePositions() {&#10;        val angles = listOf(0f, 120f, 240f)&#10;        monsters.forEachIndexed { i, m -&gt;&#10;            if (m.alive.value) {&#10;                val rad = Math.toRadians((angleOffset + angles[i]).toDouble())&#10;                m.x = (centerX + cos(rad) * radius).toFloat()&#10;                m.y.value = (centerY + sin(rad) * radius).toFloat()&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/game/Level3Activity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/game/Level3Activity.kt" />
              <option name="originalContent" value="package com.example.game&#10;&#10;import android.os.Bundle&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.TopBarComponent.TopBarUI&#10;import com.example.game.core.*&#10;import com.example.game.ui.PlaneUI&#10;import com.example.game.ui.WallUI&#10;import com.example.game.ui.InvisibleMonsterUI&#10;import com.example.game.ui.SoundControlButton&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.roundToInt&#10;import kotlin.random.Random&#10;&#10;class Level3Activity : BaseGameActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        initAudio()&#10;&#10;        setContent {&#10;            val density = LocalDensity.current&#10;            val screenWidthPx = with(density) { LocalConfiguration.current.screenWidthDp.dp.toPx() }&#10;            val screenHeightPx = with(density) { LocalConfiguration.current.screenHeightDp.dp.toPx() }&#10;&#10;            Level3Game(&#10;                screenWidthPx = screenWidthPx,&#10;                screenHeightPx = screenHeightPx,&#10;                soundPool = soundPool,&#10;                shootSoundId = shootSoundId,&#10;                onExit = { finish() }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Level3Game(&#10;    screenWidthPx: Float,&#10;    screenHeightPx: Float,&#10;    soundPool: android.media.SoundPool,&#10;    shootSoundId: Int,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val playerName = PrefManager.getPlayerName(context)&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // --- State ---&#10;    var totalScore by remember { mutableStateOf(0) }&#10;    var currentSessionScore by remember { mutableStateOf(0) }&#10;    var planeHp by remember { mutableStateOf(100) }&#10;&#10;    var shieldActive by remember { mutableStateOf(false) }&#10;    var wallActive by remember { mutableStateOf(false) }&#10;    var timeActive by remember { mutableStateOf(false) }&#10;&#10;    var isGameOver by remember { mutableStateOf(false) }&#10;    var isLevelClear by remember { mutableStateOf(false) }&#10;    var showGameEndDialog by remember { mutableStateOf(false) }&#10;&#10;    // Show dialog when game ends&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        if (isGameOver || isLevelClear) {&#10;            delay(500)&#10;            showGameEndDialog = true&#10;        }&#10;    }&#10;&#10;    // --- Plane setup ---&#10;    var planeX by remember { mutableStateOf(screenWidthPx / 2 - 50f) }&#10;    val planeY = screenHeightPx - 250f&#10;    val planeWidth = 100f&#10;    val planeHeight = 100f&#10;&#10;    // --- Background ---&#10;    var bg1Y by remember { mutableStateOf(0f) }&#10;    var bg2Y by remember { mutableStateOf(-screenHeightPx) }&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bg1Y += 4f&#10;            bg2Y += 4f&#10;            if (bg1Y &gt;= screenHeightPx) bg1Y = bg2Y - screenHeightPx&#10;            if (bg2Y &gt;= screenHeightPx) bg2Y = bg1Y - screenHeightPx&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Invisible Monsters ---&#10;    val invisibleMonsters = remember {&#10;        List(12) {&#10;            InvisibleMonster(&#10;                x = Random.nextFloat() * (screenWidthPx - 100f),&#10;                y = mutableStateOf(-Random.nextInt(200, 3000).toFloat()),&#10;                speed = Random.nextFloat() * 1.5f + 1.5f,&#10;                hp = mutableStateOf(100),&#10;                invisibleDuration = 2000L, // Invisible for 2 seconds&#10;                visibleDuration = 1500L     // Visible for 1.5 seconds&#10;            )&#10;        }&#10;    }&#10;&#10;    // Track respawn times&#10;    val monsterRespawnTimes = remember { MutableList(invisibleMonsters.size) { 0L } }&#10;&#10;    val coins = remember {&#10;        List(6) {&#10;            BaseCoin(&#10;                x = Random.nextFloat() * (screenWidthPx - 50f),&#10;                y = mutableStateOf(-Random.nextInt(100, 600).toFloat()),&#10;                speed = Random.nextFloat() * 2f + 1f&#10;            )&#10;        }&#10;    }&#10;&#10;    val bullets = remember { mutableStateListOf&lt;Bullet&gt;() }&#10;    val bagCoins = remember { mutableStateListOf&lt;BagCoinDisplay&gt;() }&#10;    var chestItems by remember { mutableStateOf&lt;List&lt;ChestItem&gt;&gt;(emptyList()) }&#10;&#10;    // --- Load player data ---&#10;    LaunchedEffect(Unit) {&#10;        if (!playerName.isNullOrBlank()) {&#10;            FirebaseHelper.syncNewPlayer(playerName)&#10;            FirebaseHelper.getScore(playerName) { totalScore = it }&#10;            FirebaseHelper.getChestItems(playerName) { chestItems = it }&#10;        }&#10;    }&#10;&#10;    // --- Shooting ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.add(Bullet(planeX + planeWidth / 2f - 15f, planeY))&#10;            soundPool.play(shootSoundId, 0.5f, 0.5f, 1, 0, 1f)&#10;            delay(300)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.forEach { it.y -= 25f }&#10;            bullets.removeAll { it.y &lt; -50f }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Monster movement + invisible toggle ---&#10;    invisibleMonsters.forEachIndexed { index, m -&gt;&#10;        LaunchedEffect(m, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                // Check if monster needs to respawn&#10;                if (!m.alive.value &amp;&amp; System.currentTimeMillis() &gt;= monsterRespawnTimes[index]) {&#10;                    m.y.value = -Random.nextInt(200, 1500).toFloat()&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 100f)&#10;                    m.hp.value = 100&#10;                    m.alive.value = true&#10;                    m.lastToggleTime = System.currentTimeMillis()&#10;                    m.isVisible.value = Random.nextBoolean() // Random start state&#10;                }&#10;&#10;                if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp; !timeActive) {&#10;                    // Toggle visibility&#10;                    val currentTime = System.currentTimeMillis()&#10;                    val elapsed = currentTime - m.lastToggleTime&#10;                    val threshold = if (m.isVisible.value) m.visibleDuration else m.invisibleDuration&#10;&#10;                    if (elapsed &gt;= threshold) {&#10;                        m.isVisible.value = !m.isVisible.value&#10;                        m.lastToggleTime = currentTime&#10;                    }&#10;&#10;                    // Wall collision check&#10;                    val wallTop = planeY - 60f&#10;                    val monsterBottom = m.y.value + 80f&#10;&#10;                    if (wallActive &amp;&amp; monsterBottom &gt;= wallTop) {&#10;                        // Stop at wall&#10;                    } else {&#10;                        // Normal movement&#10;                        m.y.value += m.speed&#10;                    }&#10;&#10;                    // Zigzag movement&#10;                    m.x += m.horizontalSpeed * m.direction&#10;                    if (m.x &lt;= 0 || m.x &gt;= screenWidthPx - 100f) {&#10;                        m.direction *= -1&#10;                    }&#10;&#10;                    // If monster passes plane&#10;                    if (m.y.value &gt; planeY + planeHeight / 2f) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) planeHp -= 50&#10;                        monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 8000)&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;                delay(16)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Coin movement ---&#10;    coins.forEach { c -&gt;&#10;        LaunchedEffect(c, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                if (!c.collected.value &amp;&amp; !timeActive) {&#10;                    c.y.value += c.speed&#10;                    if (c.y.value &gt; screenHeightPx) {&#10;                        c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                        c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                    }&#10;                }&#10;                delay(32)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Bullet vs Monster collision (only when visible) ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            val iter = bullets.iterator()&#10;            while (iter.hasNext()) {&#10;                val b = iter.next()&#10;                invisibleMonsters.forEach { m -&gt;&#10;                    // Can only hit visible monsters&#10;                    if (m.isVisible.value &amp;&amp; CollisionUtils.checkCollisionBulletMonster(b, m)) {&#10;                        m.hp.value -= 25&#10;                        iter.remove()&#10;                        if (m.hp.value &lt;= 0) {&#10;                            m.alive.value = false&#10;                            val index = invisibleMonsters.indexOf(m)&#10;                            if (index &gt;= 0) {&#10;                                monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 8000)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Coin collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            coins.forEach { c -&gt;&#10;                if (!c.collected.value &amp;&amp; CollisionUtils.checkCollisionPlaneCoin(planeX, planeY, planeWidth, planeHeight, c)) {&#10;                    c.collected.value = true&#10;                    totalScore += 1&#10;                    currentSessionScore += 1&#10;                    val bag = BagCoinDisplay(c.x, c.y.value, 1)&#10;                    bagCoins.add(bag)&#10;                    if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Monster collision (only when visible) ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            invisibleMonsters.forEach { m -&gt;&#10;                if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp; m.isVisible.value &amp;&amp;&#10;                    CollisionUtils.checkCollisionPlaneMonster(planeX, planeY, planeWidth, planeHeight, m)&#10;                ) {&#10;                    if (!shieldActive &amp;&amp; !wallActive) planeHp -= 50&#10;                    m.hp.value = 0&#10;                    m.alive.value = false&#10;                }&#10;            }&#10;            if (planeHp &lt;= 0) isGameOver = true&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Wall - Monster collision ---&#10;    LaunchedEffect(wallActive, isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            if (wallActive) {&#10;                invisibleMonsters.forEach { m -&gt;&#10;                    if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp; m.isVisible.value) {&#10;                        if (CollisionUtils.checkCollisionWallMonster(planeY, m)) {&#10;                            m.hp.value -= 2&#10;                            if (m.hp.value &lt;= 0) {&#10;                                m.alive.value = false&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Use chest item ---&#10;    fun useChestItem(item: ChestItem) {&#10;        ChestItemEffectsBase.applyItemEffect(&#10;            itemName = item.name,&#10;            monsters = invisibleMonsters,&#10;            coins = coins,&#10;            bagCoins = bagCoins,&#10;            coroutineScope = coroutineScope,&#10;            screenHeightPx = screenHeightPx,&#10;            planeX = planeX,&#10;            onScoreUpdate = { add -&gt;&#10;                totalScore += add&#10;                currentSessionScore += add&#10;                if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;            },&#10;            onShieldToggle = { active -&gt; shieldActive = active },&#10;            onWallToggle = { active -&gt; wallActive = active },&#10;            onTimeToggle = { active -&gt; timeActive = active },&#10;            onLevelClear = { isLevelClear = true }&#10;        )&#10;        chestItems = chestItems - item&#10;        if (!playerName.isNullOrBlank()) FirebaseHelper.updateChest(playerName, chestItems)&#10;    }&#10;&#10;    // --- Drag plane ---&#10;    val dragModifier = Modifier.pointerInput(Unit) {&#10;        detectDragGestures { change, dragAmount -&gt;&#10;            planeX = (planeX + dragAmount.x).coerceIn(0f, screenWidthPx - planeWidth)&#10;            change.consume()&#10;        }&#10;    }&#10;&#10;    // --- UI ---&#10;    Box(modifier = Modifier.fillMaxSize().then(dragModifier)) {&#10;        // Background&#10;        Image(&#10;            painter = painterResource(R.drawable.vutru1),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg1Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;        Image(&#10;            painter = painterResource(R.drawable.vutru1),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg2Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;&#10;        // Invisible Monsters (only show when visible)&#10;        invisibleMonsters.forEach { m -&gt;&#10;            if (m.isVisible.value) {&#10;                InvisibleMonsterUI(monster = m)&#10;            }&#10;        }&#10;&#10;        // Coins&#10;        coins.filter { !it.collected.value }.forEach { c -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.coin),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(c.x.roundToInt(), c.y.value.roundToInt()) }&#10;                    .size(40.dp)&#10;            )&#10;        }&#10;&#10;        // BagCoin animated views&#10;        bagCoins.toList().forEach { bag -&gt;&#10;            BagCoinAnimatedView(bag = bag, onFinished = { finishedBag -&gt;&#10;                bagCoins.remove(finishedBag)&#10;            })&#10;        }&#10;&#10;        // Bullets&#10;        bullets.forEach { b -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.dan2),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(b.x.roundToInt(), b.y.roundToInt()) }&#10;                    .size(30.dp)&#10;            )&#10;        }&#10;&#10;        // Plane&#10;        PlaneUI(&#10;            planeX = planeX,&#10;            planeY = planeY,&#10;            planeHp = planeHp,&#10;            shieldActive = shieldActive&#10;        )&#10;&#10;        // Wall&#10;        if (wallActive) {&#10;            WallUI(planeY = planeY)&#10;        }&#10;&#10;        // Top bar&#10;        TopBarUI(&#10;            bagCoinScore = totalScore,&#10;            chestItems = chestItems,&#10;            onBuyItem = { item, price -&gt;&#10;                if (totalScore &gt;= price) {&#10;                    totalScore -= price&#10;                    chestItems = chestItems + item&#10;                    if (!playerName.isNullOrBlank()) {&#10;                        FirebaseHelper.updateScore(playerName, totalScore)&#10;                        FirebaseHelper.updateChest(playerName, chestItems)&#10;                    }&#10;                }&#10;            },&#10;            onUseChestItem = { useChestItem(it) }&#10;        )&#10;&#10;        // --- Sound Control Button (top-right corner) ---&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp),&#10;            contentAlignment = androidx.compose.ui.Alignment.TopEnd&#10;        ) {&#10;            SoundControlButton()&#10;        }&#10;    }&#10;&#10;    // --- Game End Dialog ---&#10;    if (showGameEndDialog) {&#10;        GameEndDialog(&#10;            isWin = isLevelClear,&#10;            score = currentSessionScore,&#10;            level = 3,&#10;            onDismiss = {&#10;                showGameEndDialog = false&#10;            },&#10;            onReplay = {&#10;                // Reset game&#10;                showGameEndDialog = false&#10;                isGameOver = false&#10;                isLevelClear = false&#10;                planeHp = 100&#10;                currentSessionScore = 0&#10;&#10;                invisibleMonsters.forEachIndexed { index, m -&gt;&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 100f)&#10;                    m.y.value = -Random.nextInt(200, 3000).toFloat()&#10;                    m.hp.value = 100&#10;                    m.alive.value = true&#10;                    m.isVisible.value = Random.nextBoolean()&#10;                    m.lastToggleTime = System.currentTimeMillis()&#10;                    monsterRespawnTimes[index] = 0L&#10;                }&#10;&#10;                coins.forEach { c -&gt;&#10;                    c.collected.value = false&#10;                    c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                    c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                }&#10;&#10;                bullets.clear()&#10;            },&#10;            onNextLevel = {&#10;                onExit()&#10;            },&#10;            onExit = {&#10;                onExit()&#10;            }&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.game&#10;&#10;import android.os.Bundle&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.TopBarComponent.TopBarUI&#10;import com.example.game.core.*&#10;import com.example.game.ui.PlaneUI&#10;import com.example.game.ui.WallUI&#10;import com.example.game.ui.InvisibleMonsterUI&#10;import com.example.game.ui.SoundControlButton&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.roundToInt&#10;import kotlin.random.Random&#10;&#10;class Level3Activity : BaseGameActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        initAudio()&#10;&#10;        setContent {&#10;            val density = LocalDensity.current&#10;            val screenWidthPx = with(density) { LocalConfiguration.current.screenWidthDp.dp.toPx() }&#10;            val screenHeightPx = with(density) { LocalConfiguration.current.screenHeightDp.dp.toPx() }&#10;&#10;            Level3Game(&#10;                screenWidthPx = screenWidthPx,&#10;                screenHeightPx = screenHeightPx,&#10;                soundPool = soundPool,&#10;                shootSoundId = shootSoundId,&#10;                hitSoundId = hitSoundId,&#10;                onExit = { finish() }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Level3Game(&#10;    screenWidthPx: Float,&#10;    screenHeightPx: Float,&#10;    soundPool: android.media.SoundPool,&#10;    shootSoundId: Int,&#10;    hitSoundId: Int,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val playerName = PrefManager.getPlayerName(context)&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // --- State ---&#10;    var totalScore by remember { mutableStateOf(0) }&#10;    var currentSessionScore by remember { mutableStateOf(0) }&#10;    var planeHp by remember { mutableStateOf(100) }&#10;&#10;    var shieldActive by remember { mutableStateOf(false) }&#10;    var wallActive by remember { mutableStateOf(false) }&#10;    var timeActive by remember { mutableStateOf(false) }&#10;&#10;    var isGameOver by remember { mutableStateOf(false) }&#10;    var isLevelClear by remember { mutableStateOf(false) }&#10;    var showGameEndDialog by remember { mutableStateOf(false) }&#10;&#10;    // Show dialog when game ends&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        if (isGameOver || isLevelClear) {&#10;            delay(500)&#10;            showGameEndDialog = true&#10;        }&#10;    }&#10;&#10;    // --- Plane setup ---&#10;    var planeX by remember { mutableStateOf(screenWidthPx / 2 - 50f) }&#10;    val planeY = screenHeightPx - 250f&#10;    val planeWidth = 100f&#10;    val planeHeight = 100f&#10;&#10;    // --- Background ---&#10;    var bg1Y by remember { mutableStateOf(0f) }&#10;    var bg2Y by remember { mutableStateOf(-screenHeightPx) }&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bg1Y += 4f&#10;            bg2Y += 4f&#10;            if (bg1Y &gt;= screenHeightPx) bg1Y = bg2Y - screenHeightPx&#10;            if (bg2Y &gt;= screenHeightPx) bg2Y = bg1Y - screenHeightPx&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Invisible Monsters ---&#10;    val invisibleMonsters = remember {&#10;        List(12) {&#10;            InvisibleMonster(&#10;                x = Random.nextFloat() * (screenWidthPx - 100f),&#10;                y = mutableStateOf(-Random.nextInt(200, 3000).toFloat()),&#10;                speed = Random.nextFloat() * 1.5f + 1.5f,&#10;                hp = mutableStateOf(100),&#10;                invisibleDuration = 2000L, // Invisible for 2 seconds&#10;                visibleDuration = 1500L     // Visible for 1.5 seconds&#10;            )&#10;        }&#10;    }&#10;&#10;    // Track respawn times&#10;    val monsterRespawnTimes = remember { MutableList(invisibleMonsters.size) { 0L } }&#10;&#10;    val coins = remember {&#10;        List(6) {&#10;            BaseCoin(&#10;                x = Random.nextFloat() * (screenWidthPx - 50f),&#10;                y = mutableStateOf(-Random.nextInt(100, 600).toFloat()),&#10;                speed = Random.nextFloat() * 2f + 1f&#10;            )&#10;        }&#10;    }&#10;&#10;    val bullets = remember { mutableStateListOf&lt;Bullet&gt;() }&#10;    val bagCoins = remember { mutableStateListOf&lt;BagCoinDisplay&gt;() }&#10;    var chestItems by remember { mutableStateOf&lt;List&lt;ChestItem&gt;&gt;(emptyList()) }&#10;&#10;    // --- Load player data ---&#10;    LaunchedEffect(Unit) {&#10;        if (!playerName.isNullOrBlank()) {&#10;            FirebaseHelper.syncNewPlayer(playerName)&#10;            FirebaseHelper.getScore(playerName) { totalScore = it }&#10;            FirebaseHelper.getChestItems(playerName) { chestItems = it }&#10;        }&#10;    }&#10;&#10;    // --- Shooting ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.add(Bullet(planeX + planeWidth / 2f - 15f, planeY))&#10;            SoundManager.playSoundEffect(soundPool, shootSoundId, 0.5f)&#10;            delay(300)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.forEach { it.y -= 25f }&#10;            bullets.removeAll { it.y &lt; -50f }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Monster movement + invisible toggle ---&#10;    invisibleMonsters.forEachIndexed { index, m -&gt;&#10;        LaunchedEffect(m, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                // Check if monster needs to respawn&#10;                if (!m.alive.value &amp;&amp; System.currentTimeMillis() &gt;= monsterRespawnTimes[index]) {&#10;                    m.y.value = -Random.nextInt(200, 1500).toFloat()&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 100f)&#10;                    m.hp.value = 100&#10;                    m.alive.value = true&#10;                    m.lastToggleTime = System.currentTimeMillis()&#10;                    m.isVisible.value = Random.nextBoolean() // Random start state&#10;                }&#10;&#10;                if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp; !timeActive) {&#10;                    // Toggle visibility&#10;                    val currentTime = System.currentTimeMillis()&#10;                    val elapsed = currentTime - m.lastToggleTime&#10;                    val threshold = if (m.isVisible.value) m.visibleDuration else m.invisibleDuration&#10;&#10;                    if (elapsed &gt;= threshold) {&#10;                        m.isVisible.value = !m.isVisible.value&#10;                        m.lastToggleTime = currentTime&#10;                    }&#10;&#10;                    // Wall collision check&#10;                    val wallTop = planeY - 60f&#10;                    val monsterBottom = m.y.value + 80f&#10;&#10;                    if (wallActive &amp;&amp; monsterBottom &gt;= wallTop) {&#10;                        // Stop at wall&#10;                    } else {&#10;                        // Normal movement&#10;                        m.y.value += m.speed&#10;                    }&#10;&#10;                    // Zigzag movement&#10;                    m.x += m.horizontalSpeed * m.direction&#10;                    if (m.x &lt;= 0 || m.x &gt;= screenWidthPx - 100f) {&#10;                        m.direction *= -1&#10;                    }&#10;&#10;                    // If monster passes plane&#10;                    if (m.y.value &gt; planeY + planeHeight / 2f) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) planeHp -= 50&#10;                        monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 8000)&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;                delay(16)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Coin movement ---&#10;    coins.forEach { c -&gt;&#10;        LaunchedEffect(c, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                if (!c.collected.value &amp;&amp; !timeActive) {&#10;                    c.y.value += c.speed&#10;                    if (c.y.value &gt; screenHeightPx) {&#10;                        c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                        c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                    }&#10;                }&#10;                delay(32)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Bullet vs Monster collision (only when visible) ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            val iter = bullets.iterator()&#10;            while (iter.hasNext()) {&#10;                val b = iter.next()&#10;                invisibleMonsters.forEach { m -&gt;&#10;                    // Can only hit visible monsters&#10;                    if (m.isVisible.value &amp;&amp; CollisionUtils.checkCollisionBulletMonster(b, m)) {&#10;                        m.hp.value -= 25&#10;                        // Play hit sound&#10;                        SoundManager.playSoundEffect(soundPool, hitSoundId, 0.3f)&#10;                        iter.remove()&#10;                        if (m.hp.value &lt;= 0) {&#10;                            m.alive.value = false&#10;                            val index = invisibleMonsters.indexOf(m)&#10;                            if (index &gt;= 0) {&#10;                                monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 8000)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Coin collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            coins.forEach { c -&gt;&#10;                if (!c.collected.value &amp;&amp; CollisionUtils.checkCollisionPlaneCoin(planeX, planeY, planeWidth, planeHeight, c)) {&#10;                    c.collected.value = true&#10;                    totalScore += 1&#10;                    currentSessionScore += 1&#10;                    val bag = BagCoinDisplay(c.x, c.y.value, 1)&#10;                    bagCoins.add(bag)&#10;                    if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Monster collision (only when visible) ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            invisibleMonsters.forEach { m -&gt;&#10;                if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp; m.isVisible.value &amp;&amp;&#10;                    CollisionUtils.checkCollisionPlaneMonster(planeX, planeY, planeWidth, planeHeight, m)&#10;                ) {&#10;                    if (!shieldActive &amp;&amp; !wallActive) planeHp -= 50&#10;                    m.hp.value = 0&#10;                    m.alive.value = false&#10;                }&#10;            }&#10;            if (planeHp &lt;= 0) isGameOver = true&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Wall - Monster collision ---&#10;    LaunchedEffect(wallActive, isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            if (wallActive) {&#10;                invisibleMonsters.forEach { m -&gt;&#10;                    if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp; m.isVisible.value) {&#10;                        if (CollisionUtils.checkCollisionWallMonster(planeY, m)) {&#10;                            m.hp.value -= 2&#10;                            if (m.hp.value &lt;= 0) {&#10;                                m.alive.value = false&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Use chest item ---&#10;    fun useChestItem(item: ChestItem) {&#10;        ChestItemEffectsBase.applyItemEffect(&#10;            itemName = item.name,&#10;            monsters = invisibleMonsters,&#10;            coins = coins,&#10;            bagCoins = bagCoins,&#10;            coroutineScope = coroutineScope,&#10;            screenHeightPx = screenHeightPx,&#10;            planeX = planeX,&#10;            onScoreUpdate = { add -&gt;&#10;                totalScore += add&#10;                currentSessionScore += add&#10;                if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;            },&#10;            onShieldToggle = { active -&gt; shieldActive = active },&#10;            onWallToggle = { active -&gt; wallActive = active },&#10;            onTimeToggle = { active -&gt; timeActive = active },&#10;            onLevelClear = { isLevelClear = true }&#10;        )&#10;        chestItems = chestItems - item&#10;        if (!playerName.isNullOrBlank()) FirebaseHelper.updateChest(playerName, chestItems)&#10;    }&#10;&#10;    // --- Drag plane ---&#10;    val dragModifier = Modifier.pointerInput(Unit) {&#10;        detectDragGestures { change, dragAmount -&gt;&#10;            planeX = (planeX + dragAmount.x).coerceIn(0f, screenWidthPx - planeWidth)&#10;            change.consume()&#10;        }&#10;    }&#10;&#10;    // --- UI ---&#10;    Box(modifier = Modifier.fillMaxSize().then(dragModifier)) {&#10;        // Background&#10;        Image(&#10;            painter = painterResource(R.drawable.vutru1),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg1Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;        Image(&#10;            painter = painterResource(R.drawable.vutru1),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg2Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;&#10;        // Invisible Monsters (only show when visible)&#10;        invisibleMonsters.forEach { m -&gt;&#10;            if (m.isVisible.value) {&#10;                InvisibleMonsterUI(monster = m)&#10;            }&#10;        }&#10;&#10;        // Coins&#10;        coins.filter { !it.collected.value }.forEach { c -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.coin),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(c.x.roundToInt(), c.y.value.roundToInt()) }&#10;                    .size(40.dp)&#10;            )&#10;        }&#10;&#10;        // BagCoin animated views&#10;        bagCoins.toList().forEach { bag -&gt;&#10;            BagCoinAnimatedView(bag = bag, onFinished = { finishedBag -&gt;&#10;                bagCoins.remove(finishedBag)&#10;            })&#10;        }&#10;&#10;        // Bullets&#10;        bullets.forEach { b -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.dan2),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(b.x.roundToInt(), b.y.roundToInt()) }&#10;                    .size(30.dp)&#10;            )&#10;        }&#10;&#10;        // Plane&#10;        PlaneUI(&#10;            planeX = planeX,&#10;            planeY = planeY,&#10;            planeHp = planeHp,&#10;            shieldActive = shieldActive&#10;        )&#10;&#10;        // Wall&#10;        if (wallActive) {&#10;            WallUI(planeY = planeY)&#10;        }&#10;&#10;        // Top bar&#10;        TopBarUI(&#10;            bagCoinScore = totalScore,&#10;            chestItems = chestItems,&#10;            onBuyItem = { item, price -&gt;&#10;                if (totalScore &gt;= price) {&#10;                    totalScore -= price&#10;                    chestItems = chestItems + item&#10;                    if (!playerName.isNullOrBlank()) {&#10;                        FirebaseHelper.updateScore(playerName, totalScore)&#10;                        FirebaseHelper.updateChest(playerName, chestItems)&#10;                    }&#10;                }&#10;            },&#10;            onUseChestItem = { useChestItem(it) }&#10;        )&#10;&#10;        // --- Sound Control Button (top-right corner) ---&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp),&#10;            contentAlignment = androidx.compose.ui.Alignment.TopEnd&#10;        ) {&#10;            SoundControlButton()&#10;        }&#10;    }&#10;&#10;    // --- Game End Dialog ---&#10;    if (showGameEndDialog) {&#10;        GameEndDialog(&#10;            isWin = isLevelClear,&#10;            score = currentSessionScore,&#10;            level = 3,&#10;            onDismiss = {&#10;                showGameEndDialog = false&#10;            },&#10;            onReplay = {&#10;                // Reset game&#10;                showGameEndDialog = false&#10;                isGameOver = false&#10;                isLevelClear = false&#10;                planeHp = 100&#10;                currentSessionScore = 0&#10;&#10;                invisibleMonsters.forEachIndexed { index, m -&gt;&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 100f)&#10;                    m.y.value = -Random.nextInt(200, 3000).toFloat()&#10;                    m.hp.value = 100&#10;                    m.alive.value = true&#10;                    m.isVisible.value = Random.nextBoolean()&#10;                    m.lastToggleTime = System.currentTimeMillis()&#10;                    monsterRespawnTimes[index] = 0L&#10;                }&#10;&#10;                coins.forEach { c -&gt;&#10;                    c.collected.value = false&#10;                    c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                    c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                }&#10;&#10;                bullets.clear()&#10;            },&#10;            onNextLevel = {&#10;                onExit()&#10;            },&#10;            onExit = {&#10;                onExit()&#10;            }&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/game/Level4Activity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/game/Level4Activity.kt" />
              <option name="originalContent" value="package com.example.game&#10;&#10;import android.os.Bundle&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.TopBarComponent.TopBarUI&#10;import com.example.game.core.*&#10;import com.example.game.ui.PlaneUI&#10;import com.example.game.ui.WallUI&#10;import com.example.game.ui.GrowingMonsterUI&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.roundToInt&#10;import kotlin.random.Random&#10;&#10;class Level4Activity : BaseGameActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        initAudio()&#10;&#10;        setContent {&#10;            val density = LocalDensity.current&#10;            val screenWidthPx = with(density) { LocalConfiguration.current.screenWidthDp.dp.toPx() }&#10;            val screenHeightPx = with(density) { LocalConfiguration.current.screenHeightDp.dp.toPx() }&#10;&#10;            Level4Game(&#10;                screenWidthPx = screenWidthPx,&#10;                screenHeightPx = screenHeightPx,&#10;                soundPool = soundPool,&#10;                shootSoundId = shootSoundId,&#10;                onExit = { finish() }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Level4Game(&#10;    screenWidthPx: Float,&#10;    screenHeightPx: Float,&#10;    soundPool: android.media.SoundPool,&#10;    shootSoundId: Int,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val playerName = PrefManager.getPlayerName(context)&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // --- State ---&#10;    var totalScore by remember { mutableStateOf(0) }&#10;    var currentSessionScore by remember { mutableStateOf(0) }&#10;    var planeHp by remember { mutableStateOf(100) }&#10;&#10;    var shieldActive by remember { mutableStateOf(false) }&#10;    var wallActive by remember { mutableStateOf(false) }&#10;    var timeActive by remember { mutableStateOf(false) }&#10;&#10;    var isGameOver by remember { mutableStateOf(false) }&#10;    var isLevelClear by remember { mutableStateOf(false) }&#10;    var showGameEndDialog by remember { mutableStateOf(false) }&#10;&#10;    // Show dialog when game ends&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        if (isGameOver || isLevelClear) {&#10;            delay(500)&#10;            showGameEndDialog = true&#10;        }&#10;    }&#10;&#10;    // --- Plane setup ---&#10;    var planeX by remember { mutableStateOf(screenWidthPx / 2 - 50f) }&#10;    val planeY = screenHeightPx - 250f&#10;    val planeWidth = 100f&#10;    val planeHeight = 100f&#10;&#10;    // --- Background ---&#10;    var bg1Y by remember { mutableStateOf(0f) }&#10;    var bg2Y by remember { mutableStateOf(-screenHeightPx) }&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bg1Y += 4f&#10;            bg2Y += 4f&#10;            if (bg1Y &gt;= screenHeightPx) bg1Y = bg2Y - screenHeightPx&#10;            if (bg2Y &gt;= screenHeightPx) bg2Y = bg1Y - screenHeightPx&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Growing Monsters ---&#10;    val growingMonsters = remember {&#10;        List(10) {&#10;            GrowingMonster(&#10;                x = Random.nextFloat() * (screenWidthPx - 200f) + 100f,&#10;                y = mutableStateOf(-Random.nextInt(200, 2500).toFloat()),&#10;                speed = Random.nextFloat() * 1.2f + 1.0f,&#10;                hp = mutableStateOf(80),&#10;                initialSize = 60f,&#10;                maxSize = 600f, // Gấp 10 lần: 60 * 10 = 600&#10;                growthRate = 0.5f // Tăng tốc độ lớn lên để đạt 600px&#10;            )&#10;        }&#10;    }&#10;&#10;    // Track respawn times&#10;    val monsterRespawnTimes = remember { MutableList(growingMonsters.size) { 0L } }&#10;&#10;    val coins = remember {&#10;        List(6) {&#10;            BaseCoin(&#10;                x = Random.nextFloat() * (screenWidthPx - 50f),&#10;                y = mutableStateOf(-Random.nextInt(100, 600).toFloat()),&#10;                speed = Random.nextFloat() * 2f + 1f&#10;            )&#10;        }&#10;    }&#10;&#10;    val bullets = remember { mutableStateListOf&lt;Bullet&gt;() }&#10;    val bagCoins = remember { mutableStateListOf&lt;BagCoinDisplay&gt;() }&#10;    var chestItems by remember { mutableStateOf&lt;List&lt;ChestItem&gt;&gt;(emptyList()) }&#10;&#10;    // --- Load player data ---&#10;    LaunchedEffect(Unit) {&#10;        if (!playerName.isNullOrBlank()) {&#10;            FirebaseHelper.syncNewPlayer(playerName)&#10;            FirebaseHelper.getScore(playerName) { totalScore = it }&#10;            FirebaseHelper.getChestItems(playerName) { chestItems = it }&#10;        }&#10;    }&#10;&#10;    // --- Shooting ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.add(Bullet(planeX + planeWidth / 2f - 15f, planeY))&#10;            soundPool.play(shootSoundId, 0.5f, 0.5f, 1, 0, 1f)&#10;            delay(300)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.forEach { it.y -= 25f }&#10;            bullets.removeAll { it.y &lt; -50f }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Monster movement + growing ---&#10;    growingMonsters.forEachIndexed { index, m -&gt;&#10;        LaunchedEffect(m, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                // Check if monster needs to respawn&#10;                if (!m.alive.value &amp;&amp; System.currentTimeMillis() &gt;= monsterRespawnTimes[index]) {&#10;                    m.y.value = -Random.nextInt(200, 1500).toFloat()&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 200f) + 100f&#10;                    m.hp.value = 80&#10;                    m.maxHp = 80&#10;                    m.currentMaxHp.value = 80&#10;                    m.currentSize.value = m.initialSize&#10;                    m.alive.value = true&#10;                }&#10;&#10;                if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp; !timeActive) {&#10;                    // Grow over time&#10;                    m.grow()&#10;&#10;                    // Wall collision check&#10;                    val wallTop = planeY - 60f&#10;                    val monsterBottom = m.y.value + m.currentSize.value&#10;&#10;                    if (wallActive &amp;&amp; monsterBottom &gt;= wallTop) {&#10;                        // Stop at wall&#10;                    } else {&#10;                        // Normal movement&#10;                        m.y.value += m.speed&#10;                    }&#10;&#10;                    // If monster passes plane&#10;                    if (m.y.value &gt; planeY + planeHeight / 2f) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) {&#10;                            // Damage scales with monster size&#10;                            val damage = (30 * (m.currentSize.value / m.initialSize)).toInt()&#10;                            planeHp -= damage&#10;                        }&#10;                        monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 8000)&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;                delay(16)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Coin movement ---&#10;    coins.forEach { c -&gt;&#10;        LaunchedEffect(c, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                if (!c.collected.value &amp;&amp; !timeActive) {&#10;                    c.y.value += c.speed&#10;                    if (c.y.value &gt; screenHeightPx) {&#10;                        c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                        c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                    }&#10;                }&#10;                delay(32)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Bullet vs Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            val iter = bullets.iterator()&#10;            while (iter.hasNext()) {&#10;                val b = iter.next()&#10;                growingMonsters.forEach { m -&gt;&#10;                    if (m.alive.value &amp;&amp; m.hp.value &gt; 0) {&#10;                        // Collision detection with dynamic size&#10;                        val monsterLeft = m.x - (m.currentSize.value - 80f) / 2&#10;                        val monsterRight = monsterLeft + m.currentSize.value&#10;                        val monsterTop = m.y.value&#10;                        val monsterBottom = monsterTop + m.currentSize.value&#10;&#10;                        if (b.x &gt;= monsterLeft &amp;&amp; b.x &lt;= monsterRight &amp;&amp;&#10;                            b.y &gt;= monsterTop &amp;&amp; b.y &lt;= monsterBottom) {&#10;                            m.hp.value -= 75 // Tăng từ 25 lên 75 (x3 lần)&#10;                            iter.remove()&#10;                            if (m.hp.value &lt;= 0) {&#10;                                m.alive.value = false&#10;                                val index = growingMonsters.indexOf(m)&#10;                                if (index &gt;= 0) {&#10;                                    monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 8000)&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Coin collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            coins.forEach { c -&gt;&#10;                if (!c.collected.value &amp;&amp; CollisionUtils.checkCollisionPlaneCoin(planeX, planeY, planeWidth, planeHeight, c)) {&#10;                    c.collected.value = true&#10;                    totalScore += 1&#10;                    currentSessionScore += 1&#10;                    val bag = BagCoinDisplay(c.x, c.y.value, 1)&#10;                    bagCoins.add(bag)&#10;                    if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            growingMonsters.forEach { m -&gt;&#10;                if (m.alive.value &amp;&amp; m.hp.value &gt; 0) {&#10;                    val monsterLeft = m.x - (m.currentSize.value - 80f) / 2&#10;                    val monsterRight = monsterLeft + m.currentSize.value&#10;                    val monsterTop = m.y.value&#10;                    val monsterBottom = monsterTop + m.currentSize.value&#10;&#10;                    if (planeX + planeWidth &gt; monsterLeft &amp;&amp; planeX &lt; monsterRight &amp;&amp;&#10;                        planeY + planeHeight &gt; monsterTop &amp;&amp; planeY &lt; monsterBottom) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) {&#10;                            val damage = (30 * (m.currentSize.value / m.initialSize)).toInt()&#10;                            planeHp -= damage&#10;                        }&#10;                        m.hp.value = 0&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;            }&#10;            if (planeHp &lt;= 0) isGameOver = true&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Wall - Monster collision ---&#10;    LaunchedEffect(wallActive, isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            if (wallActive) {&#10;                growingMonsters.forEach { m -&gt;&#10;                    if (m.alive.value &amp;&amp; m.hp.value &gt; 0) {&#10;                        val wallTop = planeY - 60f&#10;                        val monsterBottom = m.y.value + m.currentSize.value&#10;                        if (monsterBottom &gt;= wallTop &amp;&amp; monsterBottom &lt;= wallTop + 10f) {&#10;                            m.hp.value -= 2&#10;                            if (m.hp.value &lt;= 0) {&#10;                                m.alive.value = false&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Use chest item ---&#10;    fun useChestItem(item: ChestItem) {&#10;        ChestItemEffectsBase.applyItemEffect(&#10;            itemName = item.name,&#10;            monsters = growingMonsters,&#10;            coins = coins,&#10;            bagCoins = bagCoins,&#10;            coroutineScope = coroutineScope,&#10;            screenHeightPx = screenHeightPx,&#10;            planeX = planeX,&#10;            onScoreUpdate = { add -&gt;&#10;                totalScore += add&#10;                currentSessionScore += add&#10;                if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;            },&#10;            onShieldToggle = { active -&gt; shieldActive = active },&#10;            onWallToggle = { active -&gt; wallActive = active },&#10;            onTimeToggle = { active -&gt; timeActive = active },&#10;            onLevelClear = { isLevelClear = true }&#10;        )&#10;        chestItems = chestItems - item&#10;        if (!playerName.isNullOrBlank()) FirebaseHelper.updateChest(playerName, chestItems)&#10;    }&#10;&#10;    // --- Drag plane ---&#10;    val dragModifier = Modifier.pointerInput(Unit) {&#10;        detectDragGestures { change, dragAmount -&gt;&#10;            planeX = (planeX + dragAmount.x).coerceIn(0f, screenWidthPx - planeWidth)&#10;            change.consume()&#10;        }&#10;    }&#10;&#10;    // --- UI ---&#10;    Box(modifier = Modifier.fillMaxSize().then(dragModifier)) {&#10;        // Background&#10;        Image(&#10;            painter = painterResource(R.drawable.vutru1),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg1Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;        Image(&#10;            painter = painterResource(R.drawable.vutru1),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg2Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;&#10;        // Growing Monsters&#10;        growingMonsters.forEach { m -&gt;&#10;            GrowingMonsterUI(monster = m)&#10;        }&#10;&#10;        // Coins&#10;        coins.filter { !it.collected.value }.forEach { c -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.coin),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(c.x.roundToInt(), c.y.value.roundToInt()) }&#10;                    .size(40.dp)&#10;            )&#10;        }&#10;&#10;        // BagCoin animated views&#10;        bagCoins.toList().forEach { bag -&gt;&#10;            BagCoinAnimatedView(bag = bag, onFinished = { finishedBag -&gt;&#10;                bagCoins.remove(finishedBag)&#10;            })&#10;        }&#10;&#10;        // Bullets&#10;        bullets.forEach { b -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.dan2),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(b.x.roundToInt(), b.y.roundToInt()) }&#10;                    .size(30.dp)&#10;            )&#10;        }&#10;&#10;        // Plane&#10;        PlaneUI(&#10;            planeX = planeX,&#10;            planeY = planeY,&#10;            planeHp = planeHp,&#10;            shieldActive = shieldActive&#10;        )&#10;&#10;        // Wall&#10;        if (wallActive) {&#10;            WallUI(planeY = planeY)&#10;        }&#10;&#10;        // Top bar&#10;        TopBarUI(&#10;            bagCoinScore = totalScore,&#10;            chestItems = chestItems,&#10;            onBuyItem = { item, price -&gt;&#10;                if (totalScore &gt;= price) {&#10;                    totalScore -= price&#10;                    chestItems = chestItems + item&#10;                    if (!playerName.isNullOrBlank()) {&#10;                        FirebaseHelper.updateScore(playerName, totalScore)&#10;                        FirebaseHelper.updateChest(playerName, chestItems)&#10;                    }&#10;                }&#10;            },&#10;            onUseChestItem = { useChestItem(it) }&#10;        )&#10;&#10;&#10;    // --- Game End Dialog ---&#10;    if (showGameEndDialog) {&#10;        GameEndDialog(&#10;            isWin = isLevelClear,&#10;            score = currentSessionScore,&#10;            level = 4,&#10;            onDismiss = {&#10;                showGameEndDialog = false&#10;            },&#10;            onReplay = {&#10;                // Reset game&#10;                showGameEndDialog = false&#10;                isGameOver = false&#10;                isLevelClear = false&#10;                planeHp = 100&#10;                currentSessionScore = 0&#10;&#10;                growingMonsters.forEachIndexed { index, m -&gt;&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 200f) + 100f&#10;                    m.y.value = -Random.nextInt(200, 2500).toFloat()&#10;                    m.hp.value = 80&#10;                    m.maxHp = 80&#10;                    m.currentMaxHp.value = 80&#10;                    m.currentSize.value = m.initialSize&#10;                    m.alive.value = true&#10;                    monsterRespawnTimes[index] = 0L&#10;                }&#10;&#10;                coins.forEach { c -&gt;&#10;                    c.collected.value = false&#10;                    c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                    c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                }&#10;&#10;                bullets.clear()&#10;            },&#10;            onNextLevel = {&#10;                onExit()&#10;            },&#10;            onExit = {&#10;                onExit()&#10;            }&#10;        )&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.game&#10;&#10;import android.os.Bundle&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.TopBarComponent.TopBarUI&#10;import com.example.game.core.*&#10;import com.example.game.ui.PlaneUI&#10;import com.example.game.ui.WallUI&#10;import com.example.game.ui.GrowingMonsterUI&#10;import com.example.game.ui.SoundControlButton&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.roundToInt&#10;import kotlin.random.Random&#10;&#10;class Level4Activity : BaseGameActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        initAudio()&#10;&#10;        setContent {&#10;            val density = LocalDensity.current&#10;            val screenWidthPx = with(density) { LocalConfiguration.current.screenWidthDp.dp.toPx() }&#10;            val screenHeightPx = with(density) { LocalConfiguration.current.screenHeightDp.dp.toPx() }&#10;&#10;            Level4Game(&#10;                screenWidthPx = screenWidthPx,&#10;                screenHeightPx = screenHeightPx,&#10;                soundPool = soundPool,&#10;                shootSoundId = shootSoundId,&#10;                hitSoundId = hitSoundId,&#10;                onExit = { finish() }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Level4Game(&#10;    screenWidthPx: Float,&#10;    screenHeightPx: Float,&#10;    soundPool: android.media.SoundPool,&#10;    shootSoundId: Int,&#10;    hitSoundId: Int,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val playerName = PrefManager.getPlayerName(context)&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // --- State ---&#10;    var totalScore by remember { mutableStateOf(0) }&#10;    var currentSessionScore by remember { mutableStateOf(0) }&#10;    var planeHp by remember { mutableStateOf(100) }&#10;&#10;    var shieldActive by remember { mutableStateOf(false) }&#10;    var wallActive by remember { mutableStateOf(false) }&#10;    var timeActive by remember { mutableStateOf(false) }&#10;&#10;    var isGameOver by remember { mutableStateOf(false) }&#10;    var isLevelClear by remember { mutableStateOf(false) }&#10;    var showGameEndDialog by remember { mutableStateOf(false) }&#10;&#10;    // Show dialog when game ends&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        if (isGameOver || isLevelClear) {&#10;            delay(500)&#10;            showGameEndDialog = true&#10;        }&#10;    }&#10;&#10;    // --- Plane setup ---&#10;    var planeX by remember { mutableStateOf(screenWidthPx / 2 - 50f) }&#10;    val planeY = screenHeightPx - 250f&#10;    val planeWidth = 100f&#10;    val planeHeight = 100f&#10;&#10;    // --- Background ---&#10;    var bg1Y by remember { mutableStateOf(0f) }&#10;    var bg2Y by remember { mutableStateOf(-screenHeightPx) }&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bg1Y += 4f&#10;            bg2Y += 4f&#10;            if (bg1Y &gt;= screenHeightPx) bg1Y = bg2Y - screenHeightPx&#10;            if (bg2Y &gt;= screenHeightPx) bg2Y = bg1Y - screenHeightPx&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Growing Monsters ---&#10;    val growingMonsters = remember {&#10;        List(10) {&#10;            GrowingMonster(&#10;                x = Random.nextFloat() * (screenWidthPx - 200f) + 100f,&#10;                y = mutableStateOf(-Random.nextInt(200, 2500).toFloat()),&#10;                speed = Random.nextFloat() * 1.2f + 1.0f,&#10;                hp = mutableStateOf(80),&#10;                initialSize = 60f,&#10;                maxSize = 600f, // Gấp 10 lần: 60 * 10 = 600&#10;                growthRate = 0.5f // Tăng tốc độ lớn lên để đạt 600px&#10;            )&#10;        }&#10;    }&#10;&#10;    // Track respawn times&#10;    val monsterRespawnTimes = remember { MutableList(growingMonsters.size) { 0L } }&#10;&#10;    val coins = remember {&#10;        List(6) {&#10;            BaseCoin(&#10;                x = Random.nextFloat() * (screenWidthPx - 50f),&#10;                y = mutableStateOf(-Random.nextInt(100, 600).toFloat()),&#10;                speed = Random.nextFloat() * 2f + 1f&#10;            )&#10;        }&#10;    }&#10;&#10;    val bullets = remember { mutableStateListOf&lt;Bullet&gt;() }&#10;    val bagCoins = remember { mutableStateListOf&lt;BagCoinDisplay&gt;() }&#10;    var chestItems by remember { mutableStateOf&lt;List&lt;ChestItem&gt;&gt;(emptyList()) }&#10;&#10;    // --- Load player data ---&#10;    LaunchedEffect(Unit) {&#10;        if (!playerName.isNullOrBlank()) {&#10;            FirebaseHelper.syncNewPlayer(playerName)&#10;            FirebaseHelper.getScore(playerName) { totalScore = it }&#10;            FirebaseHelper.getChestItems(playerName) { chestItems = it }&#10;        }&#10;    }&#10;&#10;    // --- Shooting ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.add(Bullet(planeX + planeWidth / 2f - 15f, planeY))&#10;            SoundManager.playSoundEffect(soundPool, shootSoundId, 0.5f)&#10;            delay(300)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.forEach { it.y -= 25f }&#10;            bullets.removeAll { it.y &lt; -50f }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Monster movement + growing ---&#10;    growingMonsters.forEachIndexed { index, m -&gt;&#10;        LaunchedEffect(m, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                // Check if monster needs to respawn&#10;                if (!m.alive.value &amp;&amp; System.currentTimeMillis() &gt;= monsterRespawnTimes[index]) {&#10;                    m.y.value = -Random.nextInt(200, 1500).toFloat()&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 200f) + 100f&#10;                    m.hp.value = 80&#10;                    m.maxHp = 80&#10;                    m.currentMaxHp.value = 80&#10;                    m.currentSize.value = m.initialSize&#10;                    m.alive.value = true&#10;                }&#10;&#10;                if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp; !timeActive) {&#10;                    // Grow over time&#10;                    m.grow()&#10;&#10;                    // Wall collision check&#10;                    val wallTop = planeY - 60f&#10;                    val monsterBottom = m.y.value + m.currentSize.value&#10;&#10;                    if (wallActive &amp;&amp; monsterBottom &gt;= wallTop) {&#10;                        // Stop at wall&#10;                    } else {&#10;                        // Normal movement&#10;                        m.y.value += m.speed&#10;                    }&#10;&#10;                    // If monster passes plane&#10;                    if (m.y.value &gt; planeY + planeHeight / 2f) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) {&#10;                            // Damage scales with monster size&#10;                            val damage = (30 * (m.currentSize.value / m.initialSize)).toInt()&#10;                            planeHp -= damage&#10;                        }&#10;                        monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 8000)&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;                delay(16)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Coin movement ---&#10;    coins.forEach { c -&gt;&#10;        LaunchedEffect(c, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                if (!c.collected.value &amp;&amp; !timeActive) {&#10;                    c.y.value += c.speed&#10;                    if (c.y.value &gt; screenHeightPx) {&#10;                        c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                        c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                    }&#10;                }&#10;                delay(32)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Bullet vs Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            val iter = bullets.iterator()&#10;            while (iter.hasNext()) {&#10;                val b = iter.next()&#10;                growingMonsters.forEach { m -&gt;&#10;                    if (m.alive.value &amp;&amp; m.hp.value &gt; 0) {&#10;                        // Collision detection with dynamic size&#10;                        val monsterLeft = m.x - (m.currentSize.value - 80f) / 2&#10;                        val monsterRight = monsterLeft + m.currentSize.value&#10;                        val monsterTop = m.y.value&#10;                        val monsterBottom = monsterTop + m.currentSize.value&#10;&#10;                        if (b.x &gt;= monsterLeft &amp;&amp; b.x &lt;= monsterRight &amp;&amp;&#10;                            b.y &gt;= monsterTop &amp;&amp; b.y &lt;= monsterBottom) {&#10;                            m.hp.value -= 75 // Tăng từ 25 lên 75 (x3 lần)&#10;                            // Play hit sound&#10;                            SoundManager.playSoundEffect(soundPool, hitSoundId, 0.3f)&#10;                            iter.remove()&#10;                            if (m.hp.value &lt;= 0) {&#10;                                m.alive.value = false&#10;                                val index = growingMonsters.indexOf(m)&#10;                                if (index &gt;= 0) {&#10;                                    monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 8000)&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Coin collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            coins.forEach { c -&gt;&#10;                if (!c.collected.value &amp;&amp; CollisionUtils.checkCollisionPlaneCoin(planeX, planeY, planeWidth, planeHeight, c)) {&#10;                    c.collected.value = true&#10;                    totalScore += 1&#10;                    currentSessionScore += 1&#10;                    val bag = BagCoinDisplay(c.x, c.y.value, 1)&#10;                    bagCoins.add(bag)&#10;                    if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            growingMonsters.forEach { m -&gt;&#10;                if (m.alive.value &amp;&amp; m.hp.value &gt; 0) {&#10;                    val monsterLeft = m.x - (m.currentSize.value - 80f) / 2&#10;                    val monsterRight = monsterLeft + m.currentSize.value&#10;                    val monsterTop = m.y.value&#10;                    val monsterBottom = monsterTop + m.currentSize.value&#10;&#10;                    if (planeX + planeWidth &gt; monsterLeft &amp;&amp; planeX &lt; monsterRight &amp;&amp;&#10;                        planeY + planeHeight &gt; monsterTop &amp;&amp; planeY &lt; monsterBottom) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) {&#10;                            val damage = (30 * (m.currentSize.value / m.initialSize)).toInt()&#10;                            planeHp -= damage&#10;                        }&#10;                        m.hp.value = 0&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;            }&#10;            if (planeHp &lt;= 0) isGameOver = true&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Wall - Monster collision ---&#10;    LaunchedEffect(wallActive, isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            if (wallActive) {&#10;                growingMonsters.forEach { m -&gt;&#10;                    if (m.alive.value &amp;&amp; m.hp.value &gt; 0) {&#10;                        val wallTop = planeY - 60f&#10;                        val monsterBottom = m.y.value + m.currentSize.value&#10;                        if (monsterBottom &gt;= wallTop &amp;&amp; monsterBottom &lt;= wallTop + 10f) {&#10;                            m.hp.value -= 2&#10;                            if (m.hp.value &lt;= 0) {&#10;                                m.alive.value = false&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Use chest item ---&#10;    fun useChestItem(item: ChestItem) {&#10;        ChestItemEffectsBase.applyItemEffect(&#10;            itemName = item.name,&#10;            monsters = growingMonsters,&#10;            coins = coins,&#10;            bagCoins = bagCoins,&#10;            coroutineScope = coroutineScope,&#10;            screenHeightPx = screenHeightPx,&#10;            planeX = planeX,&#10;            onScoreUpdate = { add -&gt;&#10;                totalScore += add&#10;                currentSessionScore += add&#10;                if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;            },&#10;            onShieldToggle = { active -&gt; shieldActive = active },&#10;            onWallToggle = { active -&gt; wallActive = active },&#10;            onTimeToggle = { active -&gt; timeActive = active },&#10;            onLevelClear = { isLevelClear = true }&#10;        )&#10;        chestItems = chestItems - item&#10;        if (!playerName.isNullOrBlank()) FirebaseHelper.updateChest(playerName, chestItems)&#10;    }&#10;&#10;    // --- Drag plane ---&#10;    val dragModifier = Modifier.pointerInput(Unit) {&#10;        detectDragGestures { change, dragAmount -&gt;&#10;            planeX = (planeX + dragAmount.x).coerceIn(0f, screenWidthPx - planeWidth)&#10;            change.consume()&#10;        }&#10;    }&#10;&#10;    // --- UI ---&#10;    Box(modifier = Modifier.fillMaxSize().then(dragModifier)) {&#10;        // Background&#10;        Image(&#10;            painter = painterResource(R.drawable.vutru1),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg1Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;        Image(&#10;            painter = painterResource(R.drawable.vutru1),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg2Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;&#10;        // Growing Monsters&#10;        growingMonsters.forEach { m -&gt;&#10;            GrowingMonsterUI(monster = m)&#10;        }&#10;&#10;        // Coins&#10;        coins.filter { !it.collected.value }.forEach { c -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.coin),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(c.x.roundToInt(), c.y.value.roundToInt()) }&#10;                    .size(40.dp)&#10;            )&#10;        }&#10;&#10;        // BagCoin animated views&#10;        bagCoins.toList().forEach { bag -&gt;&#10;            BagCoinAnimatedView(bag = bag, onFinished = { finishedBag -&gt;&#10;                bagCoins.remove(finishedBag)&#10;            })&#10;        }&#10;&#10;        // Bullets&#10;        bullets.forEach { b -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.dan2),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(b.x.roundToInt(), b.y.roundToInt()) }&#10;                    .size(30.dp)&#10;            )&#10;        }&#10;&#10;        // Plane&#10;        PlaneUI(&#10;            planeX = planeX,&#10;            planeY = planeY,&#10;            planeHp = planeHp,&#10;            shieldActive = shieldActive&#10;        )&#10;&#10;        // Wall&#10;        if (wallActive) {&#10;            WallUI(planeY = planeY)&#10;        }&#10;&#10;        // Top bar&#10;        TopBarUI(&#10;            bagCoinScore = totalScore,&#10;            chestItems = chestItems,&#10;            onBuyItem = { item, price -&gt;&#10;                if (totalScore &gt;= price) {&#10;                    totalScore -= price&#10;                    chestItems = chestItems + item&#10;                    if (!playerName.isNullOrBlank()) {&#10;                        FirebaseHelper.updateScore(playerName, totalScore)&#10;                        FirebaseHelper.updateChest(playerName, chestItems)&#10;                    }&#10;                }&#10;            },&#10;            onUseChestItem = { useChestItem(it) }&#10;        )&#10;&#10;        // --- Sound Control Button (top-right corner) ---&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp),&#10;            contentAlignment = androidx.compose.ui.Alignment.TopEnd&#10;        ) {&#10;            SoundControlButton()&#10;        }&#10;    }&#10;&#10;    // --- Game End Dialog ---&#10;    if (showGameEndDialog) {&#10;        GameEndDialog(&#10;            isWin = isLevelClear,&#10;            score = currentSessionScore,&#10;            level = 4,&#10;            onDismiss = {&#10;                showGameEndDialog = false&#10;            },&#10;            onReplay = {&#10;                // Reset game&#10;                showGameEndDialog = false&#10;                isGameOver = false&#10;                isLevelClear = false&#10;                planeHp = 100&#10;                currentSessionScore = 0&#10;&#10;                growingMonsters.forEachIndexed { index, m -&gt;&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 200f) + 100f&#10;                    m.y.value = -Random.nextInt(200, 2500).toFloat()&#10;                    m.hp.value = 80&#10;                    m.maxHp = 80&#10;                    m.currentMaxHp.value = 80&#10;                    m.currentSize.value = m.initialSize&#10;                    m.alive.value = true&#10;                    monsterRespawnTimes[index] = 0L&#10;                }&#10;&#10;                coins.forEach { c -&gt;&#10;                    c.collected.value = false&#10;                    c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                    c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                }&#10;&#10;                bullets.clear()&#10;            },&#10;            onNextLevel = {&#10;                onExit()&#10;            },&#10;            onExit = {&#10;                onExit()&#10;            }&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/game/Level5Activity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/game/Level5Activity.kt" />
              <option name="originalContent" value="package com.example.game&#10;&#10;import android.os.Bundle&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.TopBarComponent.TopBarUI&#10;import com.example.game.core.*&#10;import com.example.game.ui.PlaneUI&#10;import com.example.game.ui.WallUI&#10;import com.example.game.ui.SplittingMonsterUI&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.roundToInt&#10;import kotlin.random.Random&#10;&#10;class Level5Activity : BaseGameActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        initAudio()&#10;&#10;        setContent {&#10;            val density = LocalDensity.current&#10;            val screenWidthPx = with(density) { LocalConfiguration.current.screenWidthDp.dp.toPx() }&#10;            val screenHeightPx = with(density) { LocalConfiguration.current.screenHeightDp.dp.toPx() }&#10;&#10;            Level5Game(&#10;                screenWidthPx = screenWidthPx,&#10;                screenHeightPx = screenHeightPx,&#10;                soundPool = soundPool,&#10;                shootSoundId = shootSoundId,&#10;                onExit = { finish() }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Level5Game(&#10;    screenWidthPx: Float,&#10;    screenHeightPx: Float,&#10;    soundPool: android.media.SoundPool,&#10;    shootSoundId: Int,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val playerName = PrefManager.getPlayerName(context)&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // --- State ---&#10;    var totalScore by remember { mutableStateOf(0) }&#10;    var currentSessionScore by remember { mutableStateOf(0) }&#10;    var planeHp by remember { mutableStateOf(100) }&#10;&#10;    var shieldActive by remember { mutableStateOf(false) }&#10;    var wallActive by remember { mutableStateOf(false) }&#10;    var timeActive by remember { mutableStateOf(false) }&#10;&#10;    var isGameOver by remember { mutableStateOf(false) }&#10;    var isLevelClear by remember { mutableStateOf(false) }&#10;    var showGameEndDialog by remember { mutableStateOf(false) }&#10;&#10;    // Show dialog when game ends&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        if (isGameOver || isLevelClear) {&#10;            delay(500)&#10;            showGameEndDialog = true&#10;        }&#10;    }&#10;&#10;    // --- Plane setup ---&#10;    var planeX by remember { mutableStateOf(screenWidthPx / 2 - 50f) }&#10;    val planeY = screenHeightPx - 250f&#10;    val planeWidth = 100f&#10;    val planeHeight = 100f&#10;&#10;    // --- Background ---&#10;    var bg1Y by remember { mutableStateOf(0f) }&#10;    var bg2Y by remember { mutableStateOf(-screenHeightPx) }&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bg1Y += 4f&#10;            bg2Y += 4f&#10;            if (bg1Y &gt;= screenHeightPx) bg1Y = bg2Y - screenHeightPx&#10;            if (bg2Y &gt;= screenHeightPx) bg2Y = bg1Y - screenHeightPx&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Splitting Monsters (dynamic list) ---&#10;    val splittingMonsters = remember { mutableStateListOf&lt;SplittingMonster&gt;() }&#10;&#10;    // Initialize with some parent monsters&#10;    LaunchedEffect(Unit) {&#10;        repeat(8) {&#10;            splittingMonsters.add(&#10;                SplittingMonster(&#10;                    x = Random.nextFloat() * (screenWidthPx - 80f),&#10;                    y = mutableStateOf(-Random.nextInt(200, 2000).toFloat()),&#10;                    speed = Random.nextFloat() * 1.5f + 1.5f,&#10;                    hp = mutableStateOf(100),&#10;                    size = 80f,&#10;                    generation = 1&#10;                )&#10;            )&#10;        }&#10;    }&#10;&#10;    val coins = remember {&#10;        List(6) {&#10;            BaseCoin(&#10;                x = Random.nextFloat() * (screenWidthPx - 50f),&#10;                y = mutableStateOf(-Random.nextInt(100, 600).toFloat()),&#10;                speed = Random.nextFloat() * 2f + 1f&#10;            )&#10;        }&#10;    }&#10;&#10;    val bullets = remember { mutableStateListOf&lt;Bullet&gt;() }&#10;    val bagCoins = remember { mutableStateListOf&lt;BagCoinDisplay&gt;() }&#10;    var chestItems by remember { mutableStateOf&lt;List&lt;ChestItem&gt;&gt;(emptyList()) }&#10;&#10;    // --- Load player data ---&#10;    LaunchedEffect(Unit) {&#10;        if (!playerName.isNullOrBlank()) {&#10;            FirebaseHelper.syncNewPlayer(playerName)&#10;            FirebaseHelper.getScore(playerName) { totalScore = it }&#10;            FirebaseHelper.getChestItems(playerName) { chestItems = it }&#10;        }&#10;    }&#10;&#10;    // --- Shooting ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.add(Bullet(planeX + planeWidth / 2f - 15f, planeY))&#10;            soundPool.play(shootSoundId, 0.5f, 0.5f, 1, 0, 1f)&#10;            delay(300)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.forEach { it.y -= 25f }&#10;            bullets.removeAll { it.y &lt; -50f }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Monster movement (zigzag or bounce) ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            // Create a snapshot to avoid concurrent modification&#10;            val currentMonsters = splittingMonsters.toList()&#10;            currentMonsters.forEach { m -&gt;&#10;                if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp; !timeActive) {&#10;                    if (m.isZigzagMovement) {&#10;                        // Zigzag movement&#10;                        m.x += m.horizontalSpeed * m.direction&#10;                        if (m.x &lt;= 0 || m.x &gt;= screenWidthPx - m.size) {&#10;                            m.direction *= -1&#10;                        }&#10;                        m.y.value += m.speed&#10;                    } else {&#10;                        // Bounce movement&#10;                        m.x += m.velocityX&#10;                        m.y.value += m.velocityY&#10;&#10;                        // Bounce off walls&#10;                        if (m.x &lt;= 0 || m.x &gt;= screenWidthPx - m.size) {&#10;                            m.velocityX *= -1&#10;                            m.x = m.x.coerceIn(0f, screenWidthPx - m.size)&#10;                        }&#10;&#10;                        // Bounce off top (optional)&#10;                        if (m.y.value &lt;= 0) {&#10;                            m.velocityY *= -1&#10;                            m.y.value = 0f&#10;                        }&#10;                    }&#10;&#10;                    // Wall collision check&#10;                    val wallTop = planeY - 60f&#10;                    val monsterBottom = m.y.value + m.size&#10;&#10;                    if (wallActive &amp;&amp; monsterBottom &gt;= wallTop) {&#10;                        // Bounce back from wall&#10;                        if (!m.isZigzagMovement) {&#10;                            m.velocityY *= -1&#10;                        }&#10;                    }&#10;&#10;                    // If monster passes plane&#10;                    if (m.y.value &gt; planeY + planeHeight / 2f) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) {&#10;                            val damage = when(m.generation) {&#10;                                1 -&gt; 50 // Large&#10;                                2 -&gt; 30 // Medium&#10;                                else -&gt; 20 // Small&#10;                            }&#10;                            planeHp -= damage&#10;                        }&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Remove dead monsters (but spawn children first)&#10;            splittingMonsters.removeAll { !it.alive.value &amp;&amp; it.hasSpawned.value }&#10;&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Split monsters when killed ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            // Create a snapshot to avoid concurrent modification&#10;            val currentMonsters = splittingMonsters.toList()&#10;            currentMonsters.forEach { m -&gt;&#10;                if (!m.alive.value &amp;&amp; m.canSplit &amp;&amp; !m.hasSpawned.value) {&#10;                    m.hasSpawned.value = true&#10;&#10;                    // Spawn 2-3 smaller monsters&#10;                    val childCount = Random.nextInt(2, 4) // 2 or 3&#10;                    val newSize = m.size * 0.6f // 60% of parent size&#10;                    val newGeneration = m.generation + 1&#10;&#10;                    repeat(childCount) {&#10;                        splittingMonsters.add(&#10;                            SplittingMonster(&#10;                                x = m.x + Random.nextFloat() * 20f - 10f,&#10;                                y = mutableStateOf(m.y.value),&#10;                                speed = m.speed * 1.2f,&#10;                                hp = mutableStateOf(60),&#10;                                size = newSize,&#10;                                generation = newGeneration&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Coin movement ---&#10;    coins.forEach { c -&gt;&#10;        LaunchedEffect(c, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                if (!c.collected.value &amp;&amp; !timeActive) {&#10;                    c.y.value += c.speed&#10;                    if (c.y.value &gt; screenHeightPx) {&#10;                        c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                        c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                    }&#10;                }&#10;                delay(32)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Bullet vs Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            val iter = bullets.iterator()&#10;            while (iter.hasNext()) {&#10;                val b = iter.next()&#10;                // Create snapshot to avoid concurrent modification&#10;                val currentMonsters = splittingMonsters.toList()&#10;                var bulletRemoved = false&#10;                currentMonsters.forEach { m -&gt;&#10;                    if (!bulletRemoved &amp;&amp; m.alive.value &amp;&amp; m.hp.value &gt; 0) {&#10;                        if (b.x &gt;= m.x &amp;&amp; b.x &lt;= m.x + m.size &amp;&amp;&#10;                            b.y &gt;= m.y.value &amp;&amp; b.y &lt;= m.y.value + m.size) {&#10;                            m.hp.value -= 25&#10;                            bulletRemoved = true&#10;                            if (m.hp.value &lt;= 0) {&#10;                                m.alive.value = false&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;                if (bulletRemoved) {&#10;                    iter.remove()&#10;                }&#10;            }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Coin collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            coins.forEach { c -&gt;&#10;                if (!c.collected.value &amp;&amp; CollisionUtils.checkCollisionPlaneCoin(planeX, planeY, planeWidth, planeHeight, c)) {&#10;                    c.collected.value = true&#10;                    totalScore += 1&#10;                    currentSessionScore += 1&#10;                    val bag = BagCoinDisplay(c.x, c.y.value, 1)&#10;                    bagCoins.add(bag)&#10;                    if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            // Create snapshot to avoid concurrent modification&#10;            val currentMonsters = splittingMonsters.toList()&#10;            currentMonsters.forEach { m -&gt;&#10;                if (m.alive.value &amp;&amp; m.hp.value &gt; 0) {&#10;                    if (planeX + planeWidth &gt; m.x &amp;&amp; planeX &lt; m.x + m.size &amp;&amp;&#10;                        planeY + planeHeight &gt; m.y.value &amp;&amp; planeY &lt; m.y.value + m.size) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) {&#10;                            val damage = when(m.generation) {&#10;                                1 -&gt; 50&#10;                                2 -&gt; 30&#10;                                else -&gt; 20&#10;                            }&#10;                            planeHp -= damage&#10;                        }&#10;                        m.hp.value = 0&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;            }&#10;            if (planeHp &lt;= 0) isGameOver = true&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Wall - Monster collision ---&#10;    LaunchedEffect(wallActive, isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            if (wallActive) {&#10;                // Create snapshot to avoid concurrent modification&#10;                val currentMonsters = splittingMonsters.toList()&#10;                currentMonsters.forEach { m -&gt;&#10;                    if (m.alive.value &amp;&amp; m.hp.value &gt; 0) {&#10;                        val wallTop = planeY - 60f&#10;                        val monsterBottom = m.y.value + m.size&#10;                        if (monsterBottom &gt;= wallTop &amp;&amp; monsterBottom &lt;= wallTop + 10f) {&#10;                            m.hp.value -= 2&#10;                            if (m.hp.value &lt;= 0) {&#10;                                m.alive.value = false&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Use chest item ---&#10;    fun useChestItem(item: ChestItem) {&#10;        ChestItemEffectsBase.applyItemEffect(&#10;            itemName = item.name,&#10;            monsters = splittingMonsters,&#10;            coins = coins,&#10;            bagCoins = bagCoins,&#10;            coroutineScope = coroutineScope,&#10;            screenHeightPx = screenHeightPx,&#10;            planeX = planeX,&#10;            onScoreUpdate = { add -&gt;&#10;                totalScore += add&#10;                currentSessionScore += add&#10;                if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;            },&#10;            onShieldToggle = { active -&gt; shieldActive = active },&#10;            onWallToggle = { active -&gt; wallActive = active },&#10;            onTimeToggle = { active -&gt; timeActive = active },&#10;            onLevelClear = { isLevelClear = true }&#10;        )&#10;        chestItems = chestItems - item&#10;        if (!playerName.isNullOrBlank()) FirebaseHelper.updateChest(playerName, chestItems)&#10;    }&#10;&#10;    // --- Drag plane ---&#10;    val dragModifier = Modifier.pointerInput(Unit) {&#10;        detectDragGestures { change, dragAmount -&gt;&#10;            planeX = (planeX + dragAmount.x).coerceIn(0f, screenWidthPx - planeWidth)&#10;            change.consume()&#10;        }&#10;    }&#10;&#10;    // --- UI ---&#10;    Box(modifier = Modifier.fillMaxSize().then(dragModifier)) {&#10;        // Background&#10;        Image(&#10;            painter = painterResource(R.drawable.vutru1),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg1Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;        Image(&#10;            painter = painterResource(R.drawable.vutru1),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg2Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;&#10;        // Splitting Monsters&#10;        splittingMonsters.forEach { m -&gt;&#10;            SplittingMonsterUI(monster = m)&#10;        }&#10;&#10;        // Coins&#10;        coins.filter { !it.collected.value }.forEach { c -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.coin),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(c.x.roundToInt(), c.y.value.roundToInt()) }&#10;                    .size(40.dp)&#10;            )&#10;        }&#10;&#10;        // BagCoin animated views&#10;        bagCoins.toList().forEach { bag -&gt;&#10;            BagCoinAnimatedView(bag = bag, onFinished = { finishedBag -&gt;&#10;                bagCoins.remove(finishedBag)&#10;            })&#10;        }&#10;&#10;        // Bullets&#10;        bullets.forEach { b -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.dan2),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(b.x.roundToInt(), b.y.roundToInt()) }&#10;                    .size(30.dp)&#10;            )&#10;        }&#10;&#10;        // Plane&#10;        PlaneUI(&#10;            planeX = planeX,&#10;            planeY = planeY,&#10;            planeHp = planeHp,&#10;            shieldActive = shieldActive&#10;        )&#10;&#10;        // Wall&#10;        if (wallActive) {&#10;            WallUI(planeY = planeY)&#10;        }&#10;&#10;        // Top bar&#10;        TopBarUI(&#10;            bagCoinScore = totalScore,&#10;            chestItems = chestItems,&#10;            onBuyItem = { item, price -&gt;&#10;                if (totalScore &gt;= price) {&#10;                    totalScore -= price&#10;                    chestItems = chestItems + item&#10;                    if (!playerName.isNullOrBlank()) {&#10;                        FirebaseHelper.updateScore(playerName, totalScore)&#10;                        FirebaseHelper.updateChest(playerName, chestItems)&#10;                    }&#10;                }&#10;            },&#10;            onUseChestItem = { useChestItem(it) }&#10;        )&#10;    }&#10;&#10;    // --- Game End Dialog ---&#10;    if (showGameEndDialog) {&#10;        GameEndDialog(&#10;            isWin = isLevelClear,&#10;            score = currentSessionScore,&#10;            level = 5,&#10;            onDismiss = {&#10;                showGameEndDialog = false&#10;            },&#10;            onReplay = {&#10;                showGameEndDialog = false&#10;                isGameOver = false&#10;                isLevelClear = false&#10;                planeHp = 100&#10;                currentSessionScore = 0&#10;&#10;                splittingMonsters.clear()&#10;                repeat(8) {&#10;                    splittingMonsters.add(&#10;                        SplittingMonster(&#10;                            x = Random.nextFloat() * (screenWidthPx - 80f),&#10;                            y = mutableStateOf(-Random.nextInt(200, 2000).toFloat()),&#10;                            speed = Random.nextFloat() * 1.5f + 1.5f,&#10;                            hp = mutableStateOf(100),&#10;                            size = 80f,&#10;                            generation = 1&#10;                        )&#10;                    )&#10;                }&#10;&#10;                coins.forEach { c -&gt;&#10;                    c.collected.value = false&#10;                    c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                    c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                }&#10;&#10;                bullets.clear()&#10;            },&#10;            onNextLevel = {&#10;                onExit()&#10;            },&#10;            onExit = {&#10;                onExit()&#10;            }&#10;        )&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.game&#10;&#10;import android.os.Bundle&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.TopBarComponent.TopBarUI&#10;import com.example.game.core.*&#10;import com.example.game.ui.PlaneUI&#10;import com.example.game.ui.WallUI&#10;import com.example.game.ui.SplittingMonsterUI&#10;import com.example.game.ui.SoundControlButton&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.roundToInt&#10;import kotlin.random.Random&#10;&#10;class Level5Activity : BaseGameActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        initAudio()&#10;&#10;        setContent {&#10;            val density = LocalDensity.current&#10;            val screenWidthPx = with(density) { LocalConfiguration.current.screenWidthDp.dp.toPx() }&#10;            val screenHeightPx = with(density) { LocalConfiguration.current.screenHeightDp.dp.toPx() }&#10;&#10;            Level5Game(&#10;                screenWidthPx = screenWidthPx,&#10;                screenHeightPx = screenHeightPx,&#10;                soundPool = soundPool,&#10;                shootSoundId = shootSoundId,&#10;                hitSoundId = hitSoundId,&#10;                onExit = { finish() }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Level5Game(&#10;    screenWidthPx: Float,&#10;    screenHeightPx: Float,&#10;    soundPool: android.media.SoundPool,&#10;    shootSoundId: Int,&#10;    hitSoundId: Int,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val playerName = PrefManager.getPlayerName(context)&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // --- State ---&#10;    var totalScore by remember { mutableStateOf(0) }&#10;    var currentSessionScore by remember { mutableStateOf(0) }&#10;    var planeHp by remember { mutableStateOf(100) }&#10;&#10;    var shieldActive by remember { mutableStateOf(false) }&#10;    var wallActive by remember { mutableStateOf(false) }&#10;    var timeActive by remember { mutableStateOf(false) }&#10;&#10;    var isGameOver by remember { mutableStateOf(false) }&#10;    var isLevelClear by remember { mutableStateOf(false) }&#10;    var showGameEndDialog by remember { mutableStateOf(false) }&#10;&#10;    // Show dialog when game ends&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        if (isGameOver || isLevelClear) {&#10;            delay(500)&#10;            showGameEndDialog = true&#10;        }&#10;    }&#10;&#10;    // --- Plane setup ---&#10;    var planeX by remember { mutableStateOf(screenWidthPx / 2 - 50f) }&#10;    val planeY = screenHeightPx - 250f&#10;    val planeWidth = 100f&#10;    val planeHeight = 100f&#10;&#10;    // --- Background ---&#10;    var bg1Y by remember { mutableStateOf(0f) }&#10;    var bg2Y by remember { mutableStateOf(-screenHeightPx) }&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bg1Y += 4f&#10;            bg2Y += 4f&#10;            if (bg1Y &gt;= screenHeightPx) bg1Y = bg2Y - screenHeightPx&#10;            if (bg2Y &gt;= screenHeightPx) bg2Y = bg1Y - screenHeightPx&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Splitting Monsters (dynamic list) ---&#10;    val splittingMonsters = remember { mutableStateListOf&lt;SplittingMonster&gt;() }&#10;&#10;    // Initialize with some parent monsters&#10;    LaunchedEffect(Unit) {&#10;        repeat(8) {&#10;            splittingMonsters.add(&#10;                SplittingMonster(&#10;                    x = Random.nextFloat() * (screenWidthPx - 80f),&#10;                    y = mutableStateOf(-Random.nextInt(200, 2000).toFloat()),&#10;                    speed = Random.nextFloat() * 1.5f + 1.5f,&#10;                    hp = mutableStateOf(100),&#10;                    size = 80f,&#10;                    generation = 1&#10;                )&#10;            )&#10;        }&#10;    }&#10;&#10;    val coins = remember {&#10;        List(6) {&#10;            BaseCoin(&#10;                x = Random.nextFloat() * (screenWidthPx - 50f),&#10;                y = mutableStateOf(-Random.nextInt(100, 600).toFloat()),&#10;                speed = Random.nextFloat() * 2f + 1f&#10;            )&#10;        }&#10;    }&#10;&#10;    val bullets = remember { mutableStateListOf&lt;Bullet&gt;() }&#10;    val bagCoins = remember { mutableStateListOf&lt;BagCoinDisplay&gt;() }&#10;    var chestItems by remember { mutableStateOf&lt;List&lt;ChestItem&gt;&gt;(emptyList()) }&#10;&#10;    // --- Load player data ---&#10;    LaunchedEffect(Unit) {&#10;        if (!playerName.isNullOrBlank()) {&#10;            FirebaseHelper.syncNewPlayer(playerName)&#10;            FirebaseHelper.getScore(playerName) { totalScore = it }&#10;            FirebaseHelper.getChestItems(playerName) { chestItems = it }&#10;        }&#10;    }&#10;&#10;    // --- Shooting ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.add(Bullet(planeX + planeWidth / 2f - 15f, planeY))&#10;            SoundManager.playSoundEffect(soundPool, shootSoundId, 0.5f)&#10;            delay(300)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.forEach { it.y -= 25f }&#10;            bullets.removeAll { it.y &lt; -50f }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Monster movement (zigzag or bounce) ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            // Create a snapshot to avoid concurrent modification&#10;            val currentMonsters = splittingMonsters.toList()&#10;            currentMonsters.forEach { m -&gt;&#10;                if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp; !timeActive) {&#10;                    if (m.isZigzagMovement) {&#10;                        // Zigzag movement&#10;                        m.x += m.horizontalSpeed * m.direction&#10;                        if (m.x &lt;= 0 || m.x &gt;= screenWidthPx - m.size) {&#10;                            m.direction *= -1&#10;                        }&#10;                        m.y.value += m.speed&#10;                    } else {&#10;                        // Bounce movement&#10;                        m.x += m.velocityX&#10;                        m.y.value += m.velocityY&#10;&#10;                        // Bounce off walls&#10;                        if (m.x &lt;= 0 || m.x &gt;= screenWidthPx - m.size) {&#10;                            m.velocityX *= -1&#10;                            m.x = m.x.coerceIn(0f, screenWidthPx - m.size)&#10;                        }&#10;&#10;                        // Bounce off top (optional)&#10;                        if (m.y.value &lt;= 0) {&#10;                            m.velocityY *= -1&#10;                            m.y.value = 0f&#10;                        }&#10;                    }&#10;&#10;                    // Wall collision check&#10;                    val wallTop = planeY - 60f&#10;                    val monsterBottom = m.y.value + m.size&#10;&#10;                    if (wallActive &amp;&amp; monsterBottom &gt;= wallTop) {&#10;                        // Bounce back from wall&#10;                        if (!m.isZigzagMovement) {&#10;                            m.velocityY *= -1&#10;                        }&#10;                    }&#10;&#10;                    // If monster passes plane&#10;                    if (m.y.value &gt; planeY + planeHeight / 2f) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) {&#10;                            val damage = when(m.generation) {&#10;                                1 -&gt; 50 // Large&#10;                                2 -&gt; 30 // Medium&#10;                                else -&gt; 20 // Small&#10;                            }&#10;                            planeHp -= damage&#10;                        }&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Remove dead monsters (but spawn children first)&#10;            splittingMonsters.removeAll { !it.alive.value &amp;&amp; it.hasSpawned.value }&#10;&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Split monsters when killed ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            // Create a snapshot to avoid concurrent modification&#10;            val currentMonsters = splittingMonsters.toList()&#10;            currentMonsters.forEach { m -&gt;&#10;                if (!m.alive.value &amp;&amp; m.canSplit &amp;&amp; !m.hasSpawned.value) {&#10;                    m.hasSpawned.value = true&#10;&#10;                    // Spawn 2-3 smaller monsters&#10;                    val childCount = Random.nextInt(2, 4) // 2 or 3&#10;                    val newSize = m.size * 0.6f // 60% of parent size&#10;                    val newGeneration = m.generation + 1&#10;&#10;                    repeat(childCount) {&#10;                        splittingMonsters.add(&#10;                            SplittingMonster(&#10;                                x = m.x + Random.nextFloat() * 20f - 10f,&#10;                                y = mutableStateOf(m.y.value),&#10;                                speed = m.speed * 1.2f,&#10;                                hp = mutableStateOf(60),&#10;                                size = newSize,&#10;                                generation = newGeneration&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Coin movement ---&#10;    coins.forEach { c -&gt;&#10;        LaunchedEffect(c, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                if (!c.collected.value &amp;&amp; !timeActive) {&#10;                    c.y.value += c.speed&#10;                    if (c.y.value &gt; screenHeightPx) {&#10;                        c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                        c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                    }&#10;                }&#10;                delay(32)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Bullet vs Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            val iter = bullets.iterator()&#10;            while (iter.hasNext()) {&#10;                val b = iter.next()&#10;                // Create snapshot to avoid concurrent modification&#10;                val currentMonsters = splittingMonsters.toList()&#10;                var bulletRemoved = false&#10;                currentMonsters.forEach { m -&gt;&#10;                    if (!bulletRemoved &amp;&amp; m.alive.value &amp;&amp; m.hp.value &gt; 0) {&#10;                        if (b.x &gt;= m.x &amp;&amp; b.x &lt;= m.x + m.size &amp;&amp;&#10;                            b.y &gt;= m.y.value &amp;&amp; b.y &lt;= m.y.value + m.size) {&#10;                            m.hp.value -= 25&#10;                            bulletRemoved = true&#10;                            // Play hit sound when bullet hits monster&#10;                            SoundManager.playSoundEffect(soundPool, hitSoundId, 0.3f)&#10;                            if (m.hp.value &lt;= 0) {&#10;                                m.alive.value = false&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;                if (bulletRemoved) {&#10;                    iter.remove()&#10;                }&#10;            }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Coin collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            coins.forEach { c -&gt;&#10;                if (!c.collected.value &amp;&amp; CollisionUtils.checkCollisionPlaneCoin(planeX, planeY, planeWidth, planeHeight, c)) {&#10;                    c.collected.value = true&#10;                    totalScore += 1&#10;                    currentSessionScore += 1&#10;                    val bag = BagCoinDisplay(c.x, c.y.value, 1)&#10;                    bagCoins.add(bag)&#10;                    if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            // Create snapshot to avoid concurrent modification&#10;            val currentMonsters = splittingMonsters.toList()&#10;            currentMonsters.forEach { m -&gt;&#10;                if (m.alive.value &amp;&amp; m.hp.value &gt; 0) {&#10;                    if (planeX + planeWidth &gt; m.x &amp;&amp; planeX &lt; m.x + m.size &amp;&amp;&#10;                        planeY + planeHeight &gt; m.y.value &amp;&amp; planeY &lt; m.y.value + m.size) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) {&#10;                            val damage = when(m.generation) {&#10;                                1 -&gt; 50&#10;                                2 -&gt; 30&#10;                                else -&gt; 20&#10;                            }&#10;                            planeHp -= damage&#10;                        }&#10;                        m.hp.value = 0&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;            }&#10;            if (planeHp &lt;= 0) isGameOver = true&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Wall - Monster collision ---&#10;    LaunchedEffect(wallActive, isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            if (wallActive) {&#10;                // Create snapshot to avoid concurrent modification&#10;                val currentMonsters = splittingMonsters.toList()&#10;                currentMonsters.forEach { m -&gt;&#10;                    if (m.alive.value &amp;&amp; m.hp.value &gt; 0) {&#10;                        val wallTop = planeY - 60f&#10;                        val monsterBottom = m.y.value + m.size&#10;                        if (monsterBottom &gt;= wallTop &amp;&amp; monsterBottom &lt;= wallTop + 10f) {&#10;                            m.hp.value -= 2&#10;                            if (m.hp.value &lt;= 0) {&#10;                                m.alive.value = false&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Use chest item ---&#10;    fun useChestItem(item: ChestItem) {&#10;        ChestItemEffectsBase.applyItemEffect(&#10;            itemName = item.name,&#10;            monsters = splittingMonsters,&#10;            coins = coins,&#10;            bagCoins = bagCoins,&#10;            coroutineScope = coroutineScope,&#10;            screenHeightPx = screenHeightPx,&#10;            planeX = planeX,&#10;            onScoreUpdate = { add -&gt;&#10;                totalScore += add&#10;                currentSessionScore += add&#10;                if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;            },&#10;            onShieldToggle = { active -&gt; shieldActive = active },&#10;            onWallToggle = { active -&gt; wallActive = active },&#10;            onTimeToggle = { active -&gt; timeActive = active },&#10;            onLevelClear = { isLevelClear = true }&#10;        )&#10;        chestItems = chestItems - item&#10;        if (!playerName.isNullOrBlank()) FirebaseHelper.updateChest(playerName, chestItems)&#10;    }&#10;&#10;    // --- Drag plane ---&#10;    val dragModifier = Modifier.pointerInput(Unit) {&#10;        detectDragGestures { change, dragAmount -&gt;&#10;            planeX = (planeX + dragAmount.x).coerceIn(0f, screenWidthPx - planeWidth)&#10;            change.consume()&#10;        }&#10;    }&#10;&#10;    // --- UI ---&#10;    Box(modifier = Modifier.fillMaxSize().then(dragModifier)) {&#10;        // Background&#10;        Image(&#10;            painter = painterResource(R.drawable.vutru1),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg1Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;        Image(&#10;            painter = painterResource(R.drawable.vutru1),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg2Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;&#10;        // Splitting Monsters&#10;        splittingMonsters.forEach { m -&gt;&#10;            SplittingMonsterUI(monster = m)&#10;        }&#10;&#10;        // Coins&#10;        coins.filter { !it.collected.value }.forEach { c -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.coin),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(c.x.roundToInt(), c.y.value.roundToInt()) }&#10;                    .size(40.dp)&#10;            )&#10;        }&#10;&#10;        // BagCoin animated views&#10;        bagCoins.toList().forEach { bag -&gt;&#10;            BagCoinAnimatedView(bag = bag, onFinished = { finishedBag -&gt;&#10;                bagCoins.remove(finishedBag)&#10;            })&#10;        }&#10;&#10;        // Bullets&#10;        bullets.forEach { b -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.dan2),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(b.x.roundToInt(), b.y.roundToInt()) }&#10;                    .size(30.dp)&#10;            )&#10;        }&#10;&#10;        // Plane&#10;        PlaneUI(&#10;            planeX = planeX,&#10;            planeY = planeY,&#10;            planeHp = planeHp,&#10;            shieldActive = shieldActive&#10;        )&#10;&#10;        // Wall&#10;        if (wallActive) {&#10;            WallUI(planeY = planeY)&#10;        }&#10;&#10;        // Top bar&#10;        TopBarUI(&#10;            bagCoinScore = totalScore,&#10;            chestItems = chestItems,&#10;            onBuyItem = { item, price -&gt;&#10;                if (totalScore &gt;= price) {&#10;                    totalScore -= price&#10;                    chestItems = chestItems + item&#10;                    if (!playerName.isNullOrBlank()) {&#10;                        FirebaseHelper.updateScore(playerName, totalScore)&#10;                        FirebaseHelper.updateChest(playerName, chestItems)&#10;                    }&#10;                }&#10;            },&#10;            onUseChestItem = { useChestItem(it) }&#10;        )&#10;&#10;        // --- Sound Control Button (top-right corner) ---&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp),&#10;            contentAlignment = androidx.compose.ui.Alignment.TopEnd&#10;        ) {&#10;            SoundControlButton()&#10;        }&#10;    }&#10;&#10;    // --- Game End Dialog ---&#10;    if (showGameEndDialog) {&#10;        GameEndDialog(&#10;            isWin = isLevelClear,&#10;            score = currentSessionScore,&#10;            level = 5,&#10;            onDismiss = {&#10;                showGameEndDialog = false&#10;            },&#10;            onReplay = {&#10;                showGameEndDialog = false&#10;                isGameOver = false&#10;                isLevelClear = false&#10;                planeHp = 100&#10;                currentSessionScore = 0&#10;&#10;                splittingMonsters.clear()&#10;                repeat(8) {&#10;                    splittingMonsters.add(&#10;                        SplittingMonster(&#10;                            x = Random.nextFloat() * (screenWidthPx - 80f),&#10;                            y = mutableStateOf(-Random.nextInt(200, 2000).toFloat()),&#10;                            speed = Random.nextFloat() * 1.5f + 1.5f,&#10;                            hp = mutableStateOf(100),&#10;                            size = 80f,&#10;                            generation = 1&#10;                        )&#10;                    )&#10;                }&#10;&#10;                coins.forEach { c -&gt;&#10;                    c.collected.value = false&#10;                    c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                    c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                }&#10;&#10;                bullets.clear()&#10;            },&#10;            onNextLevel = {&#10;                onExit()&#10;            },&#10;            onExit = {&#10;                onExit()&#10;            }&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/game/core/BaseGameActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/game/core/BaseGameActivity.kt" />
              <option name="originalContent" value="package com.example.game.core&#10;&#10;import android.media.AudioAttributes&#10;import android.util.Log&#10;import androidx.activity.ComponentActivity&#10;import com.example.game.R&#10;&#10;open class BaseGameActivity : ComponentActivity() {&#10;    protected lateinit var soundPool: android.media.SoundPool&#10;    protected var shootSoundId: Int = 0&#10;    protected var hitSoundId: Int = 0&#10;    protected var coinSoundId: Int = 0&#10;&#10;    protected fun initAudio() {&#10;        val audioAttributes = AudioAttributes.Builder()&#10;            .setUsage(AudioAttributes.USAGE_GAME)&#10;            .setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION)&#10;            .build()&#10;        soundPool = android.media.SoundPool.Builder()&#10;            .setMaxStreams(10)&#10;            .setAudioAttributes(audioAttributes)&#10;            .build()&#10;&#10;        shootSoundId = soundPool.load(this, R.raw.shoot, 1)&#10;        hitSoundId = soundPool.load(this, R.raw.hit, 1)&#10;&#10;        // Initialize background music with SoundManager&#10;        try {&#10;            SoundManager.initBackgroundMusic(this, R.raw.background_music)&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;BaseGameActivity&quot;, &quot;Media init failed: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    override fun onPause() {&#10;        super.onPause()&#10;        SoundManager.pauseBackgroundMusic()&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        SoundManager.playBackgroundMusic()&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        soundPool.release()&#10;        // Don't release SoundManager here as it's shared across activities&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.game.core&#10;&#10;import android.media.AudioAttributes&#10;import android.util.Log&#10;import androidx.activity.ComponentActivity&#10;import com.example.game.R&#10;&#10;open class BaseGameActivity : ComponentActivity() {&#10;    protected lateinit var soundPool: android.media.SoundPool&#10;    protected var shootSoundId: Int = 0&#10;    protected var hitSoundId: Int = 0&#10;    protected var coinSoundId: Int = 0&#10;&#10;    protected fun initAudio() {&#10;        val audioAttributes = AudioAttributes.Builder()&#10;            .setUsage(AudioAttributes.USAGE_GAME)&#10;            .setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION)&#10;            .build()&#10;        soundPool = android.media.SoundPool.Builder()&#10;            .setMaxStreams(10)&#10;            .setAudioAttributes(audioAttributes)&#10;            .build()&#10;&#10;        shootSoundId = soundPool.load(this, R.raw.shoot, 1)&#10;        hitSoundId = soundPool.load(this, R.raw.hit, 1)&#10;&#10;        // Initialize background music with SoundManager&#10;        try {&#10;            SoundManager.initBackgroundMusic(this, R.raw.background_music)&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;BaseGameActivity&quot;, &quot;Media init failed: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    override fun onPause() {&#10;        super.onPause()&#10;        SoundManager.pauseBackgroundMusic()&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        // Only play if background music is enabled&#10;        if (SoundManager.isBackgroundMusicEnabled.value) {&#10;            SoundManager.playBackgroundMusic()&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        soundPool.release()&#10;        // Don't release SoundManager here as it's shared across activities&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/game/core/SoundManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/game/core/SoundManager.kt" />
              <option name="originalContent" value="package com.example.game.core&#10;&#10;import android.content.Context&#10;import android.media.MediaPlayer&#10;import androidx.compose.runtime.mutableStateOf&#10;&#10;/**&#10; * Sound Manager - Quản lý âm thanh background và sound effects&#10; */&#10;object SoundManager {&#10;    // States for sound settings&#10;    var isBackgroundMusicEnabled = mutableStateOf(true)&#10;    var isSoundEffectsEnabled = mutableStateOf(true)&#10;&#10;    private var backgroundMusic: MediaPlayer? = null&#10;    private var currentMusicResId: Int = -1&#10;&#10;    // Background music volume (0.0 to 1.0)&#10;    var backgroundMusicVolume = 0.5f&#10;&#10;    // Sound effects volume (0.0 to 1.0)&#10;    var soundEffectsVolume = 0.5f&#10;&#10;    /**&#10;     * Initialize background music&#10;     */&#10;    fun initBackgroundMusic(context: Context, musicResId: Int) {&#10;        if (currentMusicResId != musicResId) {&#10;            stopBackgroundMusic()&#10;            backgroundMusic = MediaPlayer.create(context, musicResId).apply {&#10;                isLooping = true&#10;                setVolume(backgroundMusicVolume, backgroundMusicVolume)&#10;            }&#10;            currentMusicResId = musicResId&#10;        }&#10;&#10;        if (isBackgroundMusicEnabled.value) {&#10;            playBackgroundMusic()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Play background music&#10;     */&#10;    fun playBackgroundMusic() {&#10;        if (isBackgroundMusicEnabled.value &amp;&amp; backgroundMusic?.isPlaying == false) {&#10;            backgroundMusic?.start()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Pause background music&#10;     */&#10;    fun pauseBackgroundMusic() {&#10;        backgroundMusic?.pause()&#10;    }&#10;&#10;    /**&#10;     * Stop background music&#10;     */&#10;    fun stopBackgroundMusic() {&#10;        backgroundMusic?.stop()&#10;        backgroundMusic?.release()&#10;        backgroundMusic = null&#10;        currentMusicResId = -1&#10;    }&#10;&#10;    /**&#10;     * Toggle background music on/off&#10;     */&#10;    fun toggleBackgroundMusic() {&#10;        isBackgroundMusicEnabled.value = !isBackgroundMusicEnabled.value&#10;        if (isBackgroundMusicEnabled.value) {&#10;            playBackgroundMusic()&#10;        } else {&#10;            pauseBackgroundMusic()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Toggle sound effects on/off&#10;     */&#10;    fun toggleSoundEffects() {&#10;        isSoundEffectsEnabled.value = !isSoundEffectsEnabled.value&#10;    }&#10;&#10;    /**&#10;     * Play sound effect with volume control&#10;     */&#10;    fun playSoundEffect(soundPool: android.media.SoundPool, soundId: Int, volume: Float = 1.0f) {&#10;        if (isSoundEffectsEnabled.value) {&#10;            val effectiveVolume = volume * soundEffectsVolume&#10;            soundPool.play(soundId, effectiveVolume, effectiveVolume, 1, 0, 1f)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Set background music volume&#10;     */&#10;    fun setBackgroundMusicVolume(volume: Float) {&#10;        backgroundMusicVolume = volume.coerceIn(0f, 1f)&#10;        backgroundMusic?.setVolume(backgroundMusicVolume, backgroundMusicVolume)&#10;    }&#10;&#10;    /**&#10;     * Set sound effects volume&#10;     */&#10;    fun setSoundEffectsVolume(volume: Float) {&#10;        soundEffectsVolume = volume.coerceIn(0f, 1f)&#10;    }&#10;&#10;    /**&#10;     * Clean up resources&#10;     */&#10;    fun release() {&#10;        stopBackgroundMusic()&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.example.game.core&#10;&#10;import android.content.Context&#10;import android.media.MediaPlayer&#10;import androidx.compose.runtime.mutableStateOf&#10;&#10;/**&#10; * Sound Manager - Quản lý âm thanh background và sound effects&#10; */&#10;object SoundManager {&#10;    // States for sound settings&#10;    var isBackgroundMusicEnabled = mutableStateOf(true)&#10;    var isSoundEffectsEnabled = mutableStateOf(true)&#10;&#10;    private var backgroundMusic: MediaPlayer? = null&#10;    private var currentMusicResId: Int = -1&#10;&#10;    // Background music volume (0.0 to 1.0)&#10;    private var backgroundMusicVolume = 0.5f&#10;&#10;    // Sound effects volume (0.0 to 1.0)&#10;    private var soundEffectsVolume = 0.5f&#10;&#10;    /**&#10;     * Initialize background music&#10;     */&#10;    fun initBackgroundMusic(context: Context, musicResId: Int) {&#10;        if (currentMusicResId != musicResId) {&#10;            stopBackgroundMusic()&#10;            backgroundMusic = MediaPlayer.create(context, musicResId).apply {&#10;                isLooping = true&#10;                setVolume(backgroundMusicVolume, backgroundMusicVolume)&#10;            }&#10;            currentMusicResId = musicResId&#10;        }&#10;&#10;        if (isBackgroundMusicEnabled.value) {&#10;            playBackgroundMusic()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Play background music&#10;     */&#10;    fun playBackgroundMusic() {&#10;        if (isBackgroundMusicEnabled.value &amp;&amp; backgroundMusic?.isPlaying == false) {&#10;            backgroundMusic?.start()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Pause background music&#10;     */&#10;    fun pauseBackgroundMusic() {&#10;        backgroundMusic?.pause()&#10;    }&#10;&#10;    /**&#10;     * Stop background music&#10;     */&#10;    fun stopBackgroundMusic() {&#10;        backgroundMusic?.stop()&#10;        backgroundMusic?.release()&#10;        backgroundMusic = null&#10;        currentMusicResId = -1&#10;    }&#10;&#10;    /**&#10;     * Toggle background music on/off&#10;     */&#10;    fun toggleBackgroundMusic() {&#10;        isBackgroundMusicEnabled.value = !isBackgroundMusicEnabled.value&#10;        if (isBackgroundMusicEnabled.value) {&#10;            playBackgroundMusic()&#10;        } else {&#10;            pauseBackgroundMusic()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Toggle sound effects on/off&#10;     */&#10;    fun toggleSoundEffects() {&#10;        isSoundEffectsEnabled.value = !isSoundEffectsEnabled.value&#10;    }&#10;&#10;    /**&#10;     * Play sound effect with volume control&#10;     */&#10;    fun playSoundEffect(soundPool: android.media.SoundPool, soundId: Int, volume: Float = 1.0f) {&#10;        if (isSoundEffectsEnabled.value) {&#10;            val effectiveVolume = volume * soundEffectsVolume&#10;            soundPool.play(soundId, effectiveVolume, effectiveVolume, 1, 0, 1f)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Set background music volume&#10;     */&#10;    fun setBackgroundMusicVolume(volume: Float) {&#10;        backgroundMusicVolume = volume.coerceIn(0f, 1f)&#10;        backgroundMusic?.setVolume(backgroundMusicVolume, backgroundMusicVolume)&#10;    }&#10;&#10;    /**&#10;     * Set sound effects volume&#10;     */&#10;    fun setSoundEffectsVolume(volume: Float) {&#10;        soundEffectsVolume = volume.coerceIn(0f, 1f)&#10;    }&#10;&#10;    /**&#10;     * Clean up resources&#10;     */&#10;    fun release() {&#10;        stopBackgroundMusic()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>
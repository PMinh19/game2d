<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/game/Level4Activity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/game/Level4Activity.kt" />
              <option name="originalContent" value="package com.example.game&#10;&#10;import android.os.Bundle&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.TopBarComponent.TopBarUI&#10;import com.example.game.core.*&#10;import com.example.game.ui.PlaneUI&#10;import com.example.game.ui.WallUI&#10;import com.example.game.ui.GrowingMonsterUI&#10;import com.example.game.ui.SoundControlButton&#10;import com.example.game.ui.BagCoinAnimatedView&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.roundToInt&#10;import kotlin.random.Random&#10;&#10;class Level4Activity : BaseGameActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        initAudio()&#10;&#10;        // Initialize AI Avoidance Helper for smart bullet dodging&#10;        try {&#10;            AIAvoidanceHelper.init(this)&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;Level4Activity&quot;, &quot;AI init failed: ${e.message}&quot;, e)&#10;            // Continue without AI - game will still work with basic logic&#10;        }&#10;&#10;        setContent {&#10;            val density = LocalDensity.current&#10;            val screenWidthPx = with(density) { LocalConfiguration.current.screenWidthDp.dp.toPx() }&#10;            val screenHeightPx = with(density) { LocalConfiguration.current.screenHeightDp.dp.toPx() }&#10;&#10;            Level4Game(&#10;                screenWidthPx = screenWidthPx,&#10;                screenHeightPx = screenHeightPx,&#10;                soundPool = soundPool,&#10;                shootSoundId = shootSoundId,&#10;                hitSoundId = hitSoundId,&#10;                onExit = { finish() }&#10;            )&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        try {&#10;            AIAvoidanceHelper.release()&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;Level4Activity&quot;, &quot;AI release failed: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Level4Game(&#10;    screenWidthPx: Float,&#10;    screenHeightPx: Float,&#10;    soundPool: android.media.SoundPool,&#10;    shootSoundId: Int,&#10;    hitSoundId: Int,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val playerName = PrefManager.getPlayerName(context)&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // --- State ---&#10;    var totalScore by remember { mutableStateOf(0) }&#10;    var currentSessionScore by remember { mutableStateOf(0) }&#10;    var planeHp by remember { mutableStateOf(100) }&#10;&#10;    var shieldActive by remember { mutableStateOf(false) }&#10;    var wallActive by remember { mutableStateOf(false) }&#10;    var timeActive by remember { mutableStateOf(false) }&#10;&#10;    var isGameOver by remember { mutableStateOf(false) }&#10;    var isLevelClear by remember { mutableStateOf(false) }&#10;    var showGameEndDialog by remember { mutableStateOf(false) }&#10;&#10;    // Show dialog when game ends&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        if (isGameOver || isLevelClear) {&#10;            delay(500)&#10;            showGameEndDialog = true&#10;        }&#10;    }&#10;&#10;    // --- Plane setup ---&#10;    var planeX by remember { mutableStateOf(screenWidthPx / 2 - 50f) }&#10;    val planeY = screenHeightPx - 250f&#10;    val planeWidth = 100f&#10;    val planeHeight = 100f&#10;&#10;    // --- Background ---&#10;    var offsetY by remember { mutableStateOf(0f) }&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            offsetY += 4f&#10;            if (offsetY &gt;= screenHeightPx) {&#10;                offsetY %= screenHeightPx&#10;            }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Growing Monsters ---&#10;    val growingMonsters = remember {&#10;        List(10) {&#10;            GrowingMonster(&#10;                x = Random.nextFloat() * (screenWidthPx - 200f) + 100f,&#10;                y = mutableStateOf(-Random.nextInt(200, 1500).toFloat()),&#10;                speed = Random.nextFloat() * 1.2f + 1.0f,&#10;                hp = mutableStateOf(80),  // Tăng HP lên 80&#10;                initialSize = 80f,  // Tăng kích thước ban đầu từ 60f lên 80f&#10;                maxSize = 500f,  // Tăng kích thước tối đa từ 200f lên 500f&#10;                growthRate = 0.5f  // Tăng tốc độ lớn từ 0.3f lên 0.5f&#10;            )&#10;        }&#10;    }&#10;&#10;    // Track respawn times&#10;    val monsterRespawnTimes = remember { MutableList(growingMonsters.size) { 0L } }&#10;&#10;    val coins = remember {&#10;        List(6) {&#10;            BaseCoin(&#10;                x = Random.nextFloat() * (screenWidthPx - 50f),&#10;                y = mutableStateOf(-Random.nextInt(100, 600).toFloat()),&#10;                speed = Random.nextFloat() * 2f + 1f&#10;            )&#10;        }&#10;    }&#10;&#10;    val bullets = remember { mutableStateListOf&lt;Bullet&gt;() }&#10;    val bagCoins = remember { mutableStateListOf&lt;BagCoinDisplay&gt;() }&#10;    var chestItems by remember { mutableStateOf&lt;List&lt;ChestItem&gt;&gt;(emptyList()) }&#10;&#10;    // --- Load player data ---&#10;    LaunchedEffect(Unit) {&#10;        if (!playerName.isNullOrBlank()) {&#10;            FirebaseHelper.syncNewPlayer(playerName)&#10;            FirebaseHelper.getScore(playerName) { totalScore = it }&#10;            FirebaseHelper.getChestItems(playerName) { chestItems = it }&#10;        }&#10;    }&#10;&#10;    // --- Shooting ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.add(Bullet(planeX + planeWidth / 2f - 15f, planeY))&#10;            SoundManager.playSoundEffect(soundPool, shootSoundId, 0.5f)&#10;            delay(300)&#10;        }&#10;    }&#10;&#10;    // --- Bullet movement ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.forEach { it.y -= 25f }&#10;            bullets.removeAll { it.y &lt; -50f }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Monster movement + growing + AI evasion ---&#10;    growingMonsters.forEachIndexed { index, m -&gt;&#10;        LaunchedEffect(m, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                // Check if monster needs to respawn&#10;                if (!m.alive.value &amp;&amp; System.currentTimeMillis() &gt;= monsterRespawnTimes[index]) {&#10;                    m.y.value = -Random.nextInt(200, 1500).toFloat()&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 200f) + 100f&#10;                    m.hp.value = 80  // Sửa từ 50 thành 80 để khớp với initialSize mới&#10;                    m.maxHp = 80&#10;                    m.currentMaxHp.value = 80&#10;                    m.currentSize.value = m.initialSize&#10;                    m.alive.value = true&#10;                }&#10;&#10;                if (m.alive.value &amp;&amp; !timeActive) {  // Thêm điều kiện !timeActive để grow khi không bị time stop&#10;                    // AI-based evasion: monster tries to dodge bullets intelligently&#10;                    val evasion = AIAvoidanceHelper.calculateEvasion(&#10;                        monsterX = m.x,&#10;                        monsterY = m.y.value,&#10;                        monsterSize = m.currentSize.value,&#10;                        bullets = bullets,&#10;                        screenWidth = screenWidthPx&#10;                    )&#10;&#10;                    // Apply evasion movement (horizontal dodge)&#10;                    m.x = (m.x + evasion.first).coerceIn(0f, screenWidthPx - m.currentSize.value)&#10;&#10;                    // Grow over time&#10;                    m.grow()&#10;&#10;                    // Wall collision check&#10;                    val wallTop = planeY - 60f&#10;                    val monsterBottom = m.y.value + m.currentSize.value&#10;&#10;                    if (wallActive &amp;&amp; monsterBottom &gt;= wallTop) {&#10;                        // Stop at wall&#10;                    } else {&#10;                        // Normal downward movement&#10;                        m.y.value += m.speed&#10;                    }&#10;&#10;                    // If monster passes plane&#10;                    if (m.y.value &gt; planeY + planeHeight / 2f) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) {&#10;                            // Damage scales with monster size&#10;                            val damage = (30 * (m.currentSize.value / m.initialSize)).toInt()&#10;                            planeHp -= damage&#10;                        }&#10;                        monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(500, 1500)  // Giảm thời gian respawn từ 1000-2500 xuống 500-1500&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;                delay(16)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Coin movement ---&#10;    coins.forEach { c -&gt;&#10;        LaunchedEffect(c, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                if (!c.collected.value &amp;&amp; !timeActive) {&#10;                    c.y.value += c.speed&#10;                    if (c.y.value &gt; screenHeightPx) {&#10;                        c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                        c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                    }&#10;                }&#10;                delay(32)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Bullet - Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            val toRemove = mutableSetOf&lt;Bullet&gt;()&#10;            bullets.toList().forEach { b -&gt;&#10;                var shouldRemove = false&#10;                growingMonsters.forEach { m -&gt;&#10;                    if (m.alive.value &amp;&amp; !shouldRemove) {&#10;                        if (CollisionUtils.checkCollisionBulletMonster(b, m)) {&#10;                            m.hp.value -= 20&#10;                            SoundManager.playSoundEffect(soundPool, hitSoundId, 0.3f)&#10;                            shouldRemove = true&#10;                            if (m.hp.value &lt;= 0) {&#10;                                m.alive.value = false&#10;                                val index = growingMonsters.indexOf(m)&#10;                                if (index &gt;= 0) {&#10;                                    monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(500, 1500)&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;                if (shouldRemove) {&#10;                    toRemove.add(b)&#10;                }&#10;            }&#10;            bullets.removeAll(toRemove)&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Coin collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            coins.forEach { c -&gt;&#10;                if (!c.collected.value &amp;&amp; CollisionUtils.checkCollisionPlaneCoin(planeX, planeY, planeWidth, planeHeight, c)) {&#10;                    c.collected.value = true&#10;                    totalScore += 1&#10;                    currentSessionScore += 1&#10;                    val bag = BagCoinDisplay(c.x, c.y.value, 1)&#10;                    bagCoins.add(bag)&#10;                    if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            growingMonsters.forEach { m -&gt;&#10;                if (m.alive.value &amp;&amp; CollisionUtils.checkCollisionPlaneMonster(planeX, planeY, planeWidth, planeHeight, m)) {&#10;                    if (!shieldActive) {&#10;                        val damage = (30 * (m.currentSize.value / m.initialSize)).toInt()&#10;                        planeHp -= damage&#10;                    }&#10;                    m.hp.value = 0&#10;                    m.alive.value = false&#10;                }&#10;            }&#10;            if (planeHp &lt;= 0) isGameOver = true&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Wall - Monster collision ---&#10;    LaunchedEffect(wallActive, isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            if (wallActive) {&#10;                growingMonsters.forEach { m -&gt;&#10;                    if (m.alive.value) {&#10;                        val wallTop = planeY - 60f&#10;                        val monsterBottom = m.y.value + m.currentSize.value&#10;                        if (monsterBottom &gt;= wallTop) {&#10;                            m.hp.value -= 2&#10;                            if (m.hp.value &lt;= 0) {&#10;                                m.alive.value = false&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Use chest item ---&#10;    fun useChestItem(item: ChestItem) {&#10;        ChestItemEffectsBase.applyItemEffect(&#10;            itemName = item.name,&#10;            monsters = growingMonsters,&#10;            coins = coins,&#10;            bagCoins = bagCoins,&#10;            coroutineScope = coroutineScope,&#10;            screenHeightPx = screenHeightPx,&#10;            planeX = planeX,&#10;            onScoreUpdate = { add -&gt;&#10;                totalScore += add&#10;                currentSessionScore += add&#10;                if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;            },&#10;            onShieldToggle = { active -&gt; shieldActive = active },&#10;            onWallToggle = { active -&gt; wallActive = active },&#10;            onTimeToggle = { active -&gt; timeActive = active },&#10;            onLevelClear = { isLevelClear = true }&#10;        )&#10;        chestItems = chestItems - item&#10;        if (!playerName.isNullOrBlank()) FirebaseHelper.updateChest(playerName, chestItems)&#10;    }&#10;&#10;    // --- Drag plane ---&#10;    val dragModifier = Modifier.pointerInput(Unit) {&#10;        detectDragGestures { change, dragAmount -&gt;&#10;            planeX = (planeX + dragAmount.x).coerceIn(0f, screenWidthPx - planeWidth)&#10;            change.consume()&#10;        }&#10;    }&#10;&#10;    // --- UI ---&#10;    Box(modifier = Modifier.fillMaxSize().then(dragModifier)) {&#10;        // Background&#10;        Image(&#10;            painter = painterResource(R.drawable.nen4),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, offsetY.roundToInt()) }.fillMaxSize(),&#10;            contentScale = ContentScale.Crop&#10;        )&#10;        Image(&#10;            painter = painterResource(R.drawable.nen4),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, (offsetY - screenHeightPx).roundToInt()) }.fillMaxSize(),&#10;            contentScale = ContentScale.Crop&#10;        )&#10;&#10;        // Growing Monsters&#10;        growingMonsters.forEach { m -&gt;&#10;            GrowingMonsterUI(monster = m, level = 4)&#10;        }&#10;&#10;        // Coins&#10;        coins.filter { !it.collected.value }.forEach { c -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.coin),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(c.x.roundToInt(), c.y.value.roundToInt()) }&#10;                    .size(40.dp)&#10;            )&#10;        }&#10;&#10;        // BagCoin animated views&#10;        bagCoins.toList().forEach { bag -&gt;&#10;            BagCoinAnimatedView(bag = bag, onFinished = { finishedBag -&gt;&#10;                bagCoins.remove(finishedBag)&#10;            })&#10;        }&#10;&#10;        // Bullets&#10;        bullets.forEach { b -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.dan2),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(b.x.roundToInt(), b.y.roundToInt()) }&#10;                    .size(30.dp)&#10;            )&#10;        }&#10;&#10;        // Plane&#10;        PlaneUI(&#10;            planeX = planeX,&#10;            planeY = planeY,&#10;            planeHp = planeHp,&#10;            shieldActive = shieldActive,&#10;            level = 4&#10;        )&#10;&#10;        // Wall&#10;        if (wallActive) {&#10;            WallUI(planeY = planeY)&#10;        }&#10;&#10;        // Top bar&#10;        TopBarUI(&#10;            bagCoinScore = totalScore,&#10;            chestItems = chestItems,&#10;            onBuyItem = { item, price -&gt;&#10;                if (totalScore &gt;= price) {&#10;                    totalScore -= price&#10;                    chestItems = chestItems + item&#10;                    if (!playerName.isNullOrBlank()) {&#10;                        FirebaseHelper.updateScore(playerName, totalScore)&#10;                        FirebaseHelper.updateChest(playerName, chestItems)&#10;                    }&#10;                }&#10;            },&#10;            onUseChestItem = { useChestItem(it) }&#10;        )&#10;&#10;        // --- Sound Control Button (top-right corner) ---&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp),&#10;            contentAlignment = Alignment.TopEnd&#10;        ) {&#10;            SoundControlButton()&#10;        }&#10;    }&#10;&#10;    // --- Game End Dialog ---&#10;    if (showGameEndDialog) {&#10;        GameEndDialog(&#10;            isWin = isLevelClear,&#10;            score = currentSessionScore,&#10;            level = 4,&#10;            onDismiss = {&#10;                showGameEndDialog = false&#10;            },&#10;            onReplay = {&#10;                // Reset game&#10;                showGameEndDialog = false&#10;                isGameOver = false&#10;                isLevelClear = false&#10;                planeHp = 100&#10;                currentSessionScore = 0&#10;&#10;                growingMonsters.forEachIndexed { index, m -&gt;&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 200f) + 100f&#10;                    m.y.value = -Random.nextInt(200, 2500).toFloat()&#10;                    m.hp.value = 80&#10;                    m.maxHp = 80&#10;                    m.currentMaxHp.value = 80&#10;                    m.currentSize.value = m.initialSize&#10;                    m.alive.value = true&#10;                    monsterRespawnTimes[index] = 0L&#10;                }&#10;&#10;                coins.forEach { c -&gt;&#10;                    c.collected.value = false&#10;                    c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                    c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                }&#10;&#10;                bullets.clear()&#10;            },&#10;            onNextLevel = {&#10;                onExit()&#10;            },&#10;            onExit = {&#10;                onExit()&#10;            }&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.game&#10;&#10;import android.os.Bundle&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.TopBarComponent.TopBarUI&#10;import com.example.game.core.*&#10;import com.example.game.ui.PlaneUI&#10;import com.example.game.ui.WallUI&#10;import com.example.game.ui.GrowingMonsterUI&#10;import com.example.game.ui.SoundControlButton&#10;import com.example.game.ui.BagCoinAnimatedView&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.roundToInt&#10;import kotlin.random.Random&#10;&#10;class Level4Activity : BaseGameActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        initAudio()&#10;&#10;        // Initialize AI Avoidance Helper for smart bullet dodging&#10;        try {&#10;            AIAvoidanceHelper.init(this)&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;Level4Activity&quot;, &quot;AI init failed: ${e.message}&quot;, e)&#10;            // Continue without AI - game will still work with basic logic&#10;        }&#10;&#10;        setContent {&#10;            val density = LocalDensity.current&#10;            val screenWidthPx = with(density) { LocalConfiguration.current.screenWidthDp.dp.toPx() }&#10;            val screenHeightPx = with(density) { LocalConfiguration.current.screenHeightDp.dp.toPx() }&#10;&#10;            Level4Game(&#10;                screenWidthPx = screenWidthPx,&#10;                screenHeightPx = screenHeightPx,&#10;                soundPool = soundPool,&#10;                shootSoundId = shootSoundId,&#10;                hitSoundId = hitSoundId,&#10;                onExit = { finish() }&#10;            )&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        try {&#10;            AIAvoidanceHelper.release()&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;Level4Activity&quot;, &quot;AI release failed: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Level4Game(&#10;    screenWidthPx: Float,&#10;    screenHeightPx: Float,&#10;    soundPool: android.media.SoundPool,&#10;    shootSoundId: Int,&#10;    hitSoundId: Int,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val playerName = PrefManager.getPlayerName(context)&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // --- State ---&#10;    var totalScore by remember { mutableStateOf(0) }&#10;    var currentSessionScore by remember { mutableStateOf(0) }&#10;    var planeHp by remember { mutableStateOf(100) }&#10;&#10;    var shieldActive by remember { mutableStateOf(false) }&#10;    var wallActive by remember { mutableStateOf(false) }&#10;    var timeActive by remember { mutableStateOf(false) }&#10;&#10;    var isGameOver by remember { mutableStateOf(false) }&#10;    var isLevelClear by remember { mutableStateOf(false) }&#10;    var showGameEndDialog by remember { mutableStateOf(false) }&#10;&#10;    // Show dialog when game ends&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        if (isGameOver || isLevelClear) {&#10;            delay(500)&#10;            showGameEndDialog = true&#10;        }&#10;    }&#10;&#10;    // --- Plane setup ---&#10;    var planeX by remember { mutableStateOf(screenWidthPx / 2 - 50f) }&#10;    val planeY = screenHeightPx - 250f&#10;    val planeWidth = 100f&#10;    val planeHeight = 100f&#10;&#10;    // --- Background ---&#10;    var offsetY by remember { mutableStateOf(0f) }&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            offsetY += 4f&#10;            if (offsetY &gt;= screenHeightPx) {&#10;                offsetY %= screenHeightPx&#10;            }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Growing Monsters ---&#10;    val growingMonsters = remember {&#10;        List(10) {&#10;            GrowingMonster(&#10;                x = Random.nextFloat() * (screenWidthPx - 200f) + 100f,&#10;                y = mutableStateOf(-Random.nextInt(200, 1500).toFloat()),&#10;                speed = Random.nextFloat() * 1.2f + 1.0f,&#10;                hp = mutableStateOf(80),  // Tăng HP lên 80&#10;                initialSize = 80f,  // Tăng kích thước ban đầu từ 60f lên 80f&#10;                maxSize = 500f,  // Tăng kích thước tối đa từ 200f lên 500f&#10;                growthRate = 0.5f  // Tăng tốc độ lớn từ 0.3f lên 0.5f&#10;            )&#10;        }&#10;    }&#10;&#10;    // Track respawn times&#10;    val monsterRespawnTimes = remember { MutableList(growingMonsters.size) { 0L } }&#10;&#10;    val coins = remember {&#10;        List(6) {&#10;            BaseCoin(&#10;                x = Random.nextFloat() * (screenWidthPx - 50f),&#10;                y = mutableStateOf(-Random.nextInt(100, 600).toFloat()),&#10;                speed = Random.nextFloat() * 2f + 1f&#10;            )&#10;        }&#10;    }&#10;&#10;    val bullets = remember { mutableStateListOf&lt;Bullet&gt;() }&#10;    val bagCoins = remember { mutableStateListOf&lt;BagCoinDisplay&gt;() }&#10;    var chestItems by remember { mutableStateOf&lt;List&lt;ChestItem&gt;&gt;(emptyList()) }&#10;&#10;    // --- Load player data ---&#10;    LaunchedEffect(Unit) {&#10;        if (!playerName.isNullOrBlank()) {&#10;            FirebaseHelper.syncNewPlayer(playerName)&#10;            FirebaseHelper.getScore(playerName) { totalScore = it }&#10;            FirebaseHelper.getChestItems(playerName) { chestItems = it }&#10;        }&#10;    }&#10;&#10;    // --- Shooting ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.add(Bullet(planeX + planeWidth / 2f - 15f, planeY))&#10;            SoundManager.playSoundEffect(soundPool, shootSoundId, 0.5f)&#10;            delay(300)&#10;        }&#10;    }&#10;&#10;    // --- Bullet movement ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.forEach { it.y -= 25f }&#10;            bullets.removeAll { it.y &lt; -50f }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Monster movement + growing + AI evasion ---&#10;    growingMonsters.forEachIndexed { index, m -&gt;&#10;        LaunchedEffect(m, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                // Check if monster needs to respawn&#10;                if (!m.alive.value &amp;&amp; System.currentTimeMillis() &gt;= monsterRespawnTimes[index]) {&#10;                    m.y.value = -Random.nextInt(200, 1500).toFloat()&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 200f) + 100f&#10;                    m.hp.value = 80  // Sửa từ 50 thành 80 để khớp với initialSize mới&#10;                    m.maxHp = 80&#10;                    m.currentMaxHp.value = 80&#10;                    m.currentSize.value = m.initialSize&#10;                    m.alive.value = true&#10;                }&#10;&#10;                if (m.alive.value &amp;&amp; !timeActive) {  // Thêm điều kiện !timeActive để grow khi không bị time stop&#10;                    // AI-based evasion: monster tries to dodge bullets intelligently&#10;                    val evasion = AIAvoidanceHelper.calculateEvasion(&#10;                        monsterX = m.x,&#10;                        monsterY = m.y.value,&#10;                        monsterSize = m.currentSize.value,&#10;                        bullets = bullets,&#10;                        screenWidth = screenWidthPx&#10;                    )&#10;&#10;                    // Apply evasion movement (horizontal dodge)&#10;                    m.x = (m.x + evasion.first).coerceIn(0f, screenWidthPx - m.currentSize.value)&#10;&#10;                    // Grow over time&#10;                    m.grow()&#10;&#10;                    // Wall collision check&#10;                    val wallTop = planeY - 60f&#10;                    val monsterBottom = m.y.value + m.currentSize.value&#10;&#10;                    if (wallActive &amp;&amp; monsterBottom &gt;= wallTop) {&#10;                        // Stop at wall&#10;                    } else {&#10;                        // Normal downward movement&#10;                        m.y.value += m.speed&#10;                    }&#10;&#10;                    // If monster passes plane&#10;                    if (m.y.value &gt; planeY + planeHeight / 2f) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) {&#10;                            // Damage scales with monster size&#10;                            val damage = (30 * (m.currentSize.value / m.initialSize)).toInt()&#10;                            planeHp -= damage&#10;                        }&#10;                        monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(500, 1500)  // Giảm thời gian respawn từ 1000-2500 xuống 500-1500&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;                delay(16)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Coin movement ---&#10;    coins.forEach { c -&gt;&#10;        LaunchedEffect(c, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                if (!c.collected.value &amp;&amp; !timeActive) {&#10;                    c.y.value += c.speed&#10;                    if (c.y.value &gt; screenHeightPx) {&#10;                        c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                        c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                    }&#10;                }&#10;                delay(32)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Bullet - Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            val toRemove = mutableSetOf&lt;Bullet&gt;()&#10;            bullets.toList().forEach { b -&gt;&#10;                var shouldRemove = false&#10;                growingMonsters.forEach { m -&gt;&#10;                    if (m.alive.value &amp;&amp; !shouldRemove) {&#10;                        if (CollisionUtils.checkCollisionBulletMonster(b, m)) {&#10;                            m.hp.value -= 20&#10;                            SoundManager.playSoundEffect(soundPool, hitSoundId, 0.3f)&#10;                            shouldRemove = true&#10;                            if (m.hp.value &lt;= 0) {&#10;                                m.alive.value = false&#10;                                val index = growingMonsters.indexOf(m)&#10;                                if (index &gt;= 0) {&#10;                                    monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(500, 1500)&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;                if (shouldRemove) {&#10;                    toRemove.add(b)&#10;                }&#10;            }&#10;            bullets.removeAll(toRemove)&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Coin collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            coins.forEach { c -&gt;&#10;                if (!c.collected.value &amp;&amp; CollisionUtils.checkCollisionPlaneCoin(planeX, planeY, planeWidth, planeHeight, c)) {&#10;                    c.collected.value = true&#10;                    totalScore += 1&#10;                    currentSessionScore += 1&#10;                    val bag = BagCoinDisplay(c.x, c.y.value, 1)&#10;                    bagCoins.add(bag)&#10;                    if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            growingMonsters.forEach { m -&gt;&#10;                if (m.alive.value &amp;&amp; CollisionUtils.checkCollisionPlaneMonster(planeX, planeY, planeWidth, planeHeight, m)) {&#10;                    if (!shieldActive) {&#10;                        val damage = (30 * (m.currentSize.value / m.initialSize)).toInt()&#10;                        planeHp -= damage&#10;                    }&#10;                    m.hp.value = 0&#10;                    m.alive.value = false&#10;                }&#10;            }&#10;            if (planeHp &lt;= 0) isGameOver = true&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Wall - Monster collision ---&#10;    LaunchedEffect(wallActive, isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            if (wallActive) {&#10;                growingMonsters.forEach { m -&gt;&#10;                    if (m.alive.value) {&#10;                        val wallTop = planeY - 60f&#10;                        val monsterBottom = m.y.value + m.currentSize.value&#10;                        if (monsterBottom &gt;= wallTop) {&#10;                            m.hp.value -= 2&#10;                            if (m.hp.value &lt;= 0) {&#10;                                m.alive.value = false&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Use chest item ---&#10;    fun useChestItem(item: ChestItem) {&#10;        ChestItemEffectsBase.applyItemEffect(&#10;            itemName = item.name,&#10;            monsters = growingMonsters,&#10;            coins = coins,&#10;            bagCoins = bagCoins,&#10;            coroutineScope = coroutineScope,&#10;            screenHeightPx = screenHeightPx,&#10;            planeX = planeX,&#10;            onScoreUpdate = { add -&gt;&#10;                totalScore += add&#10;                currentSessionScore += add&#10;                if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;            },&#10;            onShieldToggle = { active -&gt; shieldActive = active },&#10;            onWallToggle = { active -&gt; wallActive = active },&#10;            onTimeToggle = { active -&gt; timeActive = active },&#10;            onLevelClear = { isLevelClear = true }&#10;        )&#10;        chestItems = chestItems - item&#10;        if (!playerName.isNullOrBlank()) FirebaseHelper.updateChest(playerName, chestItems)&#10;    }&#10;&#10;    // --- Drag plane ---&#10;    val dragModifier = Modifier.pointerInput(Unit) {&#10;        detectDragGestures { change, dragAmount -&gt;&#10;            planeX = (planeX + dragAmount.x).coerceIn(0f, screenWidthPx - planeWidth)&#10;            change.consume()&#10;        }&#10;    }&#10;&#10;    // --- UI ---&#10;    Box(modifier = Modifier.fillMaxSize()) {&#10;        // Background layer - separate from drag gestures&#10;        Box(modifier = Modifier.fillMaxSize()) {&#10;            // Hình nền chính&#10;            Image(&#10;                painter = painterResource(R.drawable.nen4),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .offset { IntOffset(0, offsetY.roundToInt()) },&#10;                contentScale = ContentScale.Crop&#10;            )&#10;            // Hình nền phụ để tạo hiệu ứng lặp&#10;            Image(&#10;                painter = painterResource(R.drawable.nen4),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .offset { IntOffset(0, (offsetY - screenHeightPx).roundToInt()) },&#10;                contentScale = ContentScale.Crop&#10;            )&#10;        }&#10;&#10;        // Game content with drag gesture&#10;        Box(modifier = Modifier.fillMaxSize().then(dragModifier)) {&#10;            // Growing Monsters&#10;            growingMonsters.forEach { m -&gt;&#10;                GrowingMonsterUI(monster = m, level = 4)&#10;            }&#10;&#10;            // Coins&#10;            coins.filter { !it.collected.value }.forEach { c -&gt;&#10;                Image(&#10;                    painter = painterResource(R.drawable.coin),&#10;                    contentDescription = null,&#10;                    modifier = Modifier&#10;                        .absoluteOffset { IntOffset(c.x.roundToInt(), c.y.value.roundToInt()) }&#10;                        .size(40.dp)&#10;                )&#10;            }&#10;&#10;            // BagCoin animated views&#10;            bagCoins.toList().forEach { bag -&gt;&#10;                BagCoinAnimatedView(bag = bag, onFinished = { finishedBag -&gt;&#10;                    bagCoins.remove(finishedBag)&#10;                })&#10;            }&#10;&#10;            // Bullets&#10;            bullets.forEach { b -&gt;&#10;                Image(&#10;                    painter = painterResource(R.drawable.dan2),&#10;                    contentDescription = null,&#10;                    modifier = Modifier&#10;                        .absoluteOffset { IntOffset(b.x.roundToInt(), b.y.roundToInt()) }&#10;                        .size(30.dp)&#10;                )&#10;            }&#10;&#10;            // Plane&#10;            PlaneUI(&#10;                planeX = planeX,&#10;                planeY = planeY,&#10;                planeHp = planeHp,&#10;                shieldActive = shieldActive,&#10;                level = 4&#10;            )&#10;&#10;            // Wall&#10;            if (wallActive) {&#10;                WallUI(planeY = planeY)&#10;            }&#10;&#10;            // Top bar&#10;            TopBarUI(&#10;                bagCoinScore = totalScore,&#10;                chestItems = chestItems,&#10;                onBuyItem = { item, price -&gt;&#10;                    if (totalScore &gt;= price) {&#10;                        totalScore -= price&#10;                        chestItems = chestItems + item&#10;                        if (!playerName.isNullOrBlank()) {&#10;                            FirebaseHelper.updateScore(playerName, totalScore)&#10;                            FirebaseHelper.updateChest(playerName, chestItems)&#10;                        }&#10;                    }&#10;                },&#10;                onUseChestItem = { useChestItem(it) }&#10;            )&#10;&#10;            // --- Sound Control Button (top-right corner) ---&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(16.dp),&#10;                contentAlignment = Alignment.TopEnd&#10;            ) {&#10;                SoundControlButton()&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Game End Dialog ---&#10;    if (showGameEndDialog) {&#10;        GameEndDialog(&#10;            isWin = isLevelClear,&#10;            score = currentSessionScore,&#10;            level = 4,&#10;            onDismiss = {&#10;                showGameEndDialog = false&#10;            },&#10;            onReplay = {&#10;                // Reset game&#10;                showGameEndDialog = false&#10;                isGameOver = false&#10;                isLevelClear = false&#10;                planeHp = 100&#10;                currentSessionScore = 0&#10;&#10;                growingMonsters.forEachIndexed { index, m -&gt;&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 200f) + 100f&#10;                    m.y.value = -Random.nextInt(200, 2500).toFloat()&#10;                    m.hp.value = 80&#10;                    m.maxHp = 80&#10;                    m.currentMaxHp.value = 80&#10;                    m.currentSize.value = m.initialSize&#10;                    m.alive.value = true&#10;                    monsterRespawnTimes[index] = 0L&#10;                }&#10;&#10;                coins.forEach { c -&gt;&#10;                    c.collected.value = false&#10;                    c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                    c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                }&#10;&#10;                bullets.clear()&#10;            },&#10;            onNextLevel = {&#10;                onExit()&#10;            },&#10;            onExit = {&#10;                onExit()&#10;            }&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/game/Level5Activity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/game/Level5Activity.kt" />
              <option name="originalContent" value="package com.example.game&#10;&#10;import android.os.Bundle&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.TopBarComponent.TopBarUI&#10;import com.example.game.core.*&#10;import com.example.game.ui.PlaneUI&#10;import com.example.game.ui.WallUI&#10;import com.example.game.ui.SplittingMonsterUI&#10;import com.example.game.ui.SoundControlButton&#10;import com.example.game.ui.BagCoinAnimatedView&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.roundToInt&#10;import kotlin.random.Random&#10;&#10;class Level5Activity : BaseGameActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        initAudio()&#10;&#10;        // Initialize AI Avoidance Helper for smart bullet dodging&#10;        try {&#10;            AIAvoidanceHelper.init(this)&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            // Continue without AI if it fails&#10;        }&#10;&#10;        setContent {&#10;            val density = LocalDensity.current&#10;            val screenWidthPx = with(density) { LocalConfiguration.current.screenWidthDp.dp.toPx() }&#10;            val screenHeightPx = with(density) { LocalConfiguration.current.screenHeightDp.dp.toPx() }&#10;&#10;            Level5Game(&#10;                screenWidthPx = screenWidthPx,&#10;                screenHeightPx = screenHeightPx,&#10;                soundPool = soundPool,&#10;                shootSoundId = shootSoundId,&#10;                hitSoundId = hitSoundId,&#10;                onExit = { finish() }&#10;            )&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        try {&#10;            AIAvoidanceHelper.release()&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Level5Game(&#10;    screenWidthPx: Float,&#10;    screenHeightPx: Float,&#10;    soundPool: android.media.SoundPool,&#10;    shootSoundId: Int,&#10;    hitSoundId: Int,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val playerName = PrefManager.getPlayerName(context)&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // --- State ---&#10;    var totalScore by remember { mutableStateOf(0) }&#10;    var currentSessionScore by remember { mutableStateOf(0) }&#10;    var planeHp by remember { mutableStateOf(100) }&#10;&#10;    var shieldActive by remember { mutableStateOf(false) }&#10;    var wallActive by remember { mutableStateOf(false) }&#10;    var timeActive by remember { mutableStateOf(false) }&#10;&#10;    var isGameOver by remember { mutableStateOf(false) }&#10;    var isLevelClear by remember { mutableStateOf(false) }&#10;    var showGameEndDialog by remember { mutableStateOf(false) }&#10;&#10;    // Show dialog when game ends&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        if (isGameOver || isLevelClear) {&#10;            delay(500)&#10;            showGameEndDialog = true&#10;        }&#10;    }&#10;&#10;    // --- Plane setup ---&#10;    var planeX by remember { mutableStateOf(screenWidthPx / 2 - 50f) }&#10;    val planeY = screenHeightPx - 250f&#10;    val planeWidth = 100f&#10;    val planeHeight = 100f&#10;&#10;    // --- Background ---&#10;    var bg1Y by remember { mutableStateOf(0f) }&#10;    var bg2Y by remember { mutableStateOf(-screenHeightPx) }&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bg1Y += 4f&#10;            bg2Y += 4f&#10;            if (bg1Y &gt;= screenHeightPx) bg1Y = bg2Y - screenHeightPx&#10;            if (bg2Y &gt;= screenHeightPx) bg2Y = bg1Y - screenHeightPx&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Splitting Monsters (dynamic list) ---&#10;    val splittingMonsters = remember { mutableStateListOf&lt;SplittingMonster&gt;() }&#10;&#10;    // Initialize with some parent monsters&#10;    LaunchedEffect(Unit) {&#10;        repeat(8) {&#10;            splittingMonsters.add(&#10;                SplittingMonster(&#10;                    x = Random.nextFloat() * (screenWidthPx - 80f),&#10;                    y = mutableStateOf(-Random.nextInt(200, 2000).toFloat()),&#10;                    speed = Random.nextFloat() * 1.5f + 1.5f,&#10;                    hp = mutableStateOf(100),&#10;                    size = 80f,&#10;                    generation = 1&#10;                )&#10;            )&#10;        }&#10;    }&#10;&#10;    val coins = remember {&#10;        List(6) {&#10;            BaseCoin(&#10;                x = Random.nextFloat() * (screenWidthPx - 50f),&#10;                y = mutableStateOf(-Random.nextInt(100, 600).toFloat()),&#10;                speed = Random.nextFloat() * 2f + 1f&#10;            )&#10;        }&#10;    }&#10;&#10;    val bullets = remember { mutableStateListOf&lt;Bullet&gt;() }&#10;    val bagCoins = remember { mutableStateListOf&lt;BagCoinDisplay&gt;() }&#10;    var chestItems by remember { mutableStateOf&lt;List&lt;ChestItem&gt;&gt;(emptyList()) }&#10;&#10;    // --- Load player data ---&#10;    LaunchedEffect(Unit) {&#10;        if (!playerName.isNullOrBlank()) {&#10;            FirebaseHelper.syncNewPlayer(playerName)&#10;            FirebaseHelper.getScore(playerName) { totalScore = it }&#10;            FirebaseHelper.getChestItems(playerName) { chestItems = it }&#10;        }&#10;    }&#10;&#10;    // --- Shooting ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.add(Bullet(planeX + planeWidth / 2f - 15f, planeY))&#10;            SoundManager.playSoundEffect(soundPool, shootSoundId, 0.5f)&#10;            delay(300)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.forEach { it.y -= 25f }&#10;            bullets.removeAll { it.y &lt; -50f }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Monster movement (zigzag or bounce) + AI evasion ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            // Create a snapshot to avoid concurrent modification&#10;            val currentMonsters = splittingMonsters.toList()&#10;            currentMonsters.forEach { m -&gt;&#10;                if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp; !timeActive) {&#10;                    // AI-based evasion: monster tries to dodge bullets intelligently&#10;                    val evasion = AIAvoidanceHelper.calculateEvasion(&#10;                        monsterX = m.x,&#10;                        monsterY = m.y.value,&#10;                        monsterSize = m.size,&#10;                        bullets = bullets,&#10;                        screenWidth = screenWidthPx&#10;                    )&#10;&#10;                    if (m.isZigzagMovement) {&#10;                        // Zigzag movement combined with AI evasion&#10;                        val combinedX = (m.horizontalSpeed * m.direction) + evasion.first&#10;                        m.x = (m.x + combinedX).coerceIn(0f, screenWidthPx - m.size)&#10;&#10;                        if (m.x &lt;= 0 || m.x &gt;= screenWidthPx - m.size) {&#10;                            m.direction *= -1&#10;                        }&#10;                        m.y.value += m.speed&#10;                    } else {&#10;                        // Bounce movement combined with AI evasion&#10;                        m.x = (m.x + m.velocityX + evasion.first).coerceIn(0f, screenWidthPx - m.size)&#10;                        m.y.value += m.velocityY&#10;&#10;                        // Bounce off walls&#10;                        if (m.x &lt;= 0 || m.x &gt;= screenWidthPx - m.size) {&#10;                            m.velocityX *= -1&#10;                        }&#10;&#10;                        // Bounce off top (optional)&#10;                        if (m.y.value &lt;= 0) {&#10;                            m.velocityY *= -1&#10;                            m.y.value = 0f&#10;                        }&#10;                    }&#10;&#10;                    // Wall collision check&#10;                    val wallTop = planeY - 60f&#10;                    val monsterBottom = m.y.value + m.size&#10;&#10;                    if (wallActive &amp;&amp; monsterBottom &gt;= wallTop) {&#10;                        // Bounce back from wall&#10;                        if (!m.isZigzagMovement) {&#10;                            m.velocityY *= -1&#10;                        }&#10;                    }&#10;&#10;                    // If monster passes plane&#10;                    if (m.y.value &gt; planeY + planeHeight / 2f) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) {&#10;                            val damage = when(m.generation) {&#10;                                1 -&gt; 50 // Large&#10;                                2 -&gt; 30 // Medium&#10;                                else -&gt; 20 // Small&#10;                            }&#10;                            planeHp -= damage&#10;                        }&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Remove dead monsters (but spawn children first)&#10;            splittingMonsters.removeAll { !it.alive.value &amp;&amp; it.hasSpawned.value }&#10;&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Split monsters when killed ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            // Create a snapshot to avoid concurrent modification&#10;            val currentMonsters = splittingMonsters.toList()&#10;            currentMonsters.forEach { m -&gt;&#10;                if (!m.alive.value &amp;&amp; m.canSplit &amp;&amp; !m.hasSpawned.value) {&#10;                    m.hasSpawned.value = true&#10;&#10;                    // Spawn 2-3 smaller monsters&#10;                    val childCount = Random.nextInt(2, 4) // 2 or 3&#10;                    val newSize = m.size * 0.6f // 60% of parent size&#10;                    val newGeneration = m.generation + 1&#10;&#10;                    repeat(childCount) {&#10;                        splittingMonsters.add(&#10;                            SplittingMonster(&#10;                                x = m.x + Random.nextFloat() * 20f - 10f,&#10;                                y = mutableStateOf(m.y.value),&#10;                                speed = m.speed * 1.2f,&#10;                                hp = mutableStateOf(60),&#10;                                size = newSize,&#10;                                generation = newGeneration&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Coin movement ---&#10;    coins.forEach { c -&gt;&#10;        LaunchedEffect(c, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                if (!c.collected.value &amp;&amp; !timeActive) {&#10;                    c.y.value += c.speed&#10;                    if (c.y.value &gt; screenHeightPx) {&#10;                        c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                        c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                    }&#10;                }&#10;                delay(32)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Bullet vs Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            val iter = bullets.iterator()&#10;            while (iter.hasNext()) {&#10;                val b = iter.next()&#10;                // Create snapshot to avoid concurrent modification&#10;                val currentMonsters = splittingMonsters.toList()&#10;                var bulletRemoved = false&#10;                currentMonsters.forEach { m -&gt;&#10;                    if (!bulletRemoved &amp;&amp; CollisionUtils.checkCollisionBulletSplittingMonster(b, m)) {&#10;                        m.hp.value -= 25&#10;                        bulletRemoved = true&#10;                        // Play hit sound when bullet hits monster&#10;                        SoundManager.playSoundEffect(soundPool, hitSoundId, 0.3f)&#10;                        if (m.hp.value &lt;= 0) {&#10;                            m.alive.value = false&#10;                        }&#10;                    }&#10;                }&#10;                if (bulletRemoved) {&#10;                    iter.remove()&#10;                }&#10;            }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Coin collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            coins.forEach { c -&gt;&#10;                if (!c.collected.value &amp;&amp; CollisionUtils.checkCollisionPlaneCoin(planeX, planeY, planeWidth, planeHeight, c)) {&#10;                    c.collected.value = true&#10;                    totalScore += 1&#10;                    currentSessionScore += 1&#10;                    val bag = BagCoinDisplay(c.x, c.y.value, 1)&#10;                    bagCoins.add(bag)&#10;                    if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            // Create snapshot to avoid concurrent modification&#10;            val currentMonsters = splittingMonsters.toList()&#10;            currentMonsters.forEach { m -&gt;&#10;                if (CollisionUtils.checkCollisionPlaneSplittingMonster(planeX, planeY, planeWidth, planeHeight, m)) {&#10;                    if (!shieldActive &amp;&amp; !wallActive) {&#10;                        val damage = when(m.generation) {&#10;                            1 -&gt; 50&#10;                            2 -&gt; 30&#10;                            else -&gt; 20&#10;                        }&#10;                        planeHp -= damage&#10;                    }&#10;                    m.hp.value = 0&#10;                    m.alive.value = false&#10;                }&#10;            }&#10;            if (planeHp &lt;= 0) isGameOver = true&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Wall - Monster collision ---&#10;    LaunchedEffect(wallActive, isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            if (wallActive) {&#10;                // Create snapshot to avoid concurrent modification&#10;                val currentMonsters = splittingMonsters.toList()&#10;                currentMonsters.forEach { m -&gt;&#10;                    if (CollisionUtils.checkCollisionWallSplittingMonster(planeY, m)) {&#10;                        m.hp.value -= 2&#10;                        if (m.hp.value &lt;= 0) {&#10;                            m.alive.value = false&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Use chest item ---&#10;    fun useChestItem(item: ChestItem) {&#10;        ChestItemEffectsBase.applyItemEffect(&#10;            itemName = item.name,&#10;            monsters = splittingMonsters,&#10;            coins = coins,&#10;            bagCoins = bagCoins,&#10;            coroutineScope = coroutineScope,&#10;            screenHeightPx = screenHeightPx,&#10;            planeX = planeX,&#10;            onScoreUpdate = { add -&gt;&#10;                totalScore += add&#10;                currentSessionScore += add&#10;                if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;            },&#10;            onShieldToggle = { active -&gt; shieldActive = active },&#10;            onWallToggle = { active -&gt; wallActive = active },&#10;            onTimeToggle = { active -&gt; timeActive = active },&#10;            onLevelClear = { isLevelClear = true }&#10;        )&#10;        chestItems = chestItems - item&#10;        if (!playerName.isNullOrBlank()) FirebaseHelper.updateChest(playerName, chestItems)&#10;    }&#10;&#10;    // --- Drag plane ---&#10;    val dragModifier = Modifier.pointerInput(Unit) {&#10;        detectDragGestures { change, dragAmount -&gt;&#10;            planeX = (planeX + dragAmount.x).coerceIn(0f, screenWidthPx - planeWidth)&#10;            change.consume()&#10;        }&#10;    }&#10;&#10;    // --- UI ---&#10;    Box(modifier = Modifier.fillMaxSize().then(dragModifier)) {&#10;        // Background&#10;        Image(&#10;            painter = painterResource(R.drawable.vutru1),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg1Y.roundToInt()) }.fillMaxSize(),&#10;            contentScale = ContentScale.Crop&#10;        )&#10;        Image(&#10;            painter = painterResource(R.drawable.vutru1),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg2Y.roundToInt()) }.fillMaxSize(),&#10;            contentScale = ContentScale.Crop&#10;        )&#10;&#10;        // Splitting Monsters&#10;        splittingMonsters.forEach { m -&gt;&#10;            SplittingMonsterUI(monster = m, level = 5)&#10;        }&#10;&#10;        // Coins&#10;        coins.filter { !it.collected.value }.forEach { c -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.coin),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(c.x.roundToInt(), c.y.value.roundToInt()) }&#10;                    .size(40.dp)&#10;            )&#10;        }&#10;&#10;        // BagCoin animated views&#10;        bagCoins.toList().forEach { bag -&gt;&#10;            BagCoinAnimatedView(bag = bag, onFinished = { finishedBag -&gt;&#10;                bagCoins.remove(finishedBag)&#10;            })&#10;        }&#10;&#10;        // Bullets&#10;        bullets.forEach { b -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.dan2),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(b.x.roundToInt(), b.y.roundToInt()) }&#10;                    .size(30.dp)&#10;            )&#10;        }&#10;&#10;        // Plane&#10;        PlaneUI(&#10;            planeX = planeX,&#10;            planeY = planeY,&#10;            planeHp = planeHp,&#10;            shieldActive = shieldActive,&#10;            level = 5&#10;        )&#10;&#10;        // Wall&#10;        if (wallActive) {&#10;            WallUI(planeY = planeY)&#10;        }&#10;&#10;        // Top bar&#10;        TopBarUI(&#10;            bagCoinScore = totalScore,&#10;            chestItems = chestItems,&#10;            onBuyItem = { item, price -&gt;&#10;                if (totalScore &gt;= price) {&#10;                    totalScore -= price&#10;                    chestItems = chestItems + item&#10;                    if (!playerName.isNullOrBlank()) {&#10;                        FirebaseHelper.updateScore(playerName, totalScore)&#10;                        FirebaseHelper.updateChest(playerName, chestItems)&#10;                    }&#10;                }&#10;            },&#10;            onUseChestItem = { useChestItem(it) }&#10;        )&#10;&#10;        // --- Sound Control Button (top-right corner) ---&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp),&#10;            contentAlignment = androidx.compose.ui.Alignment.TopEnd&#10;        ) {&#10;            SoundControlButton()&#10;        }&#10;    }&#10;&#10;    // --- Game End Dialog ---&#10;    if (showGameEndDialog) {&#10;        GameEndDialog(&#10;            isWin = isLevelClear,&#10;            score = currentSessionScore,&#10;            level = 5,&#10;            onDismiss = {&#10;                showGameEndDialog = false&#10;            },&#10;            onReplay = {&#10;                showGameEndDialog = false&#10;                isGameOver = false&#10;                isLevelClear = false&#10;                planeHp = 100&#10;                currentSessionScore = 0&#10;&#10;                splittingMonsters.clear()&#10;                repeat(8) {&#10;                    splittingMonsters.add(&#10;                        SplittingMonster(&#10;                            x = Random.nextFloat() * (screenWidthPx - 80f),&#10;                            y = mutableStateOf(-Random.nextInt(200, 2000).toFloat()),&#10;                            speed = Random.nextFloat() * 1.5f + 1.5f,&#10;                            hp = mutableStateOf(100),&#10;                            size = 80f,&#10;                            generation = 1&#10;                        )&#10;                    )&#10;                }&#10;&#10;                coins.forEach { c -&gt;&#10;                    c.collected.value = false&#10;                    c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                    c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                }&#10;&#10;                bullets.clear()&#10;            },&#10;            onNextLevel = {&#10;                onExit()&#10;            },&#10;            onExit = {&#10;                onExit()&#10;            }&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.game&#10;&#10;import android.os.Bundle&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.TopBarComponent.TopBarUI&#10;import com.example.game.core.*&#10;import com.example.game.ui.PlaneUI&#10;import com.example.game.ui.WallUI&#10;import com.example.game.ui.SplittingMonsterUI&#10;import com.example.game.ui.SoundControlButton&#10;import com.example.game.ui.BagCoinAnimatedView&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.roundToInt&#10;import kotlin.random.Random&#10;&#10;class Level5Activity : BaseGameActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        initAudio()&#10;&#10;        // Initialize AI Avoidance Helper for smart bullet dodging&#10;        try {&#10;            AIAvoidanceHelper.init(this)&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            // Continue without AI if it fails&#10;        }&#10;&#10;        setContent {&#10;            val density = LocalDensity.current&#10;            val screenWidthPx = with(density) { LocalConfiguration.current.screenWidthDp.dp.toPx() }&#10;            val screenHeightPx = with(density) { LocalConfiguration.current.screenHeightDp.dp.toPx() }&#10;&#10;            Level5Game(&#10;                screenWidthPx = screenWidthPx,&#10;                screenHeightPx = screenHeightPx,&#10;                soundPool = soundPool,&#10;                shootSoundId = shootSoundId,&#10;                hitSoundId = hitSoundId,&#10;                onExit = { finish() }&#10;            )&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        try {&#10;            AIAvoidanceHelper.release()&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Level5Game(&#10;    screenWidthPx: Float,&#10;    screenHeightPx: Float,&#10;    soundPool: android.media.SoundPool,&#10;    shootSoundId: Int,&#10;    hitSoundId: Int,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val playerName = PrefManager.getPlayerName(context)&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // --- State ---&#10;    var totalScore by remember { mutableStateOf(0) }&#10;    var currentSessionScore by remember { mutableStateOf(0) }&#10;    var planeHp by remember { mutableStateOf(100) }&#10;&#10;    var shieldActive by remember { mutableStateOf(false) }&#10;    var wallActive by remember { mutableStateOf(false) }&#10;    var timeActive by remember { mutableStateOf(false) }&#10;&#10;    var isGameOver by remember { mutableStateOf(false) }&#10;    var isLevelClear by remember { mutableStateOf(false) }&#10;    var showGameEndDialog by remember { mutableStateOf(false) }&#10;&#10;    // Show dialog when game ends&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        if (isGameOver || isLevelClear) {&#10;            delay(500)&#10;            showGameEndDialog = true&#10;        }&#10;    }&#10;&#10;    // --- Plane setup ---&#10;    var planeX by remember { mutableStateOf(screenWidthPx / 2 - 50f) }&#10;    val planeY = screenHeightPx - 250f&#10;    val planeWidth = 100f&#10;    val planeHeight = 100f&#10;&#10;    // --- Background ---&#10;    var bg1Y by remember { mutableStateOf(0f) }&#10;    var bg2Y by remember { mutableStateOf(-screenHeightPx) }&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bg1Y += 4f&#10;            bg2Y += 4f&#10;            if (bg1Y &gt;= screenHeightPx) bg1Y = bg2Y - screenHeightPx&#10;            if (bg2Y &gt;= screenHeightPx) bg2Y = bg1Y - screenHeightPx&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Splitting Monsters (dynamic list) ---&#10;    val splittingMonsters = remember { mutableStateListOf&lt;SplittingMonster&gt;() }&#10;&#10;    // Initialize with some parent monsters&#10;    LaunchedEffect(Unit) {&#10;        repeat(8) {&#10;            splittingMonsters.add(&#10;                SplittingMonster(&#10;                    x = Random.nextFloat() * (screenWidthPx - 80f),&#10;                    y = mutableStateOf(-Random.nextInt(200, 2000).toFloat()),&#10;                    speed = Random.nextFloat() * 1.5f + 1.5f,&#10;                    hp = mutableStateOf(100),&#10;                    size = 80f,&#10;                    generation = 1&#10;                )&#10;            )&#10;        }&#10;    }&#10;&#10;    val coins = remember {&#10;        List(6) {&#10;            BaseCoin(&#10;                x = Random.nextFloat() * (screenWidthPx - 50f),&#10;                y = mutableStateOf(-Random.nextInt(100, 600).toFloat()),&#10;                speed = Random.nextFloat() * 2f + 1f&#10;            )&#10;        }&#10;    }&#10;&#10;    val bullets = remember { mutableStateListOf&lt;Bullet&gt;() }&#10;    val bagCoins = remember { mutableStateListOf&lt;BagCoinDisplay&gt;() }&#10;    var chestItems by remember { mutableStateOf&lt;List&lt;ChestItem&gt;&gt;(emptyList()) }&#10;&#10;    // --- Load player data ---&#10;    LaunchedEffect(Unit) {&#10;        if (!playerName.isNullOrBlank()) {&#10;            FirebaseHelper.syncNewPlayer(playerName)&#10;            FirebaseHelper.getScore(playerName) { totalScore = it }&#10;            FirebaseHelper.getChestItems(playerName) { chestItems = it }&#10;        }&#10;    }&#10;&#10;    // --- Shooting ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.add(Bullet(planeX + planeWidth / 2f - 15f, planeY))&#10;            SoundManager.playSoundEffect(soundPool, shootSoundId, 0.5f)&#10;            delay(300)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.forEach { it.y -= 25f }&#10;            bullets.removeAll { it.y &lt; -50f }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Monster movement (zigzag or bounce) + AI evasion ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            // Create a snapshot to avoid concurrent modification&#10;            val currentMonsters = splittingMonsters.toList()&#10;            currentMonsters.forEach { m -&gt;&#10;                if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp; !timeActive) {&#10;                    // AI-based evasion: monster tries to dodge bullets intelligently&#10;                    val evasion = AIAvoidanceHelper.calculateEvasion(&#10;                        monsterX = m.x,&#10;                        monsterY = m.y.value,&#10;                        monsterSize = m.size,&#10;                        bullets = bullets,&#10;                        screenWidth = screenWidthPx&#10;                    )&#10;&#10;                    if (m.isZigzagMovement) {&#10;                        // Zigzag movement combined with AI evasion&#10;                        val combinedX = (m.horizontalSpeed * m.direction) + evasion.first&#10;                        m.x = (m.x + combinedX).coerceIn(0f, screenWidthPx - m.size)&#10;&#10;                        if (m.x &lt;= 0 || m.x &gt;= screenWidthPx - m.size) {&#10;                            m.direction *= -1&#10;                        }&#10;                        m.y.value += m.speed&#10;                    } else {&#10;                        // Bounce movement combined with AI evasion&#10;                        m.x = (m.x + m.velocityX + evasion.first).coerceIn(0f, screenWidthPx - m.size)&#10;                        m.y.value += m.velocityY&#10;&#10;                        // Bounce off walls&#10;                        if (m.x &lt;= 0 || m.x &gt;= screenWidthPx - m.size) {&#10;                            m.velocityX *= -1&#10;                        }&#10;&#10;                        // Bounce off top (optional)&#10;                        if (m.y.value &lt;= 0) {&#10;                            m.velocityY *= -1&#10;                            m.y.value = 0f&#10;                        }&#10;                    }&#10;&#10;                    // Wall collision check&#10;                    val wallTop = planeY - 60f&#10;                    val monsterBottom = m.y.value + m.size&#10;&#10;                    if (wallActive &amp;&amp; monsterBottom &gt;= wallTop) {&#10;                        // Bounce back from wall&#10;                        if (!m.isZigzagMovement) {&#10;                            m.velocityY *= -1&#10;                        }&#10;                    }&#10;&#10;                    // If monster passes plane&#10;                    if (m.y.value &gt; planeY + planeHeight / 2f) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) {&#10;                            val damage = when(m.generation) {&#10;                                1 -&gt; 50 // Large&#10;                                2 -&gt; 30 // Medium&#10;                                else -&gt; 20 // Small&#10;                            }&#10;                            planeHp -= damage&#10;                        }&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Remove dead monsters (but spawn children first)&#10;            splittingMonsters.removeAll { !it.alive.value &amp;&amp; it.hasSpawned.value }&#10;&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Split monsters when killed ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            // Create a snapshot to avoid concurrent modification&#10;            val currentMonsters = splittingMonsters.toList()&#10;            currentMonsters.forEach { m -&gt;&#10;                if (!m.alive.value &amp;&amp; m.canSplit &amp;&amp; !m.hasSpawned.value) {&#10;                    m.hasSpawned.value = true&#10;&#10;                    // Spawn 2-3 smaller monsters&#10;                    val childCount = Random.nextInt(2, 4) // 2 or 3&#10;                    val newSize = m.size * 0.6f // 60% of parent size&#10;                    val newGeneration = m.generation + 1&#10;&#10;                    repeat(childCount) {&#10;                        splittingMonsters.add(&#10;                            SplittingMonster(&#10;                                x = m.x + Random.nextFloat() * 20f - 10f,&#10;                                y = mutableStateOf(m.y.value),&#10;                                speed = m.speed * 1.2f,&#10;                                hp = mutableStateOf(60),&#10;                                size = newSize,&#10;                                generation = newGeneration&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Coin movement ---&#10;    coins.forEach { c -&gt;&#10;        LaunchedEffect(c, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                if (!c.collected.value &amp;&amp; !timeActive) {&#10;                    c.y.value += c.speed&#10;                    if (c.y.value &gt; screenHeightPx) {&#10;                        c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                        c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                    }&#10;                }&#10;                delay(32)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Bullet vs Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            val iter = bullets.iterator()&#10;            while (iter.hasNext()) {&#10;                val b = iter.next()&#10;                // Create snapshot to avoid concurrent modification&#10;                val currentMonsters = splittingMonsters.toList()&#10;                var bulletRemoved = false&#10;                currentMonsters.forEach { m -&gt;&#10;                    if (!bulletRemoved &amp;&amp; CollisionUtils.checkCollisionBulletSplittingMonster(b, m)) {&#10;                        m.hp.value -= 25&#10;                        bulletRemoved = true&#10;                        // Play hit sound when bullet hits monster&#10;                        SoundManager.playSoundEffect(soundPool, hitSoundId, 0.3f)&#10;                        if (m.hp.value &lt;= 0) {&#10;                            m.alive.value = false&#10;                        }&#10;                    }&#10;                }&#10;                if (bulletRemoved) {&#10;                    iter.remove()&#10;                }&#10;            }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Coin collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            coins.forEach { c -&gt;&#10;                if (!c.collected.value &amp;&amp; CollisionUtils.checkCollisionPlaneCoin(planeX, planeY, planeWidth, planeHeight, c)) {&#10;                    c.collected.value = true&#10;                    totalScore += 1&#10;                    currentSessionScore += 1&#10;                    val bag = BagCoinDisplay(c.x, c.y.value, 1)&#10;                    bagCoins.add(bag)&#10;                    if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            // Create snapshot to avoid concurrent modification&#10;            val currentMonsters = splittingMonsters.toList()&#10;            currentMonsters.forEach { m -&gt;&#10;                if (CollisionUtils.checkCollisionPlaneSplittingMonster(planeX, planeY, planeWidth, planeHeight, m)) {&#10;                    if (!shieldActive &amp;&amp; !wallActive) {&#10;                        val damage = when(m.generation) {&#10;                            1 -&gt; 50&#10;                            2 -&gt; 30&#10;                            else -&gt; 20&#10;                        }&#10;                        planeHp -= damage&#10;                    }&#10;                    m.hp.value = 0&#10;                    m.alive.value = false&#10;                }&#10;            }&#10;            if (planeHp &lt;= 0) isGameOver = true&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Wall - Monster collision ---&#10;    LaunchedEffect(wallActive, isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            if (wallActive) {&#10;                // Create snapshot to avoid concurrent modification&#10;                val currentMonsters = splittingMonsters.toList()&#10;                currentMonsters.forEach { m -&gt;&#10;                    if (CollisionUtils.checkCollisionWallSplittingMonster(planeY, m)) {&#10;                        m.hp.value -= 2&#10;                        if (m.hp.value &lt;= 0) {&#10;                            m.alive.value = false&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Use chest item ---&#10;    fun useChestItem(item: ChestItem) {&#10;        ChestItemEffectsBase.applyItemEffect(&#10;            itemName = item.name,&#10;            monsters = splittingMonsters,&#10;            coins = coins,&#10;            bagCoins = bagCoins,&#10;            coroutineScope = coroutineScope,&#10;            screenHeightPx = screenHeightPx,&#10;            planeX = planeX,&#10;            onScoreUpdate = { add -&gt;&#10;                totalScore += add&#10;                currentSessionScore += add&#10;                if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;            },&#10;            onShieldToggle = { active -&gt; shieldActive = active },&#10;            onWallToggle = { active -&gt; wallActive = active },&#10;            onTimeToggle = { active -&gt; timeActive = active },&#10;            onLevelClear = { isLevelClear = true }&#10;        )&#10;        chestItems = chestItems - item&#10;        if (!playerName.isNullOrBlank()) FirebaseHelper.updateChest(playerName, chestItems)&#10;    }&#10;&#10;    // --- Drag plane ---&#10;    val dragModifier = Modifier.pointerInput(Unit) {&#10;        detectDragGestures { change, dragAmount -&gt;&#10;            planeX = (planeX + dragAmount.x).coerceIn(0f, screenWidthPx - planeWidth)&#10;            change.consume()&#10;        }&#10;    }&#10;&#10;    // --- UI ---&#10;    Box(modifier = Modifier.fillMaxSize()) {&#10;        // Background layer - separate from drag gestures&#10;        Box(modifier = Modifier.fillMaxSize()) {&#10;            // Background&#10;            Image(&#10;                painter = painterResource(R.drawable.vutru1),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .offset { IntOffset(0, bg1Y.roundToInt()) },&#10;                contentScale = ContentScale.Crop&#10;            )&#10;            Image(&#10;                painter = painterResource(R.drawable.vutru1),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .offset { IntOffset(0, bg2Y.roundToInt()) },&#10;                contentScale = ContentScale.Crop&#10;            )&#10;        }&#10;&#10;        // Game content with drag gesture&#10;        Box(modifier = Modifier.fillMaxSize().then(dragModifier)) {&#10;            // Splitting Monsters&#10;            splittingMonsters.forEach { m -&gt;&#10;                SplittingMonsterUI(monster = m, level = 5)&#10;            }&#10;&#10;            // Coins&#10;            coins.filter { !it.collected.value }.forEach { c -&gt;&#10;                Image(&#10;                    painter = painterResource(R.drawable.coin),&#10;                    contentDescription = null,&#10;                    modifier = Modifier&#10;                        .absoluteOffset { IntOffset(c.x.roundToInt(), c.y.value.roundToInt()) }&#10;                        .size(40.dp)&#10;                )&#10;            }&#10;&#10;            // BagCoin animated views&#10;            bagCoins.toList().forEach { bag -&gt;&#10;                BagCoinAnimatedView(bag = bag, onFinished = { finishedBag -&gt;&#10;                    bagCoins.remove(finishedBag)&#10;                })&#10;            }&#10;&#10;            // Bullets&#10;            bullets.forEach { b -&gt;&#10;                Image(&#10;                    painter = painterResource(R.drawable.dan2),&#10;                    contentDescription = null,&#10;                    modifier = Modifier&#10;                        .absoluteOffset { IntOffset(b.x.roundToInt(), b.y.roundToInt()) }&#10;                        .size(30.dp)&#10;                )&#10;            }&#10;&#10;            // Plane&#10;            PlaneUI(&#10;                planeX = planeX,&#10;                planeY = planeY,&#10;                planeHp = planeHp,&#10;                shieldActive = shieldActive,&#10;                level = 5&#10;            )&#10;&#10;            // Wall&#10;            if (wallActive) {&#10;                WallUI(planeY = planeY)&#10;            }&#10;&#10;            // Top bar&#10;            TopBarUI(&#10;                bagCoinScore = totalScore,&#10;                chestItems = chestItems,&#10;                onBuyItem = { item, price -&gt;&#10;                    if (totalScore &gt;= price) {&#10;                        totalScore -= price&#10;                        chestItems = chestItems + item&#10;                        if (!playerName.isNullOrBlank()) {&#10;                            FirebaseHelper.updateScore(playerName, totalScore)&#10;                            FirebaseHelper.updateChest(playerName, chestItems)&#10;                        }&#10;                    }&#10;                },&#10;                onUseChestItem = { useChestItem(it) }&#10;            )&#10;&#10;            // --- Sound Control Button (top-right corner) ---&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(16.dp),&#10;                contentAlignment = Alignment.TopEnd&#10;            ) {&#10;                SoundControlButton()&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Game End Dialog ---&#10;    if (showGameEndDialog) {&#10;        GameEndDialog(&#10;            isWin = isLevelClear,&#10;            score = currentSessionScore,&#10;            level = 5,&#10;            onDismiss = {&#10;                showGameEndDialog = false&#10;            },&#10;            onReplay = {&#10;                showGameEndDialog = false&#10;                isGameOver = false&#10;                isLevelClear = false&#10;                planeHp = 100&#10;                currentSessionScore = 0&#10;&#10;                splittingMonsters.clear()&#10;                repeat(8) {&#10;                    splittingMonsters.add(&#10;                        SplittingMonster(&#10;                            x = Random.nextFloat() * (screenWidthPx - 80f),&#10;                            y = mutableStateOf(-Random.nextInt(200, 2000).toFloat()),&#10;                            speed = Random.nextFloat() * 1.5f + 1.5f,&#10;                            hp = mutableStateOf(100),&#10;                            size = 80f,&#10;                            generation = 1&#10;                        )&#10;                    )&#10;                }&#10;&#10;                coins.forEach { c -&gt;&#10;                    c.collected.value = false&#10;                    c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                    c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                }&#10;&#10;                bullets.clear()&#10;            },&#10;            onNextLevel = {&#10;                onExit()&#10;            },&#10;            onExit = {&#10;                onExit()&#10;            }&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>
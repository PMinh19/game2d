<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/game/Level2Activity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/game/Level2Activity.kt" />
              <option name="originalContent" value="package com.example.game&#10;&#10;import android.os.Bundle&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.TopBarComponent.TopBarUI&#10;import com.example.game.core.*&#10;import com.example.game.ui.PlaneUI&#10;import com.example.game.ui.MonsterUI&#10;import com.example.game.ui.WallUI&#10;import com.example.game.ui.SoundControlButton&#10;import com.example.game.ui.BagCoinAnimatedView&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.*&#10;import kotlin.random.Random&#10;&#10;class Level2Activity : BaseGameActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        initAudio()&#10;&#10;        // Initialize AI Avoidance Helper for smart bullet dodging&#10;        AIAvoidanceHelper.init(this)&#10;&#10;        setContent {&#10;            val density = LocalDensity.current&#10;            val screenWidthPx = with(density) { LocalConfiguration.current.screenWidthDp.dp.toPx() }&#10;            val screenHeightPx = with(density) { LocalConfiguration.current.screenHeightDp.dp.toPx() }&#10;&#10;            Level2Game(&#10;                screenWidthPx = screenWidthPx,&#10;                screenHeightPx = screenHeightPx,&#10;                soundPool = soundPool,&#10;                shootSoundId = shootSoundId,&#10;                hitSoundId = hitSoundId,&#10;                onExit = { finish() }&#10;            )&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        AIAvoidanceHelper.release()&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Level2Game(&#10;    screenWidthPx: Float,&#10;    screenHeightPx: Float,&#10;    soundPool: android.media.SoundPool,&#10;    shootSoundId: Int,&#10;    hitSoundId: Int,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val playerName = PrefManager.getPlayerName(context)&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // --- State ---&#10;    var totalScore by remember { mutableStateOf(0) }&#10;    var currentSessionScore by remember { mutableStateOf(0) }&#10;    var planeHp by remember { mutableStateOf(100) }&#10;&#10;    var shieldActive by remember { mutableStateOf(false) }&#10;    var wallActive by remember { mutableStateOf(false) }&#10;    var timeActive by remember { mutableStateOf(false) }&#10;&#10;    var isGameOver by remember { mutableStateOf(false) }&#10;    var isLevelClear by remember { mutableStateOf(false) }&#10;    var showGameEndDialog by remember { mutableStateOf(false) }&#10;&#10;    // Show dialog when game ends instead of navigating to new activity&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        if (isGameOver || isLevelClear) {&#10;            delay(500)&#10;            showGameEndDialog = true&#10;        }&#10;    }&#10;&#10;    // --- Plane setup ---&#10;    var planeX by remember { mutableStateOf(screenWidthPx / 2 - 50f) }&#10;    val planeY = screenHeightPx - 250f&#10;    val planeWidth = 100f&#10;    val planeHeight = 100f&#10;&#10;    // --- Background ---&#10;    var bg1Y by remember { mutableStateOf(0f) }&#10;    var bg2Y by remember { mutableStateOf(-screenHeightPx) }&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bg1Y += 4f&#10;            bg2Y += 4f&#10;            if (bg1Y &gt;= screenHeightPx) bg1Y = bg2Y - screenHeightPx&#10;            if (bg2Y &gt;= screenHeightPx) bg2Y = bg1Y - screenHeightPx&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Entities: 5 rotating monster groups ---&#10;    val monsterGroups = remember {&#10;        List(5) { i -&gt;&#10;            RotatingMonsterGroup(&#10;                centerX = Random.nextFloat() * (screenWidthPx - 300f) + 150f, // Random X position&#10;                centerY = -300f, // Start just above screen&#10;                radius = 100f,&#10;                angleOffset = Random.nextFloat() * 360f, // Random starting angle&#10;                vx = if (Random.nextBoolean()) Random.nextFloat() * 2f + 2f else -(Random.nextFloat() * 2f + 2f),&#10;                vy = Random.nextFloat() * 2f + 3f // Random vertical speed (3-5f)&#10;            ).apply {&#10;                // Initially set monsters as dead - they will spawn with delay&#10;                monsters.forEach { it.alive.value = false }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Track respawn times for each group&#10;    val groupRespawnTimes = remember { MutableList(monsterGroups.size) { i -&gt; System.currentTimeMillis() + (i * 3000L) } }&#10;&#10;    val coins = remember {&#10;        List(7) {&#10;            BaseCoin(&#10;                x = Random.nextFloat() * (screenWidthPx - 50f),&#10;                y = mutableStateOf(-Random.nextInt(100, 800).toFloat()),&#10;                speed = Random.nextFloat() * 2f + 1.5f&#10;            )&#10;        }&#10;    }&#10;&#10;    val bullets = remember { mutableStateListOf&lt;Bullet&gt;() }&#10;    val bagCoins = remember { mutableStateListOf&lt;BagCoinDisplay&gt;() }&#10;    var chestItems by remember { mutableStateOf&lt;List&lt;ChestItem&gt;&gt;(emptyList()) }&#10;&#10;    // --- Load player data ---&#10;    LaunchedEffect(Unit) {&#10;        if (!playerName.isNullOrBlank()) {&#10;            FirebaseHelper.syncNewPlayer(playerName)&#10;            FirebaseHelper.getScore(playerName) { totalScore = it }&#10;            FirebaseHelper.getChestItems(playerName) { chestItems = it }&#10;        }&#10;    }&#10;&#10;    // --- Shooting ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.add(Bullet(planeX + planeWidth / 2 - 15f, planeY))&#10;            SoundManager.playSoundEffect(soundPool, shootSoundId, 0.5f)&#10;            delay(300)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.forEach { it.y -= 25f }&#10;            bullets.removeAll { it.y &lt; -50f }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Monster groups movement + rotation ---&#10;    monsterGroups.forEachIndexed { index, group -&gt;&#10;        LaunchedEffect(group, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                // Check if group needs to respawn&#10;                val allDead = group.monsters.all { !it.alive.value }&#10;                if (allDead &amp;&amp; System.currentTimeMillis() &gt;= groupRespawnTimes[index]) {&#10;                    // Respawn group at random position&#10;                    group.centerX = Random.nextFloat() * (screenWidthPx - 300f) + 150f&#10;                    group.centerY = -300f&#10;                    group.vx = if (Random.nextBoolean()) Random.nextFloat() * 2f + 2f else -(Random.nextFloat() * 2f + 2f)&#10;                    group.vy = Random.nextFloat() * 2f + 3f&#10;                    group.angleOffset = Random.nextFloat() * 360f // Random rotation angle&#10;                    group.monsters.forEach { m -&gt;&#10;                        m.hp.value = 100&#10;                        m.alive.value = true&#10;                    }&#10;                    // Update positions to match new center and angle&#10;                    group.updatePositions()&#10;                    // Set next respawn time with random delay (3-5 seconds)&#10;                    groupRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 5000)&#10;                }&#10;&#10;                if (!timeActive &amp;&amp; !allDead) {&#10;                    // Rotate monsters&#10;                    group.angleOffset += 3f&#10;&#10;                    // Move center&#10;                    group.centerX += group.vx&#10;                    group.centerY += group.vy&#10;&#10;                    // Bounce off LEFT wall - reverse to RIGHT&#10;                    if (group.centerX &lt;= 150f) {&#10;                        group.centerX = 150f&#10;                        group.vx = abs(group.vx) // Bounce to opposite direction (right)&#10;                    }&#10;&#10;                    // Bounce off RIGHT wall - reverse to LEFT&#10;                    if (group.centerX &gt;= screenWidthPx - 150f) {&#10;                        group.centerX = screenWidthPx - 150f&#10;                        group.vx = -abs(group.vx) // Bounce to opposite direction (left)&#10;                    }&#10;&#10;                    // Bounce off TOP - reverse to DOWN&#10;                    if (group.centerY &lt;= 150f) {&#10;                        group.centerY = 150f&#10;                        group.vy = abs(group.vy) // Bounce to opposite direction (down)&#10;                    }&#10;&#10;                    // Bounce off BOTTOM - reverse to UP&#10;                    if (group.centerY &gt;= screenHeightPx - 300f) {&#10;                        group.centerY = screenHeightPx - 300f&#10;                        group.vy = -abs(group.vy) // Bounce to opposite direction (up)&#10;                    }&#10;&#10;                    // Update monster positions&#10;                    group.updatePositions()&#10;&#10;                    // Respawn if group goes way off screen (safety check)&#10;                    if (group.centerY &gt; screenHeightPx + 500f || group.centerY &lt; -1000f) {&#10;                        groupRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(2000, 5000)&#10;                        group.monsters.forEach { it.alive.value = false }&#10;                    }&#10;                }&#10;                delay(16)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Coin movement ---&#10;    coins.forEach { c -&gt;&#10;        LaunchedEffect(c, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                if (!c.collected.value &amp;&amp; !timeActive) {&#10;                    c.y.value += c.speed&#10;                    if (c.y.value &gt; screenHeightPx) {&#10;                        c.y.value = -Random.nextInt(100, 800).toFloat()&#10;                        c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                    }&#10;                }&#10;                delay(32)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Bullet vs Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            val iter = bullets.iterator()&#10;            while (iter.hasNext()) {&#10;                val b = iter.next()&#10;                monsterGroups.forEach { group -&gt;&#10;                    group.monsters.forEach { m -&gt;&#10;                        if (CollisionUtils.checkCollisionBulletMonster(b, m)) {&#10;                            m.hp.value -= 25&#10;                            // Play hit sound&#10;                            SoundManager.playSoundEffect(soundPool, hitSoundId, 0.3f)&#10;                            iter.remove()&#10;                            if (m.hp.value &lt;= 0) {&#10;                                m.alive.value = false&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Coin collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            coins.forEach { c -&gt;&#10;                if (!c.collected.value &amp;&amp; CollisionUtils.checkCollisionPlaneCoin(planeX, planeY, planeWidth, planeHeight, c)) {&#10;                    c.collected.value = true&#10;                    totalScore += 1&#10;                    currentSessionScore += 1&#10;                    val bag = BagCoinDisplay(c.x, c.y.value, 1)&#10;                    bagCoins.add(bag)&#10;                    if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            monsterGroups.forEach { group -&gt;&#10;                group.monsters.forEach { m -&gt;&#10;                    if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp;&#10;                        CollisionUtils.checkCollisionPlaneMonster(planeX, planeY, planeWidth, planeHeight, m)&#10;                    ) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) planeHp -= 50&#10;                        m.hp.value = 0&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;            }&#10;            if (planeHp &lt;= 0) isGameOver = true&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Wall - Monster collision ---&#10;    LaunchedEffect(wallActive, isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            if (wallActive) {&#10;                monsterGroups.forEach { group -&gt;&#10;                    group.monsters.forEach { m -&gt;&#10;                        if (m.alive.value &amp;&amp; m.hp.value &gt; 0) {&#10;                            if (CollisionUtils.checkCollisionWallMonster(planeY, m)) {&#10;                                m.hp.value -= 2&#10;                                if (m.hp.value &lt;= 0) {&#10;                                    m.alive.value = false&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Use chest item ---&#10;    fun useChestItem(item: ChestItem) {&#10;        // Flatten all monsters from groups for ChestItemEffectsBase&#10;        val allMonsters = monsterGroups.flatMap { it.monsters }&#10;        ChestItemEffectsBase.applyItemEffect(&#10;            itemName = item.name,&#10;            monsters = allMonsters,&#10;            coins = coins,&#10;            bagCoins = bagCoins,&#10;            coroutineScope = coroutineScope,&#10;            screenHeightPx = screenHeightPx,&#10;            planeX = planeX,&#10;            onScoreUpdate = { add -&gt;&#10;                totalScore += add&#10;                currentSessionScore += add&#10;                if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;            },&#10;            onShieldToggle = { active -&gt; shieldActive = active },&#10;            onWallToggle = { active -&gt; wallActive = active },&#10;            onTimeToggle = { active -&gt; timeActive = active },&#10;            onLevelClear = { isLevelClear = true }&#10;        )&#10;        chestItems = chestItems - item&#10;        if (!playerName.isNullOrBlank()) FirebaseHelper.updateChest(playerName, chestItems)&#10;    }&#10;&#10;    // --- Drag plane ---&#10;    val dragModifier = Modifier.pointerInput(Unit) {&#10;        detectDragGestures { change, dragAmount -&gt;&#10;            planeX = (planeX + dragAmount.x).coerceIn(0f, screenWidthPx - planeWidth)&#10;            change.consume()&#10;        }&#10;    }&#10;&#10;    // --- UI ---&#10;    Box(modifier = Modifier.fillMaxSize().then(dragModifier)) {&#10;        // Background&#10;        Image(&#10;            painter = painterResource(R.drawable.nen2),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg1Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;        Image(&#10;            painter = painterResource(R.drawable.nen2),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg2Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;&#10;        // Monsters (using MonsterUI component)&#10;        monsterGroups.forEach { group -&gt;&#10;            group.monsters.forEach { m -&gt;&#10;                MonsterUI(monster = m)&#10;            }&#10;        }&#10;&#10;        // Coins&#10;        coins.filter { !it.collected.value }.forEach { c -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.coin),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(c.x.roundToInt(), c.y.value.roundToInt()) }&#10;                    .size(40.dp)&#10;            )&#10;        }&#10;&#10;        // BagCoin animated views&#10;        bagCoins.toList().forEach { bag -&gt;&#10;            BagCoinAnimatedView(bag = bag, onFinished = { finishedBag -&gt;&#10;                bagCoins.remove(finishedBag)&#10;            })&#10;        }&#10;&#10;        // Bullets&#10;        bullets.forEach { b -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.dan2),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(b.x.roundToInt(), b.y.roundToInt()) }&#10;                    .size(30.dp)&#10;            )&#10;        }&#10;&#10;        // Plane (using PlaneUI component)&#10;        PlaneUI(&#10;            planeX = planeX,&#10;            planeY = planeY,&#10;            planeHp = planeHp,&#10;            shieldActive = shieldActive&#10;        )&#10;&#10;        // Wall (using WallUI component)&#10;        if (wallActive) {&#10;            WallUI(planeY = planeY)&#10;        }&#10;&#10;        // Top bar&#10;        TopBarUI(&#10;            bagCoinScore = totalScore,&#10;            chestItems = chestItems,&#10;            onBuyItem = { item, price -&gt;&#10;                if (totalScore &gt;= price) {&#10;                    totalScore -= price&#10;                    chestItems = chestItems + item&#10;                    if (!playerName.isNullOrBlank()) {&#10;                        FirebaseHelper.updateScore(playerName, totalScore)&#10;                        FirebaseHelper.updateChest(playerName, chestItems)&#10;                    }&#10;                }&#10;            },&#10;            onUseChestItem = { useChestItem(it) }&#10;        )&#10;&#10;        // --- Sound Control Button (top-right corner) ---&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp),&#10;            contentAlignment = Alignment.TopEnd&#10;        ) {&#10;            SoundControlButton()&#10;        }&#10;    }&#10;&#10;    // --- Game End Dialog ---&#10;    if (showGameEndDialog) {&#10;        GameEndDialog(&#10;            isWin = isLevelClear,&#10;            score = currentSessionScore,&#10;            level = 2,&#10;            onDismiss = {&#10;                showGameEndDialog = false&#10;            },&#10;            onReplay = {&#10;                // Reset game state to replay&#10;                showGameEndDialog = false&#10;                isGameOver = false&#10;                isLevelClear = false&#10;                planeHp = 100&#10;                currentSessionScore = 0&#10;&#10;                // Reset monsters&#10;                monsterGroups.forEach { group -&gt;&#10;                    group.centerX = Random.nextFloat() * (screenWidthPx - 300f) + 150f&#10;                    group.centerY = -300f&#10;                    group.vx = if (Random.nextBoolean()) Random.nextFloat() * 2f + 2f else -(Random.nextFloat() * 2f + 2f)&#10;                    group.vy = Random.nextFloat() * 2f + 3f&#10;                    group.angleOffset = Random.nextFloat() * 360f&#10;                    group.monsters.forEach { m -&gt;&#10;                        m.hp.value = 100&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;&#10;                // Reset respawn times&#10;                for (i in groupRespawnTimes.indices) {&#10;                    groupRespawnTimes[i] = System.currentTimeMillis() + (i * 3000L)&#10;                }&#10;&#10;                // Reset coins&#10;                coins.forEach { c -&gt;&#10;                    c.collected.value = false&#10;                    c.y.value = -Random.nextInt(100, 800).toFloat()&#10;                    c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                }&#10;&#10;                // Clear bullets&#10;                bullets.clear()&#10;            },&#10;            onNextLevel = {&#10;                // Navigate to next level handled by GameEndDialog itself&#10;                onExit() // Close this activity&#10;            },&#10;            onExit = {&#10;                // Back to main menu&#10;                onExit()&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * BagCoinAnimatedView for Level 2&#10; * - Animates a bag coin sprite moving slightly up and fading out.&#10; * - Calls onFinished(bag) when animation done so caller can remove it.&#10; */&#10;@Composable&#10;private fun BagCoinAnimatedView(bag: BagCoinDisplay, onFinished: (BagCoinDisplay) -&gt; Unit) {&#10;    var offsetY by remember { mutableStateOf(bag.y) }&#10;    var alpha by remember { mutableStateOf(1f) }&#10;&#10;    LaunchedEffect(bag) {&#10;        val duration = 800L&#10;        val steps = 40&#10;        repeat(steps) { i -&gt;&#10;            offsetY -= 2f&#10;            alpha = 1f - (i / steps.toFloat())&#10;            delay(duration / steps)&#10;        }&#10;        onFinished(bag)&#10;    }&#10;&#10;    Image(&#10;        painter = painterResource(R.drawable.bagcoin),&#10;        contentDescription = null,&#10;        modifier = Modifier&#10;            .absoluteOffset { IntOffset(bag.x.roundToInt(), offsetY.roundToInt()) }&#10;            .size(60.dp)&#10;            .graphicsLayer { this.alpha = alpha }&#10;    )&#10;}&#10;&#10;/**&#10; * Rotating Monster Group - 3 monsters rotating around a center point&#10; */&#10;class RotatingMonsterGroup(&#10;    var centerX: Float,&#10;    var centerY: Float,&#10;    var radius: Float,&#10;    var angleOffset: Float,&#10;    var vx: Float, // velocity X&#10;    var vy: Float  // velocity Y&#10;) {&#10;    val monsters = List(3) { i -&gt;&#10;        val angle = angleOffset + i * 120f&#10;        val rad = Math.toRadians(angle.toDouble())&#10;        BaseMonster(&#10;            x = (centerX + cos(rad) * radius).toFloat(),&#10;            y = mutableStateOf((centerY + sin(rad) * radius).toFloat()),&#10;            speed = 0f,&#10;            hp = mutableStateOf(100)&#10;        )&#10;    }&#10;&#10;    fun updatePositions() {&#10;        val angles = listOf(0f, 120f, 240f)&#10;        monsters.forEachIndexed { i, m -&gt;&#10;            if (m.alive.value) {&#10;                val rad = Math.toRadians((angleOffset + angles[i]).toDouble())&#10;                m.x = (centerX + cos(rad) * radius).toFloat()&#10;                m.y.value = (centerY + sin(rad) * radius).toFloat()&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.game&#10;&#10;import android.os.Bundle&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.TopBarComponent.TopBarUI&#10;import com.example.game.core.*&#10;import com.example.game.ui.PlaneUI&#10;import com.example.game.ui.MonsterUI&#10;import com.example.game.ui.WallUI&#10;import com.example.game.ui.SoundControlButton&#10;import com.example.game.ui.BagCoinAnimatedView&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.*&#10;import kotlin.random.Random&#10;&#10;class Level2Activity : BaseGameActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        initAudio()&#10;&#10;        // Initialize AI Avoidance Helper for smart bullet dodging&#10;        AIAvoidanceHelper.init(this)&#10;&#10;        setContent {&#10;            val density = LocalDensity.current&#10;            val screenWidthPx = with(density) { LocalConfiguration.current.screenWidthDp.dp.toPx() }&#10;            val screenHeightPx = with(density) { LocalConfiguration.current.screenHeightDp.dp.toPx() }&#10;&#10;            Level2Game(&#10;                screenWidthPx = screenWidthPx,&#10;                screenHeightPx = screenHeightPx,&#10;                soundPool = soundPool,&#10;                shootSoundId = shootSoundId,&#10;                hitSoundId = hitSoundId,&#10;                onExit = { finish() }&#10;            )&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        AIAvoidanceHelper.release()&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Level2Game(&#10;    screenWidthPx: Float,&#10;    screenHeightPx: Float,&#10;    soundPool: android.media.SoundPool,&#10;    shootSoundId: Int,&#10;    hitSoundId: Int,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val playerName = PrefManager.getPlayerName(context)&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // --- State ---&#10;    var totalScore by remember { mutableStateOf(0) }&#10;    var currentSessionScore by remember { mutableStateOf(0) }&#10;    var planeHp by remember { mutableStateOf(100) }&#10;&#10;    var shieldActive by remember { mutableStateOf(false) }&#10;    var wallActive by remember { mutableStateOf(false) }&#10;    var timeActive by remember { mutableStateOf(false) }&#10;&#10;    var isGameOver by remember { mutableStateOf(false) }&#10;    var isLevelClear by remember { mutableStateOf(false) }&#10;    var showGameEndDialog by remember { mutableStateOf(false) }&#10;&#10;    // Show dialog when game ends instead of navigating to new activity&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        if (isGameOver || isLevelClear) {&#10;            delay(500)&#10;            showGameEndDialog = true&#10;        }&#10;    }&#10;&#10;    // --- Plane setup ---&#10;    var planeX by remember { mutableStateOf(screenWidthPx / 2 - 50f) }&#10;    val planeY = screenHeightPx - 250f&#10;    val planeWidth = 100f&#10;    val planeHeight = 100f&#10;&#10;    // --- Background ---&#10;    var bg1Y by remember { mutableStateOf(0f) }&#10;    var bg2Y by remember { mutableStateOf(-screenHeightPx) }&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bg1Y += 4f&#10;            bg2Y += 4f&#10;            if (bg1Y &gt;= screenHeightPx) bg1Y = bg2Y - screenHeightPx&#10;            if (bg2Y &gt;= screenHeightPx) bg2Y = bg1Y - screenHeightPx&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Entities: 5 rotating monster groups ---&#10;    val monsterGroups = remember {&#10;        List(5) { i -&gt;&#10;            RotatingMonsterGroup(&#10;                centerX = Random.nextFloat() * (screenWidthPx - 300f) + 150f, // Random X position&#10;                centerY = -300f, // Start just above screen&#10;                radius = 100f,&#10;                angleOffset = Random.nextFloat() * 360f, // Random starting angle&#10;                vx = if (Random.nextBoolean()) Random.nextFloat() * 2f + 2f else -(Random.nextFloat() * 2f + 2f),&#10;                vy = Random.nextFloat() * 2f + 3f // Random vertical speed (3-5f)&#10;            ).apply {&#10;                // Initially set monsters as dead - they will spawn with delay&#10;                monsters.forEach { it.alive.value = false }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Track respawn times for each group&#10;    val groupRespawnTimes = remember { MutableList(monsterGroups.size) { i -&gt; System.currentTimeMillis() + (i * 3000L) } }&#10;&#10;    val coins = remember {&#10;        List(7) {&#10;            BaseCoin(&#10;                x = Random.nextFloat() * (screenWidthPx - 50f),&#10;                y = mutableStateOf(-Random.nextInt(100, 800).toFloat()),&#10;                speed = Random.nextFloat() * 2f + 1.5f&#10;            )&#10;        }&#10;    }&#10;&#10;    val bullets = remember { mutableStateListOf&lt;Bullet&gt;() }&#10;    val bagCoins = remember { mutableStateListOf&lt;BagCoinDisplay&gt;() }&#10;    var chestItems by remember { mutableStateOf&lt;List&lt;ChestItem&gt;&gt;(emptyList()) }&#10;&#10;    // --- Load player data ---&#10;    LaunchedEffect(Unit) {&#10;        if (!playerName.isNullOrBlank()) {&#10;            FirebaseHelper.syncNewPlayer(playerName)&#10;            FirebaseHelper.getScore(playerName) { totalScore = it }&#10;            FirebaseHelper.getChestItems(playerName) { chestItems = it }&#10;        }&#10;    }&#10;&#10;    // --- Shooting ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.add(Bullet(planeX + planeWidth / 2 - 15f, planeY))&#10;            SoundManager.playSoundEffect(soundPool, shootSoundId, 0.5f)&#10;            delay(300)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.forEach { it.y -= 25f }&#10;            bullets.removeAll { it.y &lt; -50f }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Monster groups movement + rotation ---&#10;    monsterGroups.forEachIndexed { index, group -&gt;&#10;        LaunchedEffect(group, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                // Check if group needs to respawn&#10;                val allDead = group.monsters.all { !it.alive.value }&#10;                if (allDead &amp;&amp; System.currentTimeMillis() &gt;= groupRespawnTimes[index]) {&#10;                    // Respawn group at random position&#10;                    group.centerX = Random.nextFloat() * (screenWidthPx - 300f) + 150f&#10;                    group.centerY = -300f&#10;                    group.vx = if (Random.nextBoolean()) Random.nextFloat() * 2f + 2f else -(Random.nextFloat() * 2f + 2f)&#10;                    group.vy = Random.nextFloat() * 2f + 3f&#10;                    group.angleOffset = Random.nextFloat() * 360f // Random rotation angle&#10;                    group.monsters.forEach { m -&gt;&#10;                        m.hp.value = 100&#10;                        m.alive.value = true&#10;                    }&#10;                    // Update positions to match new center and angle&#10;                    group.updatePositions()&#10;                    // Set next respawn time with random delay (3-5 seconds)&#10;                    groupRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 5000)&#10;                }&#10;&#10;                if (!timeActive &amp;&amp; !allDead) {&#10;                    // Rotate monsters&#10;                    group.angleOffset += 3f&#10;&#10;                    // Move center&#10;                    group.centerX += group.vx&#10;                    group.centerY += group.vy&#10;&#10;                    // Bounce off LEFT wall - reverse to RIGHT&#10;                    if (group.centerX &lt;= 150f) {&#10;                        group.centerX = 150f&#10;                        group.vx = abs(group.vx) // Bounce to opposite direction (right)&#10;                    }&#10;&#10;                    // Bounce off RIGHT wall - reverse to LEFT&#10;                    if (group.centerX &gt;= screenWidthPx - 150f) {&#10;                        group.centerX = screenWidthPx - 150f&#10;                        group.vx = -abs(group.vx) // Bounce to opposite direction (left)&#10;                    }&#10;&#10;                    // Bounce off TOP - reverse to DOWN&#10;                    if (group.centerY &lt;= 150f) {&#10;                        group.centerY = 150f&#10;                        group.vy = abs(group.vy) // Bounce to opposite direction (down)&#10;                    }&#10;&#10;                    // Bounce off BOTTOM - reverse to UP&#10;                    if (group.centerY &gt;= screenHeightPx - 300f) {&#10;                        group.centerY = screenHeightPx - 300f&#10;                        group.vy = -abs(group.vy) // Bounce to opposite direction (up)&#10;                    }&#10;&#10;                    // Update monster positions&#10;                    group.updatePositions()&#10;&#10;                    // Respawn if group goes way off screen (safety check)&#10;                    if (group.centerY &gt; screenHeightPx + 500f || group.centerY &lt; -1000f) {&#10;                        groupRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(2000, 5000)&#10;                        group.monsters.forEach { it.alive.value = false }&#10;                    }&#10;                }&#10;                delay(16)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Coin movement ---&#10;    coins.forEach { c -&gt;&#10;        LaunchedEffect(c, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                if (!c.collected.value &amp;&amp; !timeActive) {&#10;                    c.y.value += c.speed&#10;                    if (c.y.value &gt; screenHeightPx) {&#10;                        c.y.value = -Random.nextInt(100, 800).toFloat()&#10;                        c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                    }&#10;                }&#10;                delay(32)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Bullet vs Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            val iter = bullets.iterator()&#10;            while (iter.hasNext()) {&#10;                val b = iter.next()&#10;                monsterGroups.forEach { group -&gt;&#10;                    group.monsters.forEach { m -&gt;&#10;                        if (CollisionUtils.checkCollisionBulletMonster(b, m)) {&#10;                            m.hp.value -= 25&#10;                            // Play hit sound&#10;                            SoundManager.playSoundEffect(soundPool, hitSoundId, 0.3f)&#10;                            iter.remove()&#10;                            if (m.hp.value &lt;= 0) {&#10;                                m.alive.value = false&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Coin collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            coins.forEach { c -&gt;&#10;                if (!c.collected.value &amp;&amp; CollisionUtils.checkCollisionPlaneCoin(planeX, planeY, planeWidth, planeHeight, c)) {&#10;                    c.collected.value = true&#10;                    totalScore += 1&#10;                    currentSessionScore += 1&#10;                    val bag = BagCoinDisplay(c.x, c.y.value, 1)&#10;                    bagCoins.add(bag)&#10;                    if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            monsterGroups.forEach { group -&gt;&#10;                group.monsters.forEach { m -&gt;&#10;                    if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp;&#10;                        CollisionUtils.checkCollisionPlaneMonster(planeX, planeY, planeWidth, planeHeight, m)&#10;                    ) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) planeHp -= 50&#10;                        m.hp.value = 0&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;            }&#10;            if (planeHp &lt;= 0) isGameOver = true&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Wall - Monster collision ---&#10;    LaunchedEffect(wallActive, isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            if (wallActive) {&#10;                monsterGroups.forEach { group -&gt;&#10;                    group.monsters.forEach { m -&gt;&#10;                        if (m.alive.value &amp;&amp; m.hp.value &gt; 0) {&#10;                            if (CollisionUtils.checkCollisionWallMonster(planeY, m)) {&#10;                                m.hp.value -= 2&#10;                                if (m.hp.value &lt;= 0) {&#10;                                    m.alive.value = false&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Use chest item ---&#10;    fun useChestItem(item: ChestItem) {&#10;        // Flatten all monsters from groups for ChestItemEffectsBase&#10;        val allMonsters = monsterGroups.flatMap { it.monsters }&#10;        ChestItemEffectsBase.applyItemEffect(&#10;            itemName = item.name,&#10;            monsters = allMonsters,&#10;            coins = coins,&#10;            bagCoins = bagCoins,&#10;            coroutineScope = coroutineScope,&#10;            screenHeightPx = screenHeightPx,&#10;            planeX = planeX,&#10;            onScoreUpdate = { add -&gt;&#10;                totalScore += add&#10;                currentSessionScore += add&#10;                if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;            },&#10;            onShieldToggle = { active -&gt; shieldActive = active },&#10;            onWallToggle = { active -&gt; wallActive = active },&#10;            onTimeToggle = { active -&gt; timeActive = active },&#10;            onLevelClear = { isLevelClear = true }&#10;        )&#10;        chestItems = chestItems - item&#10;        if (!playerName.isNullOrBlank()) FirebaseHelper.updateChest(playerName, chestItems)&#10;    }&#10;&#10;    // --- Drag plane ---&#10;    val dragModifier = Modifier.pointerInput(Unit) {&#10;        detectDragGestures { change, dragAmount -&gt;&#10;            planeX = (planeX + dragAmount.x).coerceIn(0f, screenWidthPx - planeWidth)&#10;            change.consume()&#10;        }&#10;    }&#10;&#10;    // --- UI ---&#10;    Box(modifier = Modifier.fillMaxSize().then(dragModifier)) {&#10;        // Background&#10;        Image(&#10;            painter = painterResource(R.drawable.nen2),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg1Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;        Image(&#10;            painter = painterResource(R.drawable.nen2),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg2Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;&#10;        // Monsters (using MonsterUI component)&#10;        monsterGroups.forEach { group -&gt;&#10;            group.monsters.forEach { m -&gt;&#10;                MonsterUI(monster = m)&#10;            }&#10;        }&#10;&#10;        // Coins&#10;        coins.filter { !it.collected.value }.forEach { c -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.coin),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(c.x.roundToInt(), c.y.value.roundToInt()) }&#10;                    .size(40.dp)&#10;            )&#10;        }&#10;&#10;        // BagCoin animated views&#10;        bagCoins.toList().forEach { bag -&gt;&#10;            BagCoinAnimatedView(bag = bag, onFinished = { finishedBag -&gt;&#10;                bagCoins.remove(finishedBag)&#10;            })&#10;        }&#10;&#10;        // Bullets&#10;        bullets.forEach { b -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.dan2),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(b.x.roundToInt(), b.y.roundToInt()) }&#10;                    .size(30.dp)&#10;            )&#10;        }&#10;&#10;        // Plane (using PlaneUI component)&#10;        PlaneUI(&#10;            planeX = planeX,&#10;            planeY = planeY,&#10;            planeHp = planeHp,&#10;            shieldActive = shieldActive&#10;        )&#10;&#10;        // Wall (using WallUI component)&#10;        if (wallActive) {&#10;            WallUI(planeY = planeY)&#10;        }&#10;&#10;        // Top bar&#10;        TopBarUI(&#10;            bagCoinScore = totalScore,&#10;            chestItems = chestItems,&#10;            onBuyItem = { item, price -&gt;&#10;                if (totalScore &gt;= price) {&#10;                    totalScore -= price&#10;                    chestItems = chestItems + item&#10;                    if (!playerName.isNullOrBlank()) {&#10;                        FirebaseHelper.updateScore(playerName, totalScore)&#10;                        FirebaseHelper.updateChest(playerName, chestItems)&#10;                    }&#10;                }&#10;            },&#10;            onUseChestItem = { useChestItem(it) }&#10;        )&#10;&#10;        // --- Sound Control Button (top-right corner) ---&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp),&#10;            contentAlignment = Alignment.TopEnd&#10;        ) {&#10;            SoundControlButton()&#10;        }&#10;    }&#10;&#10;    // --- Game End Dialog ---&#10;    if (showGameEndDialog) {&#10;        GameEndDialog(&#10;            isWin = isLevelClear,&#10;            score = currentSessionScore,&#10;            level = 2,&#10;            onDismiss = {&#10;                showGameEndDialog = false&#10;            },&#10;            onReplay = {&#10;                // Reset game state to replay&#10;                showGameEndDialog = false&#10;                isGameOver = false&#10;                isLevelClear = false&#10;                planeHp = 100&#10;                currentSessionScore = 0&#10;&#10;                // Reset monsters&#10;                monsterGroups.forEach { group -&gt;&#10;                    group.centerX = Random.nextFloat() * (screenWidthPx - 300f) + 150f&#10;                    group.centerY = -300f&#10;                    group.vx = if (Random.nextBoolean()) Random.nextFloat() * 2f + 2f else -(Random.nextFloat() * 2f + 2f)&#10;                    group.vy = Random.nextFloat() * 2f + 3f&#10;                    group.angleOffset = Random.nextFloat() * 360f&#10;                    group.monsters.forEach { m -&gt;&#10;                        m.hp.value = 100&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;&#10;                // Reset respawn times&#10;                for (i in groupRespawnTimes.indices) {&#10;                    groupRespawnTimes[i] = System.currentTimeMillis() + (i * 3000L)&#10;                }&#10;&#10;                // Reset coins&#10;                coins.forEach { c -&gt;&#10;                    c.collected.value = false&#10;                    c.y.value = -Random.nextInt(100, 800).toFloat()&#10;                    c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                }&#10;&#10;                // Clear bullets&#10;                bullets.clear()&#10;            },&#10;            onNextLevel = {&#10;                // Navigate to next level handled by GameEndDialog itself&#10;                onExit() // Close this activity&#10;            },&#10;            onExit = {&#10;                // Back to main menu&#10;                onExit()&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * Rotating Monster Group - 3 monsters rotating around a center point&#10; */&#10;class RotatingMonsterGroup(&#10;    var centerX: Float,&#10;    var centerY: Float,&#10;    var radius: Float,&#10;    var angleOffset: Float,&#10;    var vx: Float, // velocity X&#10;    var vy: Float  // velocity Y&#10;) {&#10;    val monsters = List(3) { i -&gt;&#10;        val angle = angleOffset + i * 120f&#10;        val rad = Math.toRadians(angle.toDouble())&#10;        BaseMonster(&#10;            x = (centerX + cos(rad) * radius).toFloat(),&#10;            y = mutableStateOf((centerY + sin(rad) * radius).toFloat()),&#10;            speed = 0f,&#10;            hp = mutableStateOf(100)&#10;        )&#10;    }&#10;&#10;    fun updatePositions() {&#10;        val angles = listOf(0f, 120f, 240f)&#10;        monsters.forEachIndexed { i, m -&gt;&#10;            if (m.alive.value) {&#10;                val rad = Math.toRadians((angleOffset + angles[i]).toDouble())&#10;                m.x = (centerX + cos(rad) * radius).toFloat()&#10;                m.y.value = (centerY + sin(rad) * radius).toFloat()&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/game/Level3Activity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/game/Level3Activity.kt" />
              <option name="originalContent" value="package com.example.game&#10;&#10;import android.os.Bundle&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.TopBarComponent.TopBarUI&#10;import com.example.game.core.*&#10;import com.example.game.ui.PlaneUI&#10;import com.example.game.ui.WallUI&#10;import com.example.game.ui.InvisibleMonsterUI&#10;import com.example.game.ui.SoundControlButton&#10;import com.example.game.ui.BagCoinAnimatedView&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.roundToInt&#10;import kotlin.random.Random&#10;&#10;class Level3Activity : BaseGameActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        try {&#10;            initAudio()&#10;&#10;            // Initialize AI Avoidance Helper for smart bullet dodging&#10;            try {&#10;                AIAvoidanceHelper.init(this)&#10;            } catch (e: Exception) {&#10;                e.printStackTrace()&#10;                // Continue without AI if it fails&#10;            }&#10;&#10;            setContent {&#10;                val density = LocalDensity.current&#10;                val screenWidthPx = with(density) { LocalConfiguration.current.screenWidthDp.dp.toPx() }&#10;                val screenHeightPx = with(density) { LocalConfiguration.current.screenHeightDp.dp.toPx() }&#10;&#10;                Level3Game(&#10;                    screenWidthPx = screenWidthPx,&#10;                    screenHeightPx = screenHeightPx,&#10;                    soundPool = soundPool,&#10;                    shootSoundId = shootSoundId,&#10;                    hitSoundId = hitSoundId,&#10;                    onExit = { finish() }&#10;                )&#10;            }&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            finish() // Exit gracefully if something goes wrong&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        try {&#10;            AIAvoidanceHelper.release()&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Level3Game(&#10;    screenWidthPx: Float,&#10;    screenHeightPx: Float,&#10;    soundPool: android.media.SoundPool,&#10;    shootSoundId: Int,&#10;    hitSoundId: Int,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val playerName = PrefManager.getPlayerName(context)&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // --- State ---&#10;    var totalScore by remember { mutableStateOf(0) }&#10;    var currentSessionScore by remember { mutableStateOf(0) }&#10;    var planeHp by remember { mutableStateOf(100) }&#10;&#10;    var shieldActive by remember { mutableStateOf(false) }&#10;    var wallActive by remember { mutableStateOf(false) }&#10;    var timeActive by remember { mutableStateOf(false) }&#10;&#10;    var isGameOver by remember { mutableStateOf(false) }&#10;    var isLevelClear by remember { mutableStateOf(false) }&#10;    var showGameEndDialog by remember { mutableStateOf(false) }&#10;&#10;    // Show dialog when game ends&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        if (isGameOver || isLevelClear) {&#10;            delay(500)&#10;            showGameEndDialog = true&#10;        }&#10;    }&#10;&#10;    // --- Plane setup ---&#10;    var planeX by remember { mutableStateOf(screenWidthPx / 2 - 50f) }&#10;    val planeY = screenHeightPx - 250f&#10;    val planeWidth = 100f&#10;    val planeHeight = 100f&#10;&#10;    // --- Background ---&#10;    var bg1Y by remember { mutableStateOf(0f) }&#10;    var bg2Y by remember { mutableStateOf(-screenHeightPx) }&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bg1Y += 4f&#10;            bg2Y += 4f&#10;            if (bg1Y &gt;= screenHeightPx) bg1Y = bg2Y - screenHeightPx&#10;            if (bg2Y &gt;= screenHeightPx) bg2Y = bg1Y - screenHeightPx&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Invisible Monsters ---&#10;    val invisibleMonsters = remember {&#10;        List(12) {&#10;            InvisibleMonster(&#10;                x = Random.nextFloat() * (screenWidthPx - 100f),&#10;                y = mutableStateOf(-Random.nextInt(200, 3000).toFloat()),&#10;                speed = Random.nextFloat() * 1.5f + 1.5f,&#10;                hp = mutableStateOf(100),&#10;                invisibleDuration = 2000L, // Invisible for 2 seconds&#10;                visibleDuration = 1500L     // Visible for 1.5 seconds&#10;            )&#10;        }&#10;    }&#10;&#10;    // Track respawn times&#10;    val monsterRespawnTimes = remember { MutableList(invisibleMonsters.size) { 0L } }&#10;&#10;    val coins = remember {&#10;        List(6) {&#10;            BaseCoin(&#10;                x = Random.nextFloat() * (screenWidthPx - 50f),&#10;                y = mutableStateOf(-Random.nextInt(100, 600).toFloat()),&#10;                speed = Random.nextFloat() * 2f + 1f&#10;            )&#10;        }&#10;    }&#10;&#10;    val bullets = remember { mutableStateListOf&lt;Bullet&gt;() }&#10;    val bagCoins = remember { mutableStateListOf&lt;BagCoinDisplay&gt;() }&#10;    var chestItems by remember { mutableStateOf&lt;List&lt;ChestItem&gt;&gt;(emptyList()) }&#10;&#10;    // --- Load player data ---&#10;    LaunchedEffect(Unit) {&#10;        if (!playerName.isNullOrBlank()) {&#10;            FirebaseHelper.syncNewPlayer(playerName)&#10;            FirebaseHelper.getScore(playerName) { totalScore = it }&#10;            FirebaseHelper.getChestItems(playerName) { chestItems = it }&#10;        }&#10;    }&#10;&#10;    // --- Shooting ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.add(Bullet(planeX + planeWidth / 2f - 15f, planeY))&#10;            SoundManager.playSoundEffect(soundPool, shootSoundId, 0.5f)&#10;            delay(300)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.forEach { it.y -= 25f }&#10;            bullets.removeAll { it.y &lt; -50f }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Monster movement + invisible toggle ---&#10;    invisibleMonsters.forEachIndexed { index, m -&gt;&#10;        LaunchedEffect(m, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                // Check if monster needs to respawn&#10;                if (!m.alive.value &amp;&amp; System.currentTimeMillis() &gt;= monsterRespawnTimes[index]) {&#10;                    m.y.value = -Random.nextInt(200, 1500).toFloat()&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 100f)&#10;                    m.hp.value = 100&#10;                    m.alive.value = true&#10;                    m.lastToggleTime = System.currentTimeMillis()&#10;                    m.isVisible.value = Random.nextBoolean() // Random start state&#10;                }&#10;&#10;                if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp; !timeActive) {&#10;                    // AI-based evasion: monster tries to dodge bullets intelligently&#10;                    val evasion = AIAvoidanceHelper.calculateEvasion(&#10;                        monsterX = m.x,&#10;                        monsterY = m.y.value,&#10;                        monsterSize = 100f,&#10;                        bullets = bullets,&#10;                        screenWidth = screenWidthPx&#10;                    )&#10;&#10;                    // Apply AI evasion (combines with zigzag movement)&#10;                    val aiDodgeX = evasion.first&#10;&#10;                    // Toggle visibility&#10;                    val currentTime = System.currentTimeMillis()&#10;                    val elapsed = currentTime - m.lastToggleTime&#10;                    val threshold = if (m.isVisible.value) m.visibleDuration else m.invisibleDuration&#10;&#10;                    if (elapsed &gt;= threshold) {&#10;                        m.isVisible.value = !m.isVisible.value&#10;                        m.lastToggleTime = currentTime&#10;                    }&#10;&#10;                    // Wall collision check&#10;                    val wallTop = planeY - 60f&#10;                    val monsterBottom = m.y.value + 80f&#10;&#10;                    if (wallActive &amp;&amp; monsterBottom &gt;= wallTop) {&#10;                        // Stop at wall&#10;                    } else {&#10;                        // Normal movement&#10;                        m.y.value += m.speed&#10;                    }&#10;&#10;                    // Zigzag movement combined with AI evasion&#10;                    val combinedX = (m.horizontalSpeed * m.direction) + aiDodgeX&#10;                    m.x = (m.x + combinedX).coerceIn(0f, screenWidthPx - 100f)&#10;&#10;                    if (m.x &lt;= 0 || m.x &gt;= screenWidthPx - 100f) {&#10;                        m.direction *= -1&#10;                    }&#10;&#10;                    // If monster passes plane&#10;                    if (m.y.value &gt; planeY + planeHeight / 2f) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) planeHp -= 50&#10;                        monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 8000)&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;                delay(16)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Coin movement ---&#10;    coins.forEach { c -&gt;&#10;        LaunchedEffect(c, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                if (!c.collected.value &amp;&amp; !timeActive) {&#10;                    c.y.value += c.speed&#10;                    if (c.y.value &gt; screenHeightPx) {&#10;                        c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                        c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                    }&#10;                }&#10;                delay(32)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Bullet vs Monster collision (only when visible) ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            val iter = bullets.iterator()&#10;            while (iter.hasNext()) {&#10;                val b = iter.next()&#10;                invisibleMonsters.forEach { m -&gt;&#10;                    // Can only hit visible monsters&#10;                    if (m.isVisible.value &amp;&amp; CollisionUtils.checkCollisionBulletInvisibleMonster(b, m)) {&#10;                        m.hp.value -= 25&#10;                        // Play hit sound&#10;                        SoundManager.playSoundEffect(soundPool, hitSoundId, 0.3f)&#10;                        iter.remove()&#10;                        if (m.hp.value &lt;= 0) {&#10;                            m.alive.value = false&#10;                            val index = invisibleMonsters.indexOf(m)&#10;                            if (index &gt;= 0) {&#10;                                monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 8000)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Coin collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            coins.forEach { c -&gt;&#10;                if (!c.collected.value &amp;&amp; CollisionUtils.checkCollisionPlaneCoin(planeX, planeY, planeWidth, planeHeight, c)) {&#10;                    c.collected.value = true&#10;                    totalScore += 1&#10;                    currentSessionScore += 1&#10;                    val bag = BagCoinDisplay(c.x, c.y.value, 1)&#10;                    bagCoins.add(bag)&#10;                    if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Monster collision (only when visible) ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            invisibleMonsters.forEach { m -&gt;&#10;                if (m.isVisible.value &amp;&amp; CollisionUtils.checkCollisionPlaneInvisibleMonster(planeX, planeY, planeWidth, planeHeight, m)) {&#10;                    if (!shieldActive &amp;&amp; !wallActive) planeHp -= 50&#10;                    m.hp.value = 0&#10;                    m.alive.value = false&#10;                }&#10;            }&#10;            if (planeHp &lt;= 0) isGameOver = true&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Wall - Monster collision ---&#10;    LaunchedEffect(wallActive, isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            if (wallActive) {&#10;                invisibleMonsters.forEach { m -&gt;&#10;                    if (m.isVisible.value &amp;&amp; CollisionUtils.checkCollisionWallInvisibleMonster(planeY, m)) {&#10;                        m.hp.value -= 2&#10;                        if (m.hp.value &lt;= 0) {&#10;                            m.alive.value = false&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Use chest item ---&#10;    fun useChestItem(item: ChestItem) {&#10;        ChestItemEffectsBase.applyItemEffect(&#10;            itemName = item.name,&#10;            monsters = invisibleMonsters,&#10;            coins = coins,&#10;            bagCoins = bagCoins,&#10;            coroutineScope = coroutineScope,&#10;            screenHeightPx = screenHeightPx,&#10;            planeX = planeX,&#10;            onScoreUpdate = { add -&gt;&#10;                totalScore += add&#10;                currentSessionScore += add&#10;                if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;            },&#10;            onShieldToggle = { active -&gt; shieldActive = active },&#10;            onWallToggle = { active -&gt; wallActive = active },&#10;            onTimeToggle = { active -&gt; timeActive = active },&#10;            onLevelClear = { isLevelClear = true }&#10;        )&#10;        chestItems = chestItems - item&#10;        if (!playerName.isNullOrBlank()) FirebaseHelper.updateChest(playerName, chestItems)&#10;    }&#10;&#10;    // --- Drag plane ---&#10;    val dragModifier = Modifier.pointerInput(Unit) {&#10;        detectDragGestures { change, dragAmount -&gt;&#10;            planeX = (planeX + dragAmount.x).coerceIn(0f, screenWidthPx - planeWidth)&#10;            change.consume()&#10;        }&#10;    }&#10;&#10;    // --- UI ---&#10;    Box(modifier = Modifier.fillMaxSize().then(dragModifier)) {&#10;        // Background&#10;        Image(&#10;            painter = painterResource(R.drawable.vutru1),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg1Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;        Image(&#10;            painter = painterResource(R.drawable.vutru1),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg2Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;&#10;        // Invisible Monsters (only show when visible)&#10;        invisibleMonsters.forEach { m -&gt;&#10;            if (m.isVisible.value) {&#10;                InvisibleMonsterUI(monster = m)&#10;            }&#10;        }&#10;&#10;        // Coins&#10;        coins.filter { !it.collected.value }.forEach { c -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.coin),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(c.x.roundToInt(), c.y.value.roundToInt()) }&#10;                    .size(40.dp)&#10;            )&#10;        }&#10;&#10;        // BagCoin animated views&#10;        bagCoins.toList().forEach { bag -&gt;&#10;            BagCoinAnimatedView(bag = bag, onFinished = { finishedBag -&gt;&#10;                bagCoins.remove(finishedBag)&#10;            })&#10;        }&#10;&#10;        // Bullets&#10;        bullets.forEach { b -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.dan2),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(b.x.roundToInt(), b.y.roundToInt()) }&#10;                    .size(30.dp)&#10;            )&#10;        }&#10;&#10;        // Plane&#10;        PlaneUI(&#10;            planeX = planeX,&#10;            planeY = planeY,&#10;            planeHp = planeHp,&#10;            shieldActive = shieldActive&#10;        )&#10;&#10;        // Wall&#10;        if (wallActive) {&#10;            WallUI(planeY = planeY)&#10;        }&#10;&#10;        // Top bar&#10;        TopBarUI(&#10;            bagCoinScore = totalScore,&#10;            chestItems = chestItems,&#10;            onBuyItem = { item, price -&gt;&#10;                if (totalScore &gt;= price) {&#10;                    totalScore -= price&#10;                    chestItems = chestItems + item&#10;                    if (!playerName.isNullOrBlank()) {&#10;                        FirebaseHelper.updateScore(playerName, totalScore)&#10;                        FirebaseHelper.updateChest(playerName, chestItems)&#10;                    }&#10;                }&#10;            },&#10;            onUseChestItem = { useChestItem(it) }&#10;        )&#10;&#10;        // --- Sound Control Button (top-right corner) ---&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp),&#10;            contentAlignment = androidx.compose.ui.Alignment.TopEnd&#10;        ) {&#10;            SoundControlButton()&#10;        }&#10;    }&#10;&#10;    // --- Game End Dialog ---&#10;    if (showGameEndDialog) {&#10;        GameEndDialog(&#10;            isWin = isLevelClear,&#10;            score = currentSessionScore,&#10;            level = 3,&#10;            onDismiss = {&#10;                showGameEndDialog = false&#10;            },&#10;            onReplay = {&#10;                // Reset game&#10;                showGameEndDialog = false&#10;                isGameOver = false&#10;                isLevelClear = false&#10;                planeHp = 100&#10;                currentSessionScore = 0&#10;&#10;                invisibleMonsters.forEachIndexed { index, m -&gt;&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 100f)&#10;                    m.y.value = -Random.nextInt(200, 3000).toFloat()&#10;                    m.hp.value = 100&#10;                    m.alive.value = true&#10;                    m.isVisible.value = Random.nextBoolean()&#10;                    m.lastToggleTime = System.currentTimeMillis()&#10;                    monsterRespawnTimes[index] = 0L&#10;                }&#10;&#10;                coins.forEach { c -&gt;&#10;                    c.collected.value = false&#10;                    c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                    c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                }&#10;&#10;                bullets.clear()&#10;            },&#10;            onNextLevel = {&#10;                onExit()&#10;            },&#10;            onExit = {&#10;                onExit()&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * BagCoinAnimatedView for Level 3&#10; * - Animates a bag coin sprite moving slightly up and fading out.&#10; * - Calls onFinished(bag) when animation done so caller can remove it.&#10; */&#10;@Composable&#10;private fun BagCoinAnimatedView(bag: BagCoinDisplay, onFinished: (BagCoinDisplay) -&gt; Unit) {&#10;    var offsetY by remember { mutableStateOf(bag.y) }&#10;    var alpha by remember { mutableStateOf(1f) }&#10;&#10;    LaunchedEffect(bag) {&#10;        val duration = 800L&#10;        val steps = 40&#10;        repeat(steps) { i -&gt;&#10;            offsetY -= 2f&#10;            alpha = 1f - (i / steps.toFloat())&#10;            delay(duration / steps)&#10;        }&#10;        onFinished(bag)&#10;    }&#10;&#10;    Image(&#10;        painter = painterResource(R.drawable.bagcoin),&#10;        contentDescription = null,&#10;        modifier = Modifier&#10;            .absoluteOffset { IntOffset(bag.x.roundToInt(), offsetY.roundToInt()) }&#10;            .size(60.dp)&#10;            .graphicsLayer { this.alpha = alpha }&#10;    )&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.game&#10;&#10;import android.os.Bundle&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.TopBarComponent.TopBarUI&#10;import com.example.game.core.*&#10;import com.example.game.ui.PlaneUI&#10;import com.example.game.ui.WallUI&#10;import com.example.game.ui.InvisibleMonsterUI&#10;import com.example.game.ui.SoundControlButton&#10;import com.example.game.ui.BagCoinAnimatedView&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.roundToInt&#10;import kotlin.random.Random&#10;&#10;class Level3Activity : BaseGameActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        try {&#10;            initAudio()&#10;&#10;            // Initialize AI Avoidance Helper for smart bullet dodging&#10;            try {&#10;                AIAvoidanceHelper.init(this)&#10;            } catch (e: Exception) {&#10;                e.printStackTrace()&#10;                // Continue without AI if it fails&#10;            }&#10;&#10;            setContent {&#10;                val density = LocalDensity.current&#10;                val screenWidthPx = with(density) { LocalConfiguration.current.screenWidthDp.dp.toPx() }&#10;                val screenHeightPx = with(density) { LocalConfiguration.current.screenHeightDp.dp.toPx() }&#10;&#10;                Level3Game(&#10;                    screenWidthPx = screenWidthPx,&#10;                    screenHeightPx = screenHeightPx,&#10;                    soundPool = soundPool,&#10;                    shootSoundId = shootSoundId,&#10;                    hitSoundId = hitSoundId,&#10;                    onExit = { finish() }&#10;                )&#10;            }&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            finish() // Exit gracefully if something goes wrong&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        try {&#10;            AIAvoidanceHelper.release()&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Level3Game(&#10;    screenWidthPx: Float,&#10;    screenHeightPx: Float,&#10;    soundPool: android.media.SoundPool,&#10;    shootSoundId: Int,&#10;    hitSoundId: Int,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val playerName = PrefManager.getPlayerName(context)&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // --- State ---&#10;    var totalScore by remember { mutableStateOf(0) }&#10;    var currentSessionScore by remember { mutableStateOf(0) }&#10;    var planeHp by remember { mutableStateOf(100) }&#10;&#10;    var shieldActive by remember { mutableStateOf(false) }&#10;    var wallActive by remember { mutableStateOf(false) }&#10;    var timeActive by remember { mutableStateOf(false) }&#10;&#10;    var isGameOver by remember { mutableStateOf(false) }&#10;    var isLevelClear by remember { mutableStateOf(false) }&#10;    var showGameEndDialog by remember { mutableStateOf(false) }&#10;&#10;    // Show dialog when game ends&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        if (isGameOver || isLevelClear) {&#10;            delay(500)&#10;            showGameEndDialog = true&#10;        }&#10;    }&#10;&#10;    // --- Plane setup ---&#10;    var planeX by remember { mutableStateOf(screenWidthPx / 2 - 50f) }&#10;    val planeY = screenHeightPx - 250f&#10;    val planeWidth = 100f&#10;    val planeHeight = 100f&#10;&#10;    // --- Background ---&#10;    var bg1Y by remember { mutableStateOf(0f) }&#10;    var bg2Y by remember { mutableStateOf(-screenHeightPx) }&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bg1Y += 4f&#10;            bg2Y += 4f&#10;            if (bg1Y &gt;= screenHeightPx) bg1Y = bg2Y - screenHeightPx&#10;            if (bg2Y &gt;= screenHeightPx) bg2Y = bg1Y - screenHeightPx&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Invisible Monsters ---&#10;    val invisibleMonsters = remember {&#10;        List(12) {&#10;            InvisibleMonster(&#10;                x = Random.nextFloat() * (screenWidthPx - 100f),&#10;                y = mutableStateOf(-Random.nextInt(200, 3000).toFloat()),&#10;                speed = Random.nextFloat() * 1.5f + 1.5f,&#10;                hp = mutableStateOf(100),&#10;                invisibleDuration = 2000L, // Invisible for 2 seconds&#10;                visibleDuration = 1500L     // Visible for 1.5 seconds&#10;            )&#10;        }&#10;    }&#10;&#10;    // Track respawn times&#10;    val monsterRespawnTimes = remember { MutableList(invisibleMonsters.size) { 0L } }&#10;&#10;    val coins = remember {&#10;        List(6) {&#10;            BaseCoin(&#10;                x = Random.nextFloat() * (screenWidthPx - 50f),&#10;                y = mutableStateOf(-Random.nextInt(100, 600).toFloat()),&#10;                speed = Random.nextFloat() * 2f + 1f&#10;            )&#10;        }&#10;    }&#10;&#10;    val bullets = remember { mutableStateListOf&lt;Bullet&gt;() }&#10;    val bagCoins = remember { mutableStateListOf&lt;BagCoinDisplay&gt;() }&#10;    var chestItems by remember { mutableStateOf&lt;List&lt;ChestItem&gt;&gt;(emptyList()) }&#10;&#10;    // --- Load player data ---&#10;    LaunchedEffect(Unit) {&#10;        if (!playerName.isNullOrBlank()) {&#10;            FirebaseHelper.syncNewPlayer(playerName)&#10;            FirebaseHelper.getScore(playerName) { totalScore = it }&#10;            FirebaseHelper.getChestItems(playerName) { chestItems = it }&#10;        }&#10;    }&#10;&#10;    // --- Shooting ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.add(Bullet(planeX + planeWidth / 2f - 15f, planeY))&#10;            SoundManager.playSoundEffect(soundPool, shootSoundId, 0.5f)&#10;            delay(300)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.forEach { it.y -= 25f }&#10;            bullets.removeAll { it.y &lt; -50f }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Monster movement + invisible toggle ---&#10;    invisibleMonsters.forEachIndexed { index, m -&gt;&#10;        LaunchedEffect(m, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                // Check if monster needs to respawn&#10;                if (!m.alive.value &amp;&amp; System.currentTimeMillis() &gt;= monsterRespawnTimes[index]) {&#10;                    m.y.value = -Random.nextInt(200, 1500).toFloat()&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 100f)&#10;                    m.hp.value = 100&#10;                    m.alive.value = true&#10;                    m.lastToggleTime = System.currentTimeMillis()&#10;                    m.isVisible.value = Random.nextBoolean() // Random start state&#10;                }&#10;&#10;                if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp; !timeActive) {&#10;                    // AI-based evasion: monster tries to dodge bullets intelligently&#10;                    val evasion = AIAvoidanceHelper.calculateEvasion(&#10;                        monsterX = m.x,&#10;                        monsterY = m.y.value,&#10;                        monsterSize = 100f,&#10;                        bullets = bullets,&#10;                        screenWidth = screenWidthPx&#10;                    )&#10;&#10;                    // Apply AI evasion (combines with zigzag movement)&#10;                    val aiDodgeX = evasion.first&#10;&#10;                    // Toggle visibility&#10;                    val currentTime = System.currentTimeMillis()&#10;                    val elapsed = currentTime - m.lastToggleTime&#10;                    val threshold = if (m.isVisible.value) m.visibleDuration else m.invisibleDuration&#10;&#10;                    if (elapsed &gt;= threshold) {&#10;                        m.isVisible.value = !m.isVisible.value&#10;                        m.lastToggleTime = currentTime&#10;                    }&#10;&#10;                    // Wall collision check&#10;                    val wallTop = planeY - 60f&#10;                    val monsterBottom = m.y.value + 80f&#10;&#10;                    if (wallActive &amp;&amp; monsterBottom &gt;= wallTop) {&#10;                        // Stop at wall&#10;                    } else {&#10;                        // Normal movement&#10;                        m.y.value += m.speed&#10;                    }&#10;&#10;                    // Zigzag movement combined with AI evasion&#10;                    val combinedX = (m.horizontalSpeed * m.direction) + aiDodgeX&#10;                    m.x = (m.x + combinedX).coerceIn(0f, screenWidthPx - 100f)&#10;&#10;                    if (m.x &lt;= 0 || m.x &gt;= screenWidthPx - 100f) {&#10;                        m.direction *= -1&#10;                    }&#10;&#10;                    // If monster passes plane&#10;                    if (m.y.value &gt; planeY + planeHeight / 2f) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) planeHp -= 50&#10;                        monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 8000)&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;                delay(16)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Coin movement ---&#10;    coins.forEach { c -&gt;&#10;        LaunchedEffect(c, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                if (!c.collected.value &amp;&amp; !timeActive) {&#10;                    c.y.value += c.speed&#10;                    if (c.y.value &gt; screenHeightPx) {&#10;                        c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                        c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                    }&#10;                }&#10;                delay(32)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Bullet vs Monster collision (only when visible) ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            val iter = bullets.iterator()&#10;            while (iter.hasNext()) {&#10;                val b = iter.next()&#10;                invisibleMonsters.forEach { m -&gt;&#10;                    // Can only hit visible monsters&#10;                    if (m.isVisible.value &amp;&amp; CollisionUtils.checkCollisionBulletInvisibleMonster(b, m)) {&#10;                        m.hp.value -= 25&#10;                        // Play hit sound&#10;                        SoundManager.playSoundEffect(soundPool, hitSoundId, 0.3f)&#10;                        iter.remove()&#10;                        if (m.hp.value &lt;= 0) {&#10;                            m.alive.value = false&#10;                            val index = invisibleMonsters.indexOf(m)&#10;                            if (index &gt;= 0) {&#10;                                monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 8000)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Coin collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            coins.forEach { c -&gt;&#10;                if (!c.collected.value &amp;&amp; CollisionUtils.checkCollisionPlaneCoin(planeX, planeY, planeWidth, planeHeight, c)) {&#10;                    c.collected.value = true&#10;                    totalScore += 1&#10;                    currentSessionScore += 1&#10;                    val bag = BagCoinDisplay(c.x, c.y.value, 1)&#10;                    bagCoins.add(bag)&#10;                    if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Monster collision (only when visible) ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            invisibleMonsters.forEach { m -&gt;&#10;                if (m.isVisible.value &amp;&amp; CollisionUtils.checkCollisionPlaneInvisibleMonster(planeX, planeY, planeWidth, planeHeight, m)) {&#10;                    if (!shieldActive &amp;&amp; !wallActive) planeHp -= 50&#10;                    m.hp.value = 0&#10;                    m.alive.value = false&#10;                }&#10;            }&#10;            if (planeHp &lt;= 0) isGameOver = true&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Wall - Monster collision ---&#10;    LaunchedEffect(wallActive, isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            if (wallActive) {&#10;                invisibleMonsters.forEach { m -&gt;&#10;                    if (m.isVisible.value &amp;&amp; CollisionUtils.checkCollisionWallInvisibleMonster(planeY, m)) {&#10;                        m.hp.value -= 2&#10;                        if (m.hp.value &lt;= 0) {&#10;                            m.alive.value = false&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Use chest item ---&#10;    fun useChestItem(item: ChestItem) {&#10;        ChestItemEffectsBase.applyItemEffect(&#10;            itemName = item.name,&#10;            monsters = invisibleMonsters,&#10;            coins = coins,&#10;            bagCoins = bagCoins,&#10;            coroutineScope = coroutineScope,&#10;            screenHeightPx = screenHeightPx,&#10;            planeX = planeX,&#10;            onScoreUpdate = { add -&gt;&#10;                totalScore += add&#10;                currentSessionScore += add&#10;                if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;            },&#10;            onShieldToggle = { active -&gt; shieldActive = active },&#10;            onWallToggle = { active -&gt; wallActive = active },&#10;            onTimeToggle = { active -&gt; timeActive = active },&#10;            onLevelClear = { isLevelClear = true }&#10;        )&#10;        chestItems = chestItems - item&#10;        if (!playerName.isNullOrBlank()) FirebaseHelper.updateChest(playerName, chestItems)&#10;    }&#10;&#10;    // --- Drag plane ---&#10;    val dragModifier = Modifier.pointerInput(Unit) {&#10;        detectDragGestures { change, dragAmount -&gt;&#10;            planeX = (planeX + dragAmount.x).coerceIn(0f, screenWidthPx - planeWidth)&#10;            change.consume()&#10;        }&#10;    }&#10;&#10;    // --- UI ---&#10;    Box(modifier = Modifier.fillMaxSize().then(dragModifier)) {&#10;        // Background&#10;        Image(&#10;            painter = painterResource(R.drawable.vutru1),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg1Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;        Image(&#10;            painter = painterResource(R.drawable.vutru1),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg2Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;&#10;        // Invisible Monsters (only show when visible)&#10;        invisibleMonsters.forEach { m -&gt;&#10;            if (m.isVisible.value) {&#10;                InvisibleMonsterUI(monster = m)&#10;            }&#10;        }&#10;&#10;        // Coins&#10;        coins.filter { !it.collected.value }.forEach { c -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.coin),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(c.x.roundToInt(), c.y.value.roundToInt()) }&#10;                    .size(40.dp)&#10;            )&#10;        }&#10;&#10;        // BagCoin animated views&#10;        bagCoins.toList().forEach { bag -&gt;&#10;            BagCoinAnimatedView(bag = bag, onFinished = { finishedBag -&gt;&#10;                bagCoins.remove(finishedBag)&#10;            })&#10;        }&#10;&#10;        // Bullets&#10;        bullets.forEach { b -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.dan2),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(b.x.roundToInt(), b.y.roundToInt()) }&#10;                    .size(30.dp)&#10;            )&#10;        }&#10;&#10;        // Plane&#10;        PlaneUI(&#10;            planeX = planeX,&#10;            planeY = planeY,&#10;            planeHp = planeHp,&#10;            shieldActive = shieldActive&#10;        )&#10;&#10;        // Wall&#10;        if (wallActive) {&#10;            WallUI(planeY = planeY)&#10;        }&#10;&#10;        // Top bar&#10;        TopBarUI(&#10;            bagCoinScore = totalScore,&#10;            chestItems = chestItems,&#10;            onBuyItem = { item, price -&gt;&#10;                if (totalScore &gt;= price) {&#10;                    totalScore -= price&#10;                    chestItems = chestItems + item&#10;                    if (!playerName.isNullOrBlank()) {&#10;                        FirebaseHelper.updateScore(playerName, totalScore)&#10;                        FirebaseHelper.updateChest(playerName, chestItems)&#10;                    }&#10;                }&#10;            },&#10;            onUseChestItem = { useChestItem(it) }&#10;        )&#10;&#10;        // --- Sound Control Button (top-right corner) ---&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp),&#10;            contentAlignment = androidx.compose.ui.Alignment.TopEnd&#10;        ) {&#10;            SoundControlButton()&#10;        }&#10;    }&#10;&#10;    // --- Game End Dialog ---&#10;    if (showGameEndDialog) {&#10;        GameEndDialog(&#10;            isWin = isLevelClear,&#10;            score = currentSessionScore,&#10;            level = 3,&#10;            onDismiss = {&#10;                showGameEndDialog = false&#10;            },&#10;            onReplay = {&#10;                // Reset game&#10;                showGameEndDialog = false&#10;                isGameOver = false&#10;                isLevelClear = false&#10;                planeHp = 100&#10;                currentSessionScore = 0&#10;&#10;                invisibleMonsters.forEachIndexed { index, m -&gt;&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 100f)&#10;                    m.y.value = -Random.nextInt(200, 3000).toFloat()&#10;                    m.hp.value = 100&#10;                    m.alive.value = true&#10;                    m.isVisible.value = Random.nextBoolean()&#10;                    m.lastToggleTime = System.currentTimeMillis()&#10;                    monsterRespawnTimes[index] = 0L&#10;                }&#10;&#10;                coins.forEach { c -&gt;&#10;                    c.collected.value = false&#10;                    c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                    c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                }&#10;&#10;                bullets.clear()&#10;            },&#10;            onNextLevel = {&#10;                onExit()&#10;            },&#10;            onExit = {&#10;                onExit()&#10;            }&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/game/Level5Activity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/game/Level5Activity.kt" />
              <option name="originalContent" value="package com.example.game&#10;&#10;import android.os.Bundle&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.TopBarComponent.TopBarUI&#10;import com.example.game.core.*&#10;import com.example.game.ui.PlaneUI&#10;import com.example.game.ui.WallUI&#10;import com.example.game.ui.SplittingMonsterUI&#10;import com.example.game.ui.SoundControlButton&#10;import com.example.game.ui.BagCoinAnimatedView&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.roundToInt&#10;import kotlin.random.Random&#10;&#10;class Level5Activity : BaseGameActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        initAudio()&#10;&#10;        // Initialize AI Avoidance Helper for smart bullet dodging&#10;        try {&#10;            AIAvoidanceHelper.init(this)&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            // Continue without AI if it fails&#10;        }&#10;&#10;        setContent {&#10;            val density = LocalDensity.current&#10;            val screenWidthPx = with(density) { LocalConfiguration.current.screenWidthDp.dp.toPx() }&#10;            val screenHeightPx = with(density) { LocalConfiguration.current.screenHeightDp.dp.toPx() }&#10;&#10;            Level5Game(&#10;                screenWidthPx = screenWidthPx,&#10;                screenHeightPx = screenHeightPx,&#10;                soundPool = soundPool,&#10;                shootSoundId = shootSoundId,&#10;                hitSoundId = hitSoundId,&#10;                onExit = { finish() }&#10;            )&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        try {&#10;            AIAvoidanceHelper.release()&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Level5Game(&#10;    screenWidthPx: Float,&#10;    screenHeightPx: Float,&#10;    soundPool: android.media.SoundPool,&#10;    shootSoundId: Int,&#10;    hitSoundId: Int,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val playerName = PrefManager.getPlayerName(context)&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // --- State ---&#10;    var totalScore by remember { mutableStateOf(0) }&#10;    var currentSessionScore by remember { mutableStateOf(0) }&#10;    var planeHp by remember { mutableStateOf(100) }&#10;&#10;    var shieldActive by remember { mutableStateOf(false) }&#10;    var wallActive by remember { mutableStateOf(false) }&#10;    var timeActive by remember { mutableStateOf(false) }&#10;&#10;    var isGameOver by remember { mutableStateOf(false) }&#10;    var isLevelClear by remember { mutableStateOf(false) }&#10;    var showGameEndDialog by remember { mutableStateOf(false) }&#10;&#10;    // Show dialog when game ends&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        if (isGameOver || isLevelClear) {&#10;            delay(500)&#10;            showGameEndDialog = true&#10;        }&#10;    }&#10;&#10;    // --- Plane setup ---&#10;    var planeX by remember { mutableStateOf(screenWidthPx / 2 - 50f) }&#10;    val planeY = screenHeightPx - 250f&#10;    val planeWidth = 100f&#10;    val planeHeight = 100f&#10;&#10;    // --- Background ---&#10;    var bg1Y by remember { mutableStateOf(0f) }&#10;    var bg2Y by remember { mutableStateOf(-screenHeightPx) }&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bg1Y += 4f&#10;            bg2Y += 4f&#10;            if (bg1Y &gt;= screenHeightPx) bg1Y = bg2Y - screenHeightPx&#10;            if (bg2Y &gt;= screenHeightPx) bg2Y = bg1Y - screenHeightPx&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Splitting Monsters (dynamic list) ---&#10;    val splittingMonsters = remember { mutableStateListOf&lt;SplittingMonster&gt;() }&#10;&#10;    // Initialize with some parent monsters&#10;    LaunchedEffect(Unit) {&#10;        repeat(8) {&#10;            splittingMonsters.add(&#10;                SplittingMonster(&#10;                    x = Random.nextFloat() * (screenWidthPx - 80f),&#10;                    y = mutableStateOf(-Random.nextInt(200, 2000).toFloat()),&#10;                    speed = Random.nextFloat() * 1.5f + 1.5f,&#10;                    hp = mutableStateOf(100),&#10;                    size = 80f,&#10;                    generation = 1&#10;                )&#10;            )&#10;        }&#10;    }&#10;&#10;    val coins = remember {&#10;        List(6) {&#10;            BaseCoin(&#10;                x = Random.nextFloat() * (screenWidthPx - 50f),&#10;                y = mutableStateOf(-Random.nextInt(100, 600).toFloat()),&#10;                speed = Random.nextFloat() * 2f + 1f&#10;            )&#10;        }&#10;    }&#10;&#10;    val bullets = remember { mutableStateListOf&lt;Bullet&gt;() }&#10;    val bagCoins = remember { mutableStateListOf&lt;BagCoinDisplay&gt;() }&#10;    var chestItems by remember { mutableStateOf&lt;List&lt;ChestItem&gt;&gt;(emptyList()) }&#10;&#10;    // --- Load player data ---&#10;    LaunchedEffect(Unit) {&#10;        if (!playerName.isNullOrBlank()) {&#10;            FirebaseHelper.syncNewPlayer(playerName)&#10;            FirebaseHelper.getScore(playerName) { totalScore = it }&#10;            FirebaseHelper.getChestItems(playerName) { chestItems = it }&#10;        }&#10;    }&#10;&#10;    // --- Shooting ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.add(Bullet(planeX + planeWidth / 2f - 15f, planeY))&#10;            SoundManager.playSoundEffect(soundPool, shootSoundId, 0.5f)&#10;            delay(300)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.forEach { it.y -= 25f }&#10;            bullets.removeAll { it.y &lt; -50f }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Monster movement (zigzag or bounce) + AI evasion ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            // Create a snapshot to avoid concurrent modification&#10;            val currentMonsters = splittingMonsters.toList()&#10;            currentMonsters.forEach { m -&gt;&#10;                if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp; !timeActive) {&#10;                    // AI-based evasion: monster tries to dodge bullets intelligently&#10;                    val evasion = AIAvoidanceHelper.calculateEvasion(&#10;                        monsterX = m.x,&#10;                        monsterY = m.y.value,&#10;                        monsterSize = m.size,&#10;                        bullets = bullets,&#10;                        screenWidth = screenWidthPx&#10;                    )&#10;&#10;                    if (m.isZigzagMovement) {&#10;                        // Zigzag movement combined with AI evasion&#10;                        val combinedX = (m.horizontalSpeed * m.direction) + evasion.first&#10;                        m.x = (m.x + combinedX).coerceIn(0f, screenWidthPx - m.size)&#10;&#10;                        if (m.x &lt;= 0 || m.x &gt;= screenWidthPx - m.size) {&#10;                            m.direction *= -1&#10;                        }&#10;                        m.y.value += m.speed&#10;                    } else {&#10;                        // Bounce movement combined with AI evasion&#10;                        m.x = (m.x + m.velocityX + evasion.first).coerceIn(0f, screenWidthPx - m.size)&#10;                        m.y.value += m.velocityY&#10;&#10;                        // Bounce off walls&#10;                        if (m.x &lt;= 0 || m.x &gt;= screenWidthPx - m.size) {&#10;                            m.velocityX *= -1&#10;                        }&#10;&#10;                        // Bounce off top (optional)&#10;                        if (m.y.value &lt;= 0) {&#10;                            m.velocityY *= -1&#10;                            m.y.value = 0f&#10;                        }&#10;                    }&#10;&#10;                    // Wall collision check&#10;                    val wallTop = planeY - 60f&#10;                    val monsterBottom = m.y.value + m.size&#10;&#10;                    if (wallActive &amp;&amp; monsterBottom &gt;= wallTop) {&#10;                        // Bounce back from wall&#10;                        if (!m.isZigzagMovement) {&#10;                            m.velocityY *= -1&#10;                        }&#10;                    }&#10;&#10;                    // If monster passes plane&#10;                    if (m.y.value &gt; planeY + planeHeight / 2f) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) {&#10;                            val damage = when(m.generation) {&#10;                                1 -&gt; 50 // Large&#10;                                2 -&gt; 30 // Medium&#10;                                else -&gt; 20 // Small&#10;                            }&#10;                            planeHp -= damage&#10;                        }&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Remove dead monsters (but spawn children first)&#10;            splittingMonsters.removeAll { !it.alive.value &amp;&amp; it.hasSpawned.value }&#10;&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Split monsters when killed ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            // Create a snapshot to avoid concurrent modification&#10;            val currentMonsters = splittingMonsters.toList()&#10;            currentMonsters.forEach { m -&gt;&#10;                if (!m.alive.value &amp;&amp; m.canSplit &amp;&amp; !m.hasSpawned.value) {&#10;                    m.hasSpawned.value = true&#10;&#10;                    // Spawn 2-3 smaller monsters&#10;                    val childCount = Random.nextInt(2, 4) // 2 or 3&#10;                    val newSize = m.size * 0.6f // 60% of parent size&#10;                    val newGeneration = m.generation + 1&#10;&#10;                    repeat(childCount) {&#10;                        splittingMonsters.add(&#10;                            SplittingMonster(&#10;                                x = m.x + Random.nextFloat() * 20f - 10f,&#10;                                y = mutableStateOf(m.y.value),&#10;                                speed = m.speed * 1.2f,&#10;                                hp = mutableStateOf(60),&#10;                                size = newSize,&#10;                                generation = newGeneration&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Coin movement ---&#10;    coins.forEach { c -&gt;&#10;        LaunchedEffect(c, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                if (!c.collected.value &amp;&amp; !timeActive) {&#10;                    c.y.value += c.speed&#10;                    if (c.y.value &gt; screenHeightPx) {&#10;                        c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                        c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                    }&#10;                }&#10;                delay(32)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Bullet vs Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            val iter = bullets.iterator()&#10;            while (iter.hasNext()) {&#10;                val b = iter.next()&#10;                // Create snapshot to avoid concurrent modification&#10;                val currentMonsters = splittingMonsters.toList()&#10;                var bulletRemoved = false&#10;                currentMonsters.forEach { m -&gt;&#10;                    if (!bulletRemoved &amp;&amp; CollisionUtils.checkCollisionBulletSplittingMonster(b, m)) {&#10;                        m.hp.value -= 25&#10;                        bulletRemoved = true&#10;                        // Play hit sound when bullet hits monster&#10;                        SoundManager.playSoundEffect(soundPool, hitSoundId, 0.3f)&#10;                        if (m.hp.value &lt;= 0) {&#10;                            m.alive.value = false&#10;                        }&#10;                    }&#10;                }&#10;                if (bulletRemoved) {&#10;                    iter.remove()&#10;                }&#10;            }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Coin collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            coins.forEach { c -&gt;&#10;                if (!c.collected.value &amp;&amp; CollisionUtils.checkCollisionPlaneCoin(planeX, planeY, planeWidth, planeHeight, c)) {&#10;                    c.collected.value = true&#10;                    totalScore += 1&#10;                    currentSessionScore += 1&#10;                    val bag = BagCoinDisplay(c.x, c.y.value, 1)&#10;                    bagCoins.add(bag)&#10;                    if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            // Create snapshot to avoid concurrent modification&#10;            val currentMonsters = splittingMonsters.toList()&#10;            currentMonsters.forEach { m -&gt;&#10;                if (CollisionUtils.checkCollisionPlaneSplittingMonster(planeX, planeY, planeWidth, planeHeight, m)) {&#10;                    if (!shieldActive &amp;&amp; !wallActive) {&#10;                        val damage = when(m.generation) {&#10;                            1 -&gt; 50&#10;                            2 -&gt; 30&#10;                            else -&gt; 20&#10;                        }&#10;                        planeHp -= damage&#10;                    }&#10;                    m.hp.value = 0&#10;                    m.alive.value = false&#10;                }&#10;            }&#10;            if (planeHp &lt;= 0) isGameOver = true&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Wall - Monster collision ---&#10;    LaunchedEffect(wallActive, isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            if (wallActive) {&#10;                // Create snapshot to avoid concurrent modification&#10;                val currentMonsters = splittingMonsters.toList()&#10;                currentMonsters.forEach { m -&gt;&#10;                    if (CollisionUtils.checkCollisionWallSplittingMonster(planeY, m)) {&#10;                        m.hp.value -= 2&#10;                        if (m.hp.value &lt;= 0) {&#10;                            m.alive.value = false&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Use chest item ---&#10;    fun useChestItem(item: ChestItem) {&#10;        ChestItemEffectsBase.applyItemEffect(&#10;            itemName = item.name,&#10;            monsters = splittingMonsters,&#10;            coins = coins,&#10;            bagCoins = bagCoins,&#10;            coroutineScope = coroutineScope,&#10;            screenHeightPx = screenHeightPx,&#10;            planeX = planeX,&#10;            onScoreUpdate = { add -&gt;&#10;                totalScore += add&#10;                currentSessionScore += add&#10;                if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;            },&#10;            onShieldToggle = { active -&gt; shieldActive = active },&#10;            onWallToggle = { active -&gt; wallActive = active },&#10;            onTimeToggle = { active -&gt; timeActive = active },&#10;            onLevelClear = { isLevelClear = true }&#10;        )&#10;        chestItems = chestItems - item&#10;        if (!playerName.isNullOrBlank()) FirebaseHelper.updateChest(playerName, chestItems)&#10;    }&#10;&#10;    // --- Drag plane ---&#10;    val dragModifier = Modifier.pointerInput(Unit) {&#10;        detectDragGestures { change, dragAmount -&gt;&#10;            planeX = (planeX + dragAmount.x).coerceIn(0f, screenWidthPx - planeWidth)&#10;            change.consume()&#10;        }&#10;    }&#10;&#10;    // --- UI ---&#10;    Box(modifier = Modifier.fillMaxSize().then(dragModifier)) {&#10;        // Background&#10;        Image(&#10;            painter = painterResource(R.drawable.vutru1),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg1Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;        Image(&#10;            painter = painterResource(R.drawable.vutru1),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg2Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;&#10;        // Splitting Monsters&#10;        splittingMonsters.forEach { m -&gt;&#10;            SplittingMonsterUI(monster = m)&#10;        }&#10;&#10;        // Coins&#10;        coins.filter { !it.collected.value }.forEach { c -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.coin),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(c.x.roundToInt(), c.y.value.roundToInt()) }&#10;                    .size(40.dp)&#10;            )&#10;        }&#10;&#10;        // BagCoin animated views&#10;        bagCoins.toList().forEach { bag -&gt;&#10;            BagCoinAnimatedView(bag = bag, onFinished = { finishedBag -&gt;&#10;                bagCoins.remove(finishedBag)&#10;            })&#10;        }&#10;&#10;        // Bullets&#10;        bullets.forEach { b -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.dan2),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(b.x.roundToInt(), b.y.roundToInt()) }&#10;                    .size(30.dp)&#10;            )&#10;        }&#10;&#10;        // Plane&#10;        PlaneUI(&#10;            planeX = planeX,&#10;            planeY = planeY,&#10;            planeHp = planeHp,&#10;            shieldActive = shieldActive&#10;        )&#10;&#10;        // Wall&#10;        if (wallActive) {&#10;            WallUI(planeY = planeY)&#10;        }&#10;&#10;        // Top bar&#10;        TopBarUI(&#10;            bagCoinScore = totalScore,&#10;            chestItems = chestItems,&#10;            onBuyItem = { item, price -&gt;&#10;                if (totalScore &gt;= price) {&#10;                    totalScore -= price&#10;                    chestItems = chestItems + item&#10;                    if (!playerName.isNullOrBlank()) {&#10;                        FirebaseHelper.updateScore(playerName, totalScore)&#10;                        FirebaseHelper.updateChest(playerName, chestItems)&#10;                    }&#10;                }&#10;            },&#10;            onUseChestItem = { useChestItem(it) }&#10;        )&#10;&#10;        // --- Sound Control Button (top-right corner) ---&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp),&#10;            contentAlignment = androidx.compose.ui.Alignment.TopEnd&#10;        ) {&#10;            SoundControlButton()&#10;        }&#10;    }&#10;&#10;    // --- Game End Dialog ---&#10;    if (showGameEndDialog) {&#10;        GameEndDialog(&#10;            isWin = isLevelClear,&#10;            score = currentSessionScore,&#10;            level = 5,&#10;            onDismiss = {&#10;                showGameEndDialog = false&#10;            },&#10;            onReplay = {&#10;                showGameEndDialog = false&#10;                isGameOver = false&#10;                isLevelClear = false&#10;                planeHp = 100&#10;                currentSessionScore = 0&#10;&#10;                splittingMonsters.clear()&#10;                repeat(8) {&#10;                    splittingMonsters.add(&#10;                        SplittingMonster(&#10;                            x = Random.nextFloat() * (screenWidthPx - 80f),&#10;                            y = mutableStateOf(-Random.nextInt(200, 2000).toFloat()),&#10;                            speed = Random.nextFloat() * 1.5f + 1.5f,&#10;                            hp = mutableStateOf(100),&#10;                            size = 80f,&#10;                            generation = 1&#10;                        )&#10;                    )&#10;                }&#10;&#10;                coins.forEach { c -&gt;&#10;                    c.collected.value = false&#10;                    c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                    c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                }&#10;&#10;                bullets.clear()&#10;            },&#10;            onNextLevel = {&#10;                onExit()&#10;            },&#10;            onExit = {&#10;                onExit()&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * BagCoinAnimatedView for Level 5&#10; * - Animates a bag coin sprite moving slightly up and fading out.&#10; * - Calls onFinished(bag) when animation done so caller can remove it.&#10; */&#10;@Composable&#10;private fun BagCoinAnimatedView(bag: BagCoinDisplay, onFinished: (BagCoinDisplay) -&gt; Unit) {&#10;    var offsetY by remember { mutableStateOf(bag.y) }&#10;    var alpha by remember { mutableStateOf(1f) }&#10;&#10;    LaunchedEffect(bag) {&#10;        val duration = 800L&#10;        val steps = 40&#10;        repeat(steps) { i -&gt;&#10;            offsetY -= 2f&#10;            alpha = 1f - (i / steps.toFloat())&#10;            delay(duration / steps)&#10;        }&#10;        onFinished(bag)&#10;    }&#10;&#10;    Image(&#10;        painter = painterResource(R.drawable.bagcoin),&#10;        contentDescription = null,&#10;        modifier = Modifier&#10;            .absoluteOffset { IntOffset(bag.x.roundToInt(), offsetY.roundToInt()) }&#10;            .size(60.dp)&#10;            .graphicsLayer { this.alpha = alpha }&#10;    )&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.game&#10;&#10;import android.os.Bundle&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.TopBarComponent.TopBarUI&#10;import com.example.game.core.*&#10;import com.example.game.ui.PlaneUI&#10;import com.example.game.ui.WallUI&#10;import com.example.game.ui.SplittingMonsterUI&#10;import com.example.game.ui.SoundControlButton&#10;import com.example.game.ui.BagCoinAnimatedView&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.roundToInt&#10;import kotlin.random.Random&#10;&#10;class Level5Activity : BaseGameActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        initAudio()&#10;&#10;        // Initialize AI Avoidance Helper for smart bullet dodging&#10;        try {&#10;            AIAvoidanceHelper.init(this)&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            // Continue without AI if it fails&#10;        }&#10;&#10;        setContent {&#10;            val density = LocalDensity.current&#10;            val screenWidthPx = with(density) { LocalConfiguration.current.screenWidthDp.dp.toPx() }&#10;            val screenHeightPx = with(density) { LocalConfiguration.current.screenHeightDp.dp.toPx() }&#10;&#10;            Level5Game(&#10;                screenWidthPx = screenWidthPx,&#10;                screenHeightPx = screenHeightPx,&#10;                soundPool = soundPool,&#10;                shootSoundId = shootSoundId,&#10;                hitSoundId = hitSoundId,&#10;                onExit = { finish() }&#10;            )&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        try {&#10;            AIAvoidanceHelper.release()&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Level5Game(&#10;    screenWidthPx: Float,&#10;    screenHeightPx: Float,&#10;    soundPool: android.media.SoundPool,&#10;    shootSoundId: Int,&#10;    hitSoundId: Int,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val playerName = PrefManager.getPlayerName(context)&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // --- State ---&#10;    var totalScore by remember { mutableStateOf(0) }&#10;    var currentSessionScore by remember { mutableStateOf(0) }&#10;    var planeHp by remember { mutableStateOf(100) }&#10;&#10;    var shieldActive by remember { mutableStateOf(false) }&#10;    var wallActive by remember { mutableStateOf(false) }&#10;    var timeActive by remember { mutableStateOf(false) }&#10;&#10;    var isGameOver by remember { mutableStateOf(false) }&#10;    var isLevelClear by remember { mutableStateOf(false) }&#10;    var showGameEndDialog by remember { mutableStateOf(false) }&#10;&#10;    // Show dialog when game ends&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        if (isGameOver || isLevelClear) {&#10;            delay(500)&#10;            showGameEndDialog = true&#10;        }&#10;    }&#10;&#10;    // --- Plane setup ---&#10;    var planeX by remember { mutableStateOf(screenWidthPx / 2 - 50f) }&#10;    val planeY = screenHeightPx - 250f&#10;    val planeWidth = 100f&#10;    val planeHeight = 100f&#10;&#10;    // --- Background ---&#10;    var bg1Y by remember { mutableStateOf(0f) }&#10;    var bg2Y by remember { mutableStateOf(-screenHeightPx) }&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bg1Y += 4f&#10;            bg2Y += 4f&#10;            if (bg1Y &gt;= screenHeightPx) bg1Y = bg2Y - screenHeightPx&#10;            if (bg2Y &gt;= screenHeightPx) bg2Y = bg1Y - screenHeightPx&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Splitting Monsters (dynamic list) ---&#10;    val splittingMonsters = remember { mutableStateListOf&lt;SplittingMonster&gt;() }&#10;&#10;    // Initialize with some parent monsters&#10;    LaunchedEffect(Unit) {&#10;        repeat(8) {&#10;            splittingMonsters.add(&#10;                SplittingMonster(&#10;                    x = Random.nextFloat() * (screenWidthPx - 80f),&#10;                    y = mutableStateOf(-Random.nextInt(200, 2000).toFloat()),&#10;                    speed = Random.nextFloat() * 1.5f + 1.5f,&#10;                    hp = mutableStateOf(100),&#10;                    size = 80f,&#10;                    generation = 1&#10;                )&#10;            )&#10;        }&#10;    }&#10;&#10;    val coins = remember {&#10;        List(6) {&#10;            BaseCoin(&#10;                x = Random.nextFloat() * (screenWidthPx - 50f),&#10;                y = mutableStateOf(-Random.nextInt(100, 600).toFloat()),&#10;                speed = Random.nextFloat() * 2f + 1f&#10;            )&#10;        }&#10;    }&#10;&#10;    val bullets = remember { mutableStateListOf&lt;Bullet&gt;() }&#10;    val bagCoins = remember { mutableStateListOf&lt;BagCoinDisplay&gt;() }&#10;    var chestItems by remember { mutableStateOf&lt;List&lt;ChestItem&gt;&gt;(emptyList()) }&#10;&#10;    // --- Load player data ---&#10;    LaunchedEffect(Unit) {&#10;        if (!playerName.isNullOrBlank()) {&#10;            FirebaseHelper.syncNewPlayer(playerName)&#10;            FirebaseHelper.getScore(playerName) { totalScore = it }&#10;            FirebaseHelper.getChestItems(playerName) { chestItems = it }&#10;        }&#10;    }&#10;&#10;    // --- Shooting ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.add(Bullet(planeX + planeWidth / 2f - 15f, planeY))&#10;            SoundManager.playSoundEffect(soundPool, shootSoundId, 0.5f)&#10;            delay(300)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.forEach { it.y -= 25f }&#10;            bullets.removeAll { it.y &lt; -50f }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Monster movement (zigzag or bounce) + AI evasion ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            // Create a snapshot to avoid concurrent modification&#10;            val currentMonsters = splittingMonsters.toList()&#10;            currentMonsters.forEach { m -&gt;&#10;                if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp; !timeActive) {&#10;                    // AI-based evasion: monster tries to dodge bullets intelligently&#10;                    val evasion = AIAvoidanceHelper.calculateEvasion(&#10;                        monsterX = m.x,&#10;                        monsterY = m.y.value,&#10;                        monsterSize = m.size,&#10;                        bullets = bullets,&#10;                        screenWidth = screenWidthPx&#10;                    )&#10;&#10;                    if (m.isZigzagMovement) {&#10;                        // Zigzag movement combined with AI evasion&#10;                        val combinedX = (m.horizontalSpeed * m.direction) + evasion.first&#10;                        m.x = (m.x + combinedX).coerceIn(0f, screenWidthPx - m.size)&#10;&#10;                        if (m.x &lt;= 0 || m.x &gt;= screenWidthPx - m.size) {&#10;                            m.direction *= -1&#10;                        }&#10;                        m.y.value += m.speed&#10;                    } else {&#10;                        // Bounce movement combined with AI evasion&#10;                        m.x = (m.x + m.velocityX + evasion.first).coerceIn(0f, screenWidthPx - m.size)&#10;                        m.y.value += m.velocityY&#10;&#10;                        // Bounce off walls&#10;                        if (m.x &lt;= 0 || m.x &gt;= screenWidthPx - m.size) {&#10;                            m.velocityX *= -1&#10;                        }&#10;&#10;                        // Bounce off top (optional)&#10;                        if (m.y.value &lt;= 0) {&#10;                            m.velocityY *= -1&#10;                            m.y.value = 0f&#10;                        }&#10;                    }&#10;&#10;                    // Wall collision check&#10;                    val wallTop = planeY - 60f&#10;                    val monsterBottom = m.y.value + m.size&#10;&#10;                    if (wallActive &amp;&amp; monsterBottom &gt;= wallTop) {&#10;                        // Bounce back from wall&#10;                        if (!m.isZigzagMovement) {&#10;                            m.velocityY *= -1&#10;                        }&#10;                    }&#10;&#10;                    // If monster passes plane&#10;                    if (m.y.value &gt; planeY + planeHeight / 2f) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) {&#10;                            val damage = when(m.generation) {&#10;                                1 -&gt; 50 // Large&#10;                                2 -&gt; 30 // Medium&#10;                                else -&gt; 20 // Small&#10;                            }&#10;                            planeHp -= damage&#10;                        }&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Remove dead monsters (but spawn children first)&#10;            splittingMonsters.removeAll { !it.alive.value &amp;&amp; it.hasSpawned.value }&#10;&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Split monsters when killed ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            // Create a snapshot to avoid concurrent modification&#10;            val currentMonsters = splittingMonsters.toList()&#10;            currentMonsters.forEach { m -&gt;&#10;                if (!m.alive.value &amp;&amp; m.canSplit &amp;&amp; !m.hasSpawned.value) {&#10;                    m.hasSpawned.value = true&#10;&#10;                    // Spawn 2-3 smaller monsters&#10;                    val childCount = Random.nextInt(2, 4) // 2 or 3&#10;                    val newSize = m.size * 0.6f // 60% of parent size&#10;                    val newGeneration = m.generation + 1&#10;&#10;                    repeat(childCount) {&#10;                        splittingMonsters.add(&#10;                            SplittingMonster(&#10;                                x = m.x + Random.nextFloat() * 20f - 10f,&#10;                                y = mutableStateOf(m.y.value),&#10;                                speed = m.speed * 1.2f,&#10;                                hp = mutableStateOf(60),&#10;                                size = newSize,&#10;                                generation = newGeneration&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Coin movement ---&#10;    coins.forEach { c -&gt;&#10;        LaunchedEffect(c, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                if (!c.collected.value &amp;&amp; !timeActive) {&#10;                    c.y.value += c.speed&#10;                    if (c.y.value &gt; screenHeightPx) {&#10;                        c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                        c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                    }&#10;                }&#10;                delay(32)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Bullet vs Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            val iter = bullets.iterator()&#10;            while (iter.hasNext()) {&#10;                val b = iter.next()&#10;                // Create snapshot to avoid concurrent modification&#10;                val currentMonsters = splittingMonsters.toList()&#10;                var bulletRemoved = false&#10;                currentMonsters.forEach { m -&gt;&#10;                    if (!bulletRemoved &amp;&amp; CollisionUtils.checkCollisionBulletSplittingMonster(b, m)) {&#10;                        m.hp.value -= 25&#10;                        bulletRemoved = true&#10;                        // Play hit sound when bullet hits monster&#10;                        SoundManager.playSoundEffect(soundPool, hitSoundId, 0.3f)&#10;                        if (m.hp.value &lt;= 0) {&#10;                            m.alive.value = false&#10;                        }&#10;                    }&#10;                }&#10;                if (bulletRemoved) {&#10;                    iter.remove()&#10;                }&#10;            }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Coin collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            coins.forEach { c -&gt;&#10;                if (!c.collected.value &amp;&amp; CollisionUtils.checkCollisionPlaneCoin(planeX, planeY, planeWidth, planeHeight, c)) {&#10;                    c.collected.value = true&#10;                    totalScore += 1&#10;                    currentSessionScore += 1&#10;                    val bag = BagCoinDisplay(c.x, c.y.value, 1)&#10;                    bagCoins.add(bag)&#10;                    if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            // Create snapshot to avoid concurrent modification&#10;            val currentMonsters = splittingMonsters.toList()&#10;            currentMonsters.forEach { m -&gt;&#10;                if (CollisionUtils.checkCollisionPlaneSplittingMonster(planeX, planeY, planeWidth, planeHeight, m)) {&#10;                    if (!shieldActive &amp;&amp; !wallActive) {&#10;                        val damage = when(m.generation) {&#10;                            1 -&gt; 50&#10;                            2 -&gt; 30&#10;                            else -&gt; 20&#10;                        }&#10;                        planeHp -= damage&#10;                    }&#10;                    m.hp.value = 0&#10;                    m.alive.value = false&#10;                }&#10;            }&#10;            if (planeHp &lt;= 0) isGameOver = true&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Wall - Monster collision ---&#10;    LaunchedEffect(wallActive, isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            if (wallActive) {&#10;                // Create snapshot to avoid concurrent modification&#10;                val currentMonsters = splittingMonsters.toList()&#10;                currentMonsters.forEach { m -&gt;&#10;                    if (CollisionUtils.checkCollisionWallSplittingMonster(planeY, m)) {&#10;                        m.hp.value -= 2&#10;                        if (m.hp.value &lt;= 0) {&#10;                            m.alive.value = false&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Use chest item ---&#10;    fun useChestItem(item: ChestItem) {&#10;        ChestItemEffectsBase.applyItemEffect(&#10;            itemName = item.name,&#10;            monsters = splittingMonsters,&#10;            coins = coins,&#10;            bagCoins = bagCoins,&#10;            coroutineScope = coroutineScope,&#10;            screenHeightPx = screenHeightPx,&#10;            planeX = planeX,&#10;            onScoreUpdate = { add -&gt;&#10;                totalScore += add&#10;                currentSessionScore += add&#10;                if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;            },&#10;            onShieldToggle = { active -&gt; shieldActive = active },&#10;            onWallToggle = { active -&gt; wallActive = active },&#10;            onTimeToggle = { active -&gt; timeActive = active },&#10;            onLevelClear = { isLevelClear = true }&#10;        )&#10;        chestItems = chestItems - item&#10;        if (!playerName.isNullOrBlank()) FirebaseHelper.updateChest(playerName, chestItems)&#10;    }&#10;&#10;    // --- Drag plane ---&#10;    val dragModifier = Modifier.pointerInput(Unit) {&#10;        detectDragGestures { change, dragAmount -&gt;&#10;            planeX = (planeX + dragAmount.x).coerceIn(0f, screenWidthPx - planeWidth)&#10;            change.consume()&#10;        }&#10;    }&#10;&#10;    // --- UI ---&#10;    Box(modifier = Modifier.fillMaxSize().then(dragModifier)) {&#10;        // Background&#10;        Image(&#10;            painter = painterResource(R.drawable.vutru1),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg1Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;        Image(&#10;            painter = painterResource(R.drawable.vutru1),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg2Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;&#10;        // Splitting Monsters&#10;        splittingMonsters.forEach { m -&gt;&#10;            SplittingMonsterUI(monster = m)&#10;        }&#10;&#10;        // Coins&#10;        coins.filter { !it.collected.value }.forEach { c -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.coin),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(c.x.roundToInt(), c.y.value.roundToInt()) }&#10;                    .size(40.dp)&#10;            )&#10;        }&#10;&#10;        // BagCoin animated views&#10;        bagCoins.toList().forEach { bag -&gt;&#10;            BagCoinAnimatedView(bag = bag, onFinished = { finishedBag -&gt;&#10;                bagCoins.remove(finishedBag)&#10;            })&#10;        }&#10;&#10;        // Bullets&#10;        bullets.forEach { b -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.dan2),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(b.x.roundToInt(), b.y.roundToInt()) }&#10;                    .size(30.dp)&#10;            )&#10;        }&#10;&#10;        // Plane&#10;        PlaneUI(&#10;            planeX = planeX,&#10;            planeY = planeY,&#10;            planeHp = planeHp,&#10;            shieldActive = shieldActive&#10;        )&#10;&#10;        // Wall&#10;        if (wallActive) {&#10;            WallUI(planeY = planeY)&#10;        }&#10;&#10;        // Top bar&#10;        TopBarUI(&#10;            bagCoinScore = totalScore,&#10;            chestItems = chestItems,&#10;            onBuyItem = { item, price -&gt;&#10;                if (totalScore &gt;= price) {&#10;                    totalScore -= price&#10;                    chestItems = chestItems + item&#10;                    if (!playerName.isNullOrBlank()) {&#10;                        FirebaseHelper.updateScore(playerName, totalScore)&#10;                        FirebaseHelper.updateChest(playerName, chestItems)&#10;                    }&#10;                }&#10;            },&#10;            onUseChestItem = { useChestItem(it) }&#10;        )&#10;&#10;        // --- Sound Control Button (top-right corner) ---&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp),&#10;            contentAlignment = androidx.compose.ui.Alignment.TopEnd&#10;        ) {&#10;            SoundControlButton()&#10;        }&#10;    }&#10;&#10;    // --- Game End Dialog ---&#10;    if (showGameEndDialog) {&#10;        GameEndDialog(&#10;            isWin = isLevelClear,&#10;            score = currentSessionScore,&#10;            level = 5,&#10;            onDismiss = {&#10;                showGameEndDialog = false&#10;            },&#10;            onReplay = {&#10;                showGameEndDialog = false&#10;                isGameOver = false&#10;                isLevelClear = false&#10;                planeHp = 100&#10;                currentSessionScore = 0&#10;&#10;                splittingMonsters.clear()&#10;                repeat(8) {&#10;                    splittingMonsters.add(&#10;                        SplittingMonster(&#10;                            x = Random.nextFloat() * (screenWidthPx - 80f),&#10;                            y = mutableStateOf(-Random.nextInt(200, 2000).toFloat()),&#10;                            speed = Random.nextFloat() * 1.5f + 1.5f,&#10;                            hp = mutableStateOf(100),&#10;                            size = 80f,&#10;                            generation = 1&#10;                        )&#10;                    )&#10;                }&#10;&#10;                coins.forEach { c -&gt;&#10;                    c.collected.value = false&#10;                    c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                    c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                }&#10;&#10;                bullets.clear()&#10;            },&#10;            onNextLevel = {&#10;                onExit()&#10;            },&#10;            onExit = {&#10;                onExit()&#10;            }&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/game/core/GameOverlays.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/game/core/GameOverlays.kt" />
              <option name="originalContent" value="package com.example.game.core&#10;&#10;import android.content.Intent&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.fadeIn&#10;import androidx.compose.animation.fadeOut&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.window.Dialog&#10;import androidx.compose.ui.window.DialogProperties&#10;import com.example.game.GameScreenActivity&#10;import com.example.game.Level2Activity&#10;import com.example.game.Level3Activity&#10;import com.example.game.Level4Activity&#10;import com.example.game.Level5Activity&#10;import com.example.game.MainActivity&#10;import com.example.game.R&#10;import com.example.game.Top6Activity&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.roundToInt&#10;&#10;enum class OverlayType { WIN, GAME_OVER }&#10;&#10;@Composable&#10;fun GameOverlay(type: OverlayType, score: Int, onExit: () -&gt; Unit) {&#10;    val context = LocalContext.current&#10;    var visible by remember { mutableStateOf(false) }&#10;    LaunchedEffect(Unit) { visible = true }&#10;&#10;    AnimatedVisibility(visible, enter = fadeIn(), exit = fadeOut()) {&#10;        Box(&#10;            Modifier.fillMaxSize().background(Color(0xAA000000)),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                val img = if (type == OverlayType.WIN) R.drawable.win else R.drawable.game_over&#10;                Image(painterResource(img), null, Modifier.size(300.dp))&#10;                Spacer(Modifier.height(16.dp))&#10;                Text(&quot;Bạn thu thêm được $score xu&quot;, color = Color.Yellow, fontSize = 24.sp)&#10;                Spacer(Modifier.height(24.dp))&#10;                if (type == OverlayType.WIN) {&#10;                    Row(horizontalArrangement = Arrangement.spacedBy(16.dp)) {&#10;                        Button(onClick = { onExit() }) { Text(&quot;Thoát&quot;, fontSize = 20.sp) }&#10;                        Button(onClick = {&#10;                            val intent = Intent(context, Top6Activity::class.java)&#10;                            context.startActivity(intent)&#10;                        }) { Text(&quot;Top 6&quot;, fontSize = 20.sp) }&#10;                    }&#10;                } else Button(onClick = { onExit() }) { Text(&quot;Thoát&quot;, fontSize = 20.sp) }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * GameEndDialog - Reusable dialog for game end screen&#10; * Displays as an overlay without navigating to a new activity&#10; */&#10;@Composable&#10;fun GameEndDialog(&#10;    isWin: Boolean,&#10;    score: Int,&#10;    level: Int,&#10;    onDismiss: () -&gt; Unit,&#10;    onReplay: () -&gt; Unit,&#10;    onNextLevel: () -&gt; Unit,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;&#10;    Dialog(&#10;        onDismissRequest = { /* Prevent dismissing by clicking outside */ },&#10;        properties = DialogProperties(&#10;            dismissOnBackPress = false,&#10;            dismissOnClickOutside = false,&#10;            usePlatformDefaultWidth = false&#10;        )&#10;    ) {&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .background(Color(0xDD000000)),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            Column(&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.Center,&#10;                modifier = Modifier.padding(32.dp)&#10;            ) {&#10;                // Game End Image (Win or Game Over)&#10;                val imageRes = if (isWin) R.drawable.win else R.drawable.game_over&#10;                Image(&#10;                    painter = painterResource(imageRes),&#10;                    contentDescription = if (isWin) &quot;Win&quot; else &quot;Game Over&quot;,&#10;                    modifier = Modifier.size(300.dp)&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                // Level info&#10;                Text(&#10;                    text = &quot;Level $level&quot;,&#10;                    color = Color.White,&#10;                    fontSize = 28.sp&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                // Score info&#10;                Text(&#10;                    text = &quot;Bạn thu thêm được $score xu&quot;,&#10;                    color = Color.Yellow,&#10;                    fontSize = 24.sp&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(32.dp))&#10;&#10;                // Buttons&#10;                if (isWin) {&#10;                    // WIN buttons&#10;                    Column(&#10;                        horizontalAlignment = Alignment.CenterHorizontally,&#10;                        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                    ) {&#10;                        // Next Level button (if not last level)&#10;                        if (level &lt; 5) {&#10;                            Button(&#10;                                onClick = {&#10;                                    val nextLevelIntent = when (level) {&#10;                                        1 -&gt; Intent(context, Level2Activity::class.java)&#10;                                        2 -&gt; Intent(context, Level3Activity::class.java)&#10;                                        3 -&gt; Intent(context, Level4Activity::class.java)&#10;                                        4 -&gt; Intent(context, Level5Activity::class.java)&#10;                                        else -&gt; null&#10;                                    }&#10;                                    nextLevelIntent?.let {&#10;                                        it.flags = Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_NEW_TASK&#10;                                        context.startActivity(it)&#10;                                        onNextLevel()&#10;                                    }&#10;                                },&#10;                                modifier = Modifier.width(200.dp)&#10;                            ) {&#10;                                Text(&quot;Level tiếp theo&quot;, fontSize = 20.sp)&#10;                            }&#10;                        }&#10;&#10;                        // Replay button&#10;                        Button(&#10;                            onClick = onReplay,&#10;                            modifier = Modifier.width(200.dp)&#10;                        ) {&#10;                            Text(&quot;Chơi lại&quot;, fontSize = 20.sp)&#10;                        }&#10;&#10;                        // Top 6 button&#10;                        Button(&#10;                            onClick = {&#10;                                val intent = Intent(context, Top6Activity::class.java)&#10;                                context.startActivity(intent)&#10;                            },&#10;                            modifier = Modifier.width(200.dp)&#10;                        ) {&#10;                            Text(&quot;Top 6&quot;, fontSize = 20.sp)&#10;                        }&#10;&#10;                        // Exit button&#10;                        Button(&#10;                            onClick = onExit,&#10;                            modifier = Modifier.width(200.dp)&#10;                        ) {&#10;                            Text(&quot;Thoát&quot;, fontSize = 20.sp)&#10;                        }&#10;                    }&#10;                } else {&#10;                    // GAME OVER buttons&#10;                    Column(&#10;                        horizontalAlignment = Alignment.CenterHorizontally,&#10;                        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                    ) {&#10;                        // Replay button&#10;                        Button(&#10;                            onClick = onReplay,&#10;                            modifier = Modifier.width(200.dp)&#10;                        ) {&#10;                            Text(&quot;Chơi lại&quot;, fontSize = 20.sp)&#10;                        }&#10;&#10;                        // Exit button&#10;                        Button(&#10;                            onClick = onExit,&#10;                            modifier = Modifier.width(200.dp)&#10;                        ) {&#10;                            Text(&quot;Thoát&quot;, fontSize = 20.sp)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * BagCoinAnimatedView - Reusable component for coin collection animation&#10; * Can be used across all game levels&#10; */&#10;@Composable&#10;fun BagCoinAnimatedView(bag: BagCoinDisplay, onFinished: (BagCoinDisplay) -&gt; Unit) {&#10;    var offsetY by remember { mutableStateOf(bag.y) }&#10;    var alpha by remember { mutableStateOf(1f) }&#10;&#10;    LaunchedEffect(bag) {&#10;        val duration = 800L&#10;        val steps = 40&#10;        repeat(steps) { i -&gt;&#10;            offsetY -= 2f&#10;            alpha = 1f - (i / steps.toFloat())&#10;            delay(duration / steps)&#10;        }&#10;        onFinished(bag)&#10;    }&#10;&#10;    Image(&#10;        painter = painterResource(R.drawable.bagcoin),&#10;        contentDescription = null,&#10;        modifier = Modifier&#10;            .absoluteOffset { IntOffset(bag.x.roundToInt(), offsetY.roundToInt()) }&#10;            .size(60.dp)&#10;            .graphicsLayer { this.alpha = alpha }&#10;    )&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.game.core&#10;&#10;import android.content.Intent&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.fadeIn&#10;import androidx.compose.animation.fadeOut&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.window.Dialog&#10;import androidx.compose.ui.window.DialogProperties&#10;import com.example.game.GameScreenActivity&#10;import com.example.game.Level2Activity&#10;import com.example.game.Level3Activity&#10;import com.example.game.Level4Activity&#10;import com.example.game.Level5Activity&#10;import com.example.game.MainActivity&#10;import com.example.game.R&#10;import com.example.game.Top6Activity&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.roundToInt&#10;&#10;enum class OverlayType { WIN, GAME_OVER }&#10;&#10;@Composable&#10;fun GameOverlay(type: OverlayType, score: Int, onExit: () -&gt; Unit) {&#10;    val context = LocalContext.current&#10;    var visible by remember { mutableStateOf(false) }&#10;    LaunchedEffect(Unit) { visible = true }&#10;&#10;    AnimatedVisibility(visible, enter = fadeIn(), exit = fadeOut()) {&#10;        Box(&#10;            Modifier.fillMaxSize().background(Color(0xAA000000)),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                val img = if (type == OverlayType.WIN) R.drawable.win else R.drawable.game_over&#10;                Image(painterResource(img), null, Modifier.size(300.dp))&#10;                Spacer(Modifier.height(16.dp))&#10;                Text(&quot;Bạn thu thêm được $score xu&quot;, color = Color.Yellow, fontSize = 24.sp)&#10;                Spacer(Modifier.height(24.dp))&#10;                if (type == OverlayType.WIN) {&#10;                    Row(horizontalArrangement = Arrangement.spacedBy(16.dp)) {&#10;                        Button(onClick = { onExit() }) { Text(&quot;Thoát&quot;, fontSize = 20.sp) }&#10;                        Button(onClick = {&#10;                            val intent = Intent(context, Top6Activity::class.java)&#10;                            context.startActivity(intent)&#10;                        }) { Text(&quot;Top 6&quot;, fontSize = 20.sp) }&#10;                    }&#10;                } else Button(onClick = { onExit() }) { Text(&quot;Thoát&quot;, fontSize = 20.sp) }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * GameEndDialog - Reusable dialog for game end screen&#10; * Displays as an overlay without navigating to a new activity&#10; */&#10;@Composable&#10;fun GameEndDialog(&#10;    isWin: Boolean,&#10;    score: Int,&#10;    level: Int,&#10;    onDismiss: () -&gt; Unit,&#10;    onReplay: () -&gt; Unit,&#10;    onNextLevel: () -&gt; Unit,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;&#10;    Dialog(&#10;        onDismissRequest = { /* Prevent dismissing by clicking outside */ },&#10;        properties = DialogProperties(&#10;            dismissOnBackPress = false,&#10;            dismissOnClickOutside = false,&#10;            usePlatformDefaultWidth = false&#10;        )&#10;    ) {&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .background(Color(0xDD000000)),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            Column(&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.Center,&#10;                modifier = Modifier.padding(32.dp)&#10;            ) {&#10;                // Game End Image (Win or Game Over)&#10;                val imageRes = if (isWin) R.drawable.win else R.drawable.game_over&#10;                Image(&#10;                    painter = painterResource(imageRes),&#10;                    contentDescription = if (isWin) &quot;Win&quot; else &quot;Game Over&quot;,&#10;                    modifier = Modifier.size(300.dp)&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                // Level info&#10;                Text(&#10;                    text = &quot;Level $level&quot;,&#10;                    color = Color.White,&#10;                    fontSize = 28.sp&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                // Score info&#10;                Text(&#10;                    text = &quot;Bạn thu thêm được $score xu&quot;,&#10;                    color = Color.Yellow,&#10;                    fontSize = 24.sp&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(32.dp))&#10;&#10;                // Buttons&#10;                if (isWin) {&#10;                    // WIN buttons&#10;                    Column(&#10;                        horizontalAlignment = Alignment.CenterHorizontally,&#10;                        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                    ) {&#10;                        // Next Level button (if not last level)&#10;                        if (level &lt; 5) {&#10;                            Button(&#10;                                onClick = {&#10;                                    val nextLevelIntent = when (level) {&#10;                                        1 -&gt; Intent(context, Level2Activity::class.java)&#10;                                        2 -&gt; Intent(context, Level3Activity::class.java)&#10;                                        3 -&gt; Intent(context, Level4Activity::class.java)&#10;                                        4 -&gt; Intent(context, Level5Activity::class.java)&#10;                                        else -&gt; null&#10;                                    }&#10;                                    nextLevelIntent?.let {&#10;                                        it.flags = Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_NEW_TASK&#10;                                        context.startActivity(it)&#10;                                        onNextLevel()&#10;                                    }&#10;                                },&#10;                                modifier = Modifier.width(200.dp)&#10;                            ) {&#10;                                Text(&quot;Level tiếp theo&quot;, fontSize = 20.sp)&#10;                            }&#10;                        }&#10;&#10;                        // Replay button&#10;                        Button(&#10;                            onClick = onReplay,&#10;                            modifier = Modifier.width(200.dp)&#10;                        ) {&#10;                            Text(&quot;Chơi lại&quot;, fontSize = 20.sp)&#10;                        }&#10;&#10;                        // Top 6 button&#10;                        Button(&#10;                            onClick = {&#10;                                val intent = Intent(context, Top6Activity::class.java)&#10;                                context.startActivity(intent)&#10;                            },&#10;                            modifier = Modifier.width(200.dp)&#10;                        ) {&#10;                            Text(&quot;Top 6&quot;, fontSize = 20.sp)&#10;                        }&#10;&#10;                        // Exit button&#10;                        Button(&#10;                            onClick = onExit,&#10;                            modifier = Modifier.width(200.dp)&#10;                        ) {&#10;                            Text(&quot;Thoát&quot;, fontSize = 20.sp)&#10;                        }&#10;                    }&#10;                } else {&#10;                    // GAME OVER buttons&#10;                    Column(&#10;                        horizontalAlignment = Alignment.CenterHorizontally,&#10;                        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                    ) {&#10;                        // Replay button&#10;                        Button(&#10;                            onClick = onReplay,&#10;                            modifier = Modifier.width(200.dp)&#10;                        ) {&#10;                            Text(&quot;Chơi lại&quot;, fontSize = 20.sp)&#10;                        }&#10;&#10;                        // Exit button&#10;                        Button(&#10;                            onClick = onExit,&#10;                            modifier = Modifier.width(200.dp)&#10;                        ) {&#10;                            Text(&quot;Thoát&quot;, fontSize = 20.sp)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>
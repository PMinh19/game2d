<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/game/Level2Activity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/game/Level2Activity.kt" />
              <option name="originalContent" value="package com.example.game&#10;&#10;import android.os.Bundle&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.TopBarComponent.TopBarUI&#10;import com.example.game.core.*&#10;import com.example.game.ui.PlaneUI&#10;import com.example.game.ui.MonsterUI&#10;import com.example.game.ui.WallUI&#10;import com.example.game.ui.SoundControlButton&#10;import com.example.game.ui.BagCoinAnimatedView&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.*&#10;import kotlin.random.Random&#10;&#10;class Level2Activity : BaseGameActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        initAudio()&#10;&#10;        // Initialize AI Avoidance Helper for smart bullet dodging&#10;        try {&#10;            AIAvoidanceHelper.init(this)&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;Level2Activity&quot;, &quot;AI init failed: ${e.message}&quot;, e)&#10;            // Continue without AI - game will still work with basic logic&#10;        }&#10;&#10;        setContent {&#10;            val density = LocalDensity.current&#10;            val screenWidthPx = with(density) { LocalConfiguration.current.screenWidthDp.dp.toPx() }&#10;            val screenHeightPx = with(density) { LocalConfiguration.current.screenHeightDp.dp.toPx() }&#10;&#10;            Level2Game(&#10;                screenWidthPx = screenWidthPx,&#10;                screenHeightPx = screenHeightPx,&#10;                soundPool = soundPool,&#10;                shootSoundId = shootSoundId,&#10;                hitSoundId = hitSoundId,&#10;                onExit = { finish() }&#10;            )&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        try {&#10;            AIAvoidanceHelper.release()&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;Level2Activity&quot;, &quot;AI release failed: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Level2Game(&#10;    screenWidthPx: Float,&#10;    screenHeightPx: Float,&#10;    soundPool: android.media.SoundPool,&#10;    shootSoundId: Int,&#10;    hitSoundId: Int,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val playerName = PrefManager.getPlayerName(context)&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // --- State ---&#10;    var totalScore by remember { mutableStateOf(0) }&#10;    var currentSessionScore by remember { mutableStateOf(0) }&#10;    var planeHp by remember { mutableStateOf(100) }&#10;&#10;    var shieldActive by remember { mutableStateOf(false) }&#10;    var wallActive by remember { mutableStateOf(false) }&#10;    var timeActive by remember { mutableStateOf(false) }&#10;&#10;    var isGameOver by remember { mutableStateOf(false) }&#10;    var isLevelClear by remember { mutableStateOf(false) }&#10;    var showGameEndDialog by remember { mutableStateOf(false) }&#10;&#10;    // Show dialog when game ends instead of navigating to new activity&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        if (isGameOver || isLevelClear) {&#10;            delay(500)&#10;            showGameEndDialog = true&#10;        }&#10;    }&#10;&#10;    // --- Plane setup ---&#10;    var planeX by remember { mutableStateOf(screenWidthPx / 2 - 50f) }&#10;    val planeY = screenHeightPx - 250f&#10;    val planeWidth = 100f&#10;    val planeHeight = 100f&#10;&#10;    // --- Background ---&#10;    var bg1Y by remember { mutableStateOf(0f) }&#10;    var bg2Y by remember { mutableStateOf(-screenHeightPx) }&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bg1Y += 4f&#10;            bg2Y += 4f&#10;            if (bg1Y &gt;= screenHeightPx) bg1Y = bg2Y - screenHeightPx&#10;            if (bg2Y &gt;= screenHeightPx) bg2Y = bg1Y - screenHeightPx&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Entities: 5 rotating monster groups ---&#10;    val monsterGroups = remember {&#10;        List(5) { i -&gt;&#10;            RotatingMonsterGroup(&#10;                centerX = Random.nextFloat() * (screenWidthPx - 300f) + 150f, // Random X position&#10;                centerY = -300f, // Start just above screen&#10;                radius = 100f,&#10;                angleOffset = Random.nextFloat() * 360f, // Random starting angle&#10;                vx = if (Random.nextBoolean()) Random.nextFloat() * 2f + 2f else -(Random.nextFloat() * 2f + 2f),&#10;                vy = Random.nextFloat() * 2f + 3f // Random vertical speed (3-5f)&#10;            ).apply {&#10;                // Initially set monsters as dead - they will spawn with delay&#10;                monsters.forEach { it.alive.value = false }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Track respawn times for each group&#10;    val groupRespawnTimes = remember { MutableList(monsterGroups.size) { i -&gt; System.currentTimeMillis() + (i * 3000L) } }&#10;&#10;    val coins = remember {&#10;        List(7) {&#10;            BaseCoin(&#10;                x = Random.nextFloat() * (screenWidthPx - 50f),&#10;                y = mutableStateOf(-Random.nextInt(100, 800).toFloat()),&#10;                speed = Random.nextFloat() * 2f + 1.5f&#10;            )&#10;        }&#10;    }&#10;&#10;    val bullets = remember { mutableStateListOf&lt;Bullet&gt;() }&#10;    val bagCoins = remember { mutableStateListOf&lt;BagCoinDisplay&gt;() }&#10;    var chestItems by remember { mutableStateOf&lt;List&lt;ChestItem&gt;&gt;(emptyList()) }&#10;&#10;    // --- Load player data ---&#10;    LaunchedEffect(Unit) {&#10;        if (!playerName.isNullOrBlank()) {&#10;            FirebaseHelper.syncNewPlayer(playerName)&#10;            FirebaseHelper.getScore(playerName) { totalScore = it }&#10;            FirebaseHelper.getChestItems(playerName) { chestItems = it }&#10;        }&#10;    }&#10;&#10;    // --- Shooting ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.add(Bullet(planeX + planeWidth / 2 - 15f, planeY))&#10;            SoundManager.playSoundEffect(soundPool, shootSoundId, 0.5f)&#10;            delay(300)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.forEach { it.y -= 25f }&#10;            bullets.removeAll { it.y &lt; -50f }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Monster groups movement + rotation ---&#10;    monsterGroups.forEachIndexed { index, group -&gt;&#10;        LaunchedEffect(group, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                // Check if group needs to respawn&#10;                val allDead = group.monsters.all { !it.alive.value }&#10;                if (allDead &amp;&amp; System.currentTimeMillis() &gt;= groupRespawnTimes[index]) {&#10;                    // Respawn group at random position&#10;                    group.centerX = Random.nextFloat() * (screenWidthPx - 300f) + 150f&#10;                    group.centerY = -300f&#10;                    group.vx = if (Random.nextBoolean()) Random.nextFloat() * 2f + 2f else -(Random.nextFloat() * 2f + 2f)&#10;                    group.vy = Random.nextFloat() * 2f + 3f&#10;                    group.angleOffset = Random.nextFloat() * 360f // Random rotation angle&#10;                    group.monsters.forEach { m -&gt;&#10;                        m.hp.value = 100&#10;                        m.alive.value = true&#10;                    }&#10;                    // Update positions to match new center and angle&#10;                    group.updatePositions()&#10;                    // Set next respawn time with random delay (3-5 seconds)&#10;                    groupRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 5000)&#10;                }&#10;&#10;                if (!timeActive &amp;&amp; !allDead) {&#10;                    // Rotate monsters&#10;                    group.angleOffset += 3f&#10;&#10;                    // Move center&#10;                    group.centerX += group.vx&#10;                    group.centerY += group.vy&#10;&#10;                    // Bounce off LEFT wall - reverse to RIGHT&#10;                    if (group.centerX &lt;= 150f) {&#10;                        group.centerX = 150f&#10;                        group.vx = abs(group.vx) // Bounce to opposite direction (right)&#10;                    }&#10;&#10;                    // Bounce off RIGHT wall - reverse to LEFT&#10;                    if (group.centerX &gt;= screenWidthPx - 150f) {&#10;                        group.centerX = screenWidthPx - 150f&#10;                        group.vx = -abs(group.vx) // Bounce to opposite direction (left)&#10;                    }&#10;&#10;                    // Bounce off TOP - reverse to DOWN&#10;                    if (group.centerY &lt;= 150f) {&#10;                        group.centerY = 150f&#10;                        group.vy = abs(group.vy) // Bounce to opposite direction (down)&#10;                    }&#10;&#10;                    // Bounce off BOTTOM - reverse to UP&#10;                    if (group.centerY &gt;= screenHeightPx - 300f) {&#10;                        group.centerY = screenHeightPx - 300f&#10;                        group.vy = -abs(group.vy) // Bounce to opposite direction (up)&#10;                    }&#10;&#10;                    // Update monster positions&#10;                    group.updatePositions()&#10;&#10;                    // Respawn if group goes way off screen (safety check)&#10;                    if (group.centerY &gt; screenHeightPx + 500f || group.centerY &lt; -1000f) {&#10;                        groupRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(2000, 5000)&#10;                        group.monsters.forEach { it.alive.value = false }&#10;                    }&#10;                }&#10;                delay(16)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Coin movement ---&#10;    coins.forEach { c -&gt;&#10;        LaunchedEffect(c, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                if (!c.collected.value &amp;&amp; !timeActive) {&#10;                    c.y.value += c.speed&#10;                    if (c.y.value &gt; screenHeightPx) {&#10;                        c.y.value = -Random.nextInt(100, 800).toFloat()&#10;                        c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                    }&#10;                }&#10;                delay(32)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Bullet vs Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            val iter = bullets.iterator()&#10;            while (iter.hasNext()) {&#10;                val b = iter.next()&#10;                monsterGroups.forEach { group -&gt;&#10;                    group.monsters.forEach { m -&gt;&#10;                        if (CollisionUtils.checkCollisionBulletMonster(b, m)) {&#10;                            m.hp.value -= 25&#10;                            // Play hit sound&#10;                            SoundManager.playSoundEffect(soundPool, hitSoundId, 0.3f)&#10;                            iter.remove()&#10;                            if (m.hp.value &lt;= 0) {&#10;                                m.alive.value = false&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Coin collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            coins.forEach { c -&gt;&#10;                if (!c.collected.value &amp;&amp; CollisionUtils.checkCollisionPlaneCoin(planeX, planeY, planeWidth, planeHeight, c)) {&#10;                    c.collected.value = true&#10;                    totalScore += 1&#10;                    currentSessionScore += 1&#10;                    val bag = BagCoinDisplay(c.x, c.y.value, 1)&#10;                    bagCoins.add(bag)&#10;                    if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            monsterGroups.forEach { group -&gt;&#10;                group.monsters.forEach { m -&gt;&#10;                    if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp;&#10;                        CollisionUtils.checkCollisionPlaneMonster(planeX, planeY, planeWidth, planeHeight, m)&#10;                    ) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) planeHp -= 50&#10;                        m.hp.value = 0&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;            }&#10;            if (planeHp &lt;= 0) isGameOver = true&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Wall - Monster collision ---&#10;    LaunchedEffect(wallActive, isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            if (wallActive) {&#10;                monsterGroups.forEach { group -&gt;&#10;                    group.monsters.forEach { m -&gt;&#10;                        if (m.alive.value &amp;&amp; m.hp.value &gt; 0) {&#10;                            if (CollisionUtils.checkCollisionWallMonster(planeY, m)) {&#10;                                m.hp.value -= 2&#10;                                if (m.hp.value &lt;= 0) {&#10;                                    m.alive.value = false&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Use chest item ---&#10;    fun useChestItem(item: ChestItem) {&#10;        // Flatten all monsters from groups for ChestItemEffectsBase&#10;        val allMonsters = monsterGroups.flatMap { it.monsters }&#10;        ChestItemEffectsBase.applyItemEffect(&#10;            itemName = item.name,&#10;            monsters = allMonsters,&#10;            coins = coins,&#10;            bagCoins = bagCoins,&#10;            coroutineScope = coroutineScope,&#10;            screenHeightPx = screenHeightPx,&#10;            planeX = planeX,&#10;            onScoreUpdate = { add -&gt;&#10;                totalScore += add&#10;                currentSessionScore += add&#10;                if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;            },&#10;            onShieldToggle = { active -&gt; shieldActive = active },&#10;            onWallToggle = { active -&gt; wallActive = active },&#10;            onTimeToggle = { active -&gt; timeActive = active },&#10;            onLevelClear = { isLevelClear = true }&#10;        )&#10;        chestItems = chestItems - item&#10;        if (!playerName.isNullOrBlank()) FirebaseHelper.updateChest(playerName, chestItems)&#10;    }&#10;&#10;    // --- Drag plane ---&#10;    val dragModifier = Modifier.pointerInput(Unit) {&#10;        detectDragGestures { change, dragAmount -&gt;&#10;            planeX = (planeX + dragAmount.x).coerceIn(0f, screenWidthPx - planeWidth)&#10;            change.consume()&#10;        }&#10;    }&#10;&#10;    // --- UI ---&#10;    Box(modifier = Modifier.fillMaxSize().then(dragModifier)) {&#10;        // Background&#10;        Image(&#10;            painter = painterResource(R.drawable.nen2),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg1Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;        Image(&#10;            painter = painterResource(R.drawable.nen2),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg2Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;&#10;        // Monsters (using MonsterUI component)&#10;        monsterGroups.forEach { group -&gt;&#10;            group.monsters.forEach { m -&gt;&#10;                MonsterUI(monster = m)&#10;            }&#10;        }&#10;&#10;        // Coins&#10;        coins.filter { !it.collected.value }.forEach { c -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.coin),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(c.x.roundToInt(), c.y.value.roundToInt()) }&#10;                    .size(40.dp)&#10;            )&#10;        }&#10;&#10;        // BagCoin animated views&#10;        bagCoins.toList().forEach { bag -&gt;&#10;            BagCoinAnimatedView(bag = bag, onFinished = { finishedBag -&gt;&#10;                bagCoins.remove(finishedBag)&#10;            })&#10;        }&#10;&#10;        // Bullets&#10;        bullets.forEach { b -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.dan2),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(b.x.roundToInt(), b.y.roundToInt()) }&#10;                    .size(30.dp)&#10;            )&#10;        }&#10;&#10;        // Plane (using PlaneUI component)&#10;        PlaneUI(&#10;            planeX = planeX,&#10;            planeY = planeY,&#10;            planeHp = planeHp,&#10;            shieldActive = shieldActive&#10;        )&#10;&#10;        // Wall (using WallUI component)&#10;        if (wallActive) {&#10;            WallUI(planeY = planeY)&#10;        }&#10;&#10;        // Top bar&#10;        TopBarUI(&#10;            bagCoinScore = totalScore,&#10;            chestItems = chestItems,&#10;            onBuyItem = { item, price -&gt;&#10;                if (totalScore &gt;= price) {&#10;                    totalScore -= price&#10;                    chestItems = chestItems + item&#10;                    if (!playerName.isNullOrBlank()) {&#10;                        FirebaseHelper.updateScore(playerName, totalScore)&#10;                        FirebaseHelper.updateChest(playerName, chestItems)&#10;                    }&#10;                }&#10;            },&#10;            onUseChestItem = { useChestItem(it) }&#10;        )&#10;&#10;        // --- Sound Control Button (top-right corner) ---&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp),&#10;            contentAlignment = Alignment.TopEnd&#10;        ) {&#10;            SoundControlButton()&#10;        }&#10;    }&#10;&#10;    // --- Game End Dialog ---&#10;    if (showGameEndDialog) {&#10;        GameEndDialog(&#10;            isWin = isLevelClear,&#10;            score = currentSessionScore,&#10;            level = 2,&#10;            onDismiss = {&#10;                showGameEndDialog = false&#10;            },&#10;            onReplay = {&#10;                // Reset game state to replay&#10;                showGameEndDialog = false&#10;                isGameOver = false&#10;                isLevelClear = false&#10;                planeHp = 100&#10;                currentSessionScore = 0&#10;&#10;                // Reset monsters&#10;                monsterGroups.forEach { group -&gt;&#10;                    group.centerX = Random.nextFloat() * (screenWidthPx - 300f) + 150f&#10;                    group.centerY = -300f&#10;                    group.vx = if (Random.nextBoolean()) Random.nextFloat() * 2f + 2f else -(Random.nextFloat() * 2f + 2f)&#10;                    group.vy = Random.nextFloat() * 2f + 3f&#10;                    group.angleOffset = Random.nextFloat() * 360f&#10;                    group.monsters.forEach { m -&gt;&#10;                        m.hp.value = 100&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;&#10;                // Reset respawn times&#10;                for (i in groupRespawnTimes.indices) {&#10;                    groupRespawnTimes[i] = System.currentTimeMillis() + (i * 3000L)&#10;                }&#10;&#10;                // Reset coins&#10;                coins.forEach { c -&gt;&#10;                    c.collected.value = false&#10;                    c.y.value = -Random.nextInt(100, 800).toFloat()&#10;                    c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                }&#10;&#10;                // Clear bullets&#10;                bullets.clear()&#10;            },&#10;            onNextLevel = {&#10;                // Navigate to next level handled by GameEndDialog itself&#10;                onExit() // Close this activity&#10;            },&#10;            onExit = {&#10;                // Back to main menu&#10;                onExit()&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * Rotating Monster Group - 3 monsters rotating around a center point&#10; */&#10;class RotatingMonsterGroup(&#10;    var centerX: Float,&#10;    var centerY: Float,&#10;    var radius: Float,&#10;    var angleOffset: Float,&#10;    var vx: Float, // velocity X&#10;    var vy: Float  // velocity Y&#10;) {&#10;    val monsters = List(3) { i -&gt;&#10;        val angle = angleOffset + i * 120f&#10;        val rad = Math.toRadians(angle.toDouble())&#10;        BaseMonster(&#10;            x = (centerX + cos(rad) * radius).toFloat(),&#10;            y = mutableStateOf((centerY + sin(rad) * radius).toFloat()),&#10;            speed = 0f,&#10;            hp = mutableStateOf(100)&#10;        )&#10;    }&#10;&#10;    fun updatePositions() {&#10;        val angles = listOf(0f, 120f, 240f)&#10;        monsters.forEachIndexed { i, m -&gt;&#10;            if (m.alive.value) {&#10;                val rad = Math.toRadians((angleOffset + angles[i]).toDouble())&#10;                m.x = (centerX + cos(rad) * radius).toFloat()&#10;                m.y.value = (centerY + sin(rad) * radius).toFloat()&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.game&#10;&#10;import android.os.Bundle&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.TopBarComponent.TopBarUI&#10;import com.example.game.core.*&#10;import com.example.game.ui.PlaneUI&#10;import com.example.game.ui.MonsterUI&#10;import com.example.game.ui.WallUI&#10;import com.example.game.ui.SoundControlButton&#10;import com.example.game.ui.BagCoinAnimatedView&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.*&#10;import kotlin.random.Random&#10;&#10;class Level2Activity : BaseGameActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        initAudio()&#10;&#10;        // Initialize AI Avoidance Helper for smart bullet dodging&#10;        try {&#10;            AIAvoidanceHelper.init(this)&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;Level2Activity&quot;, &quot;AI init failed: ${e.message}&quot;, e)&#10;            // Continue without AI - game will still work with basic logic&#10;        }&#10;&#10;        setContent {&#10;            val density = LocalDensity.current&#10;            val screenWidthPx = with(density) { LocalConfiguration.current.screenWidthDp.dp.toPx() }&#10;            val screenHeightPx = with(density) { LocalConfiguration.current.screenHeightDp.dp.toPx() }&#10;&#10;            Level2Game(&#10;                screenWidthPx = screenWidthPx,&#10;                screenHeightPx = screenHeightPx,&#10;                soundPool = soundPool,&#10;                shootSoundId = shootSoundId,&#10;                hitSoundId = hitSoundId,&#10;                onExit = { finish() }&#10;            )&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        try {&#10;            AIAvoidanceHelper.release()&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;Level2Activity&quot;, &quot;AI release failed: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Level2Game(&#10;    screenWidthPx: Float,&#10;    screenHeightPx: Float,&#10;    soundPool: android.media.SoundPool,&#10;    shootSoundId: Int,&#10;    hitSoundId: Int,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val playerName = PrefManager.getPlayerName(context)&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // --- State ---&#10;    var totalScore by remember { mutableStateOf(0) }&#10;    var currentSessionScore by remember { mutableStateOf(0) }&#10;    var planeHp by remember { mutableStateOf(100) }&#10;&#10;    var shieldActive by remember { mutableStateOf(false) }&#10;    var wallActive by remember { mutableStateOf(false) }&#10;    var timeActive by remember { mutableStateOf(false) }&#10;&#10;    var isGameOver by remember { mutableStateOf(false) }&#10;    var isLevelClear by remember { mutableStateOf(false) }&#10;    var showGameEndDialog by remember { mutableStateOf(false) }&#10;&#10;    // Show dialog when game ends instead of navigating to new activity&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        if (isGameOver || isLevelClear) {&#10;            delay(500)&#10;            showGameEndDialog = true&#10;        }&#10;    }&#10;&#10;    // --- Plane setup ---&#10;    var planeX by remember { mutableStateOf(screenWidthPx / 2 - 50f) }&#10;    val planeY = screenHeightPx - 250f&#10;    val planeWidth = 100f&#10;    val planeHeight = 100f&#10;&#10;    // --- Background ---&#10;    var bg1Y by remember { mutableStateOf(0f) }&#10;    var bg2Y by remember { mutableStateOf(-screenHeightPx) }&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bg1Y += 4f&#10;            bg2Y += 4f&#10;            if (bg1Y &gt;= screenHeightPx) bg1Y = bg2Y - screenHeightPx&#10;            if (bg2Y &gt;= screenHeightPx) bg2Y = bg1Y - screenHeightPx&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Entities: 5 rotating monster groups ---&#10;    val monsterGroups = remember {&#10;        List(5) { i -&gt;&#10;            RotatingMonsterGroup(&#10;                centerX = Random.nextFloat() * (screenWidthPx - 300f) + 150f, // Random X position&#10;                centerY = -300f, // Start just above screen&#10;                radius = 100f,&#10;                angleOffset = Random.nextFloat() * 360f, // Random starting angle&#10;                vx = if (Random.nextBoolean()) Random.nextFloat() * 2f + 2f else -(Random.nextFloat() * 2f + 2f),&#10;                vy = Random.nextFloat() * 2f + 3f // Random vertical speed (3-5f)&#10;            ).apply {&#10;                // Initially set monsters as dead - they will spawn with delay&#10;                monsters.forEach { it.alive.value = false }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Track respawn times for each group&#10;    val groupRespawnTimes = remember { MutableList(monsterGroups.size) { i -&gt; System.currentTimeMillis() + (i * 3000L) } }&#10;&#10;    val coins = remember {&#10;        List(7) {&#10;            BaseCoin(&#10;                x = Random.nextFloat() * (screenWidthPx - 50f),&#10;                y = mutableStateOf(-Random.nextInt(100, 800).toFloat()),&#10;                speed = Random.nextFloat() * 2f + 1.5f&#10;            )&#10;        }&#10;    }&#10;&#10;    val bullets = remember { mutableStateListOf&lt;Bullet&gt;() }&#10;    val bagCoins = remember { mutableStateListOf&lt;BagCoinDisplay&gt;() }&#10;    var chestItems by remember { mutableStateOf&lt;List&lt;ChestItem&gt;&gt;(emptyList()) }&#10;&#10;    // --- Load player data ---&#10;    LaunchedEffect(Unit) {&#10;        if (!playerName.isNullOrBlank()) {&#10;            FirebaseHelper.syncNewPlayer(playerName)&#10;            FirebaseHelper.getScore(playerName) { totalScore = it }&#10;            FirebaseHelper.getChestItems(playerName) { chestItems = it }&#10;        }&#10;    }&#10;&#10;    // --- Shooting ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.add(Bullet(planeX + planeWidth / 2 - 15f, planeY))&#10;            SoundManager.playSoundEffect(soundPool, shootSoundId, 0.5f)&#10;            delay(300)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.forEach { it.y -= 25f }&#10;            bullets.removeAll { it.y &lt; -50f }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Monster groups movement + rotation ---&#10;    monsterGroups.forEachIndexed { index, group -&gt;&#10;        LaunchedEffect(group, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                // Check if group needs to respawn&#10;                val allDead = group.monsters.all { !it.alive.value }&#10;                if (allDead &amp;&amp; System.currentTimeMillis() &gt;= groupRespawnTimes[index]) {&#10;                    // Respawn group at random position&#10;                    group.centerX = Random.nextFloat() * (screenWidthPx - 300f) + 150f&#10;                    group.centerY = -300f&#10;                    group.vx = if (Random.nextBoolean()) Random.nextFloat() * 2f + 2f else -(Random.nextFloat() * 2f + 2f)&#10;                    group.vy = Random.nextFloat() * 2f + 3f&#10;                    group.angleOffset = Random.nextFloat() * 360f // Random rotation angle&#10;                    group.monsters.forEach { m -&gt;&#10;                        m.hp.value = 100&#10;                        m.alive.value = true&#10;                    }&#10;                    // Update positions to match new center and angle&#10;                    group.updatePositions()&#10;                    // Set next respawn time with random delay (3-5 seconds)&#10;                    groupRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 5000)&#10;                }&#10;&#10;                if (!timeActive &amp;&amp; !allDead) {&#10;                    // Rotate monsters&#10;                    group.angleOffset += 3f&#10;&#10;                    // Move center&#10;                    group.centerX += group.vx&#10;                    group.centerY += group.vy&#10;&#10;                    // Bounce off LEFT wall - reverse to RIGHT&#10;                    if (group.centerX &lt;= 150f) {&#10;                        group.centerX = 150f&#10;                        group.vx = abs(group.vx) // Bounce to opposite direction (right)&#10;                    }&#10;&#10;                    // Bounce off RIGHT wall - reverse to LEFT&#10;                    if (group.centerX &gt;= screenWidthPx - 150f) {&#10;                        group.centerX = screenWidthPx - 150f&#10;                        group.vx = -abs(group.vx) // Bounce to opposite direction (left)&#10;                    }&#10;&#10;                    // Bounce off TOP - reverse to DOWN&#10;                    if (group.centerY &lt;= 150f) {&#10;                        group.centerY = 150f&#10;                        group.vy = abs(group.vy) // Bounce to opposite direction (down)&#10;                    }&#10;&#10;                    // Bounce off BOTTOM - reverse to UP&#10;                    if (group.centerY &gt;= screenHeightPx - 300f) {&#10;                        group.centerY = screenHeightPx - 300f&#10;                        group.vy = -abs(group.vy) // Bounce to opposite direction (up)&#10;                    }&#10;&#10;                    // Update monster positions&#10;                    group.updatePositions()&#10;&#10;                    // Respawn if group goes way off screen (safety check)&#10;                    if (group.centerY &gt; screenHeightPx + 500f || group.centerY &lt; -1000f) {&#10;                        groupRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(2000, 5000)&#10;                        group.monsters.forEach { it.alive.value = false }&#10;                    }&#10;                }&#10;                delay(16)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Coin movement ---&#10;    coins.forEach { c -&gt;&#10;        LaunchedEffect(c, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                if (!c.collected.value &amp;&amp; !timeActive) {&#10;                    c.y.value += c.speed&#10;                    if (c.y.value &gt; screenHeightPx) {&#10;                        c.y.value = -Random.nextInt(100, 800).toFloat()&#10;                        c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                    }&#10;                }&#10;                delay(32)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Bullet vs Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            val toRemove = mutableSetOf&lt;Bullet&gt;()&#10;            bullets.toList().forEach { b -&gt;&#10;                var shouldRemove = false&#10;                monsterGroups.forEach { group -&gt;&#10;                    group.monsters.forEach { m -&gt;&#10;                        if (m.alive.value &amp;&amp; CollisionUtils.checkCollisionBulletMonster(b, m)) {&#10;                            m.hp.value -= 25&#10;                            // Play hit sound&#10;                            SoundManager.playSoundEffect(soundPool, hitSoundId, 0.3f)&#10;                            shouldRemove = true&#10;                            if (m.hp.value &lt;= 0) {&#10;                                m.alive.value = false&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;                if (shouldRemove) {&#10;                    toRemove.add(b)&#10;                }&#10;            }&#10;            bullets.removeAll(toRemove)&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Coin collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            coins.forEach { c -&gt;&#10;                if (!c.collected.value &amp;&amp; CollisionUtils.checkCollisionPlaneCoin(planeX, planeY, planeWidth, planeHeight, c)) {&#10;                    c.collected.value = true&#10;                    totalScore += 1&#10;                    currentSessionScore += 1&#10;                    val bag = BagCoinDisplay(c.x, c.y.value, 1)&#10;                    bagCoins.add(bag)&#10;                    if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            monsterGroups.forEach { group -&gt;&#10;                group.monsters.forEach { m -&gt;&#10;                    if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp;&#10;                        CollisionUtils.checkCollisionPlaneMonster(planeX, planeY, planeWidth, planeHeight, m)&#10;                    ) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) planeHp -= 50&#10;                        m.hp.value = 0&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;            }&#10;            if (planeHp &lt;= 0) isGameOver = true&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Wall - Monster collision ---&#10;    LaunchedEffect(wallActive, isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            if (wallActive) {&#10;                monsterGroups.forEach { group -&gt;&#10;                    group.monsters.forEach { m -&gt;&#10;                        if (m.alive.value &amp;&amp; m.hp.value &gt; 0) {&#10;                            if (CollisionUtils.checkCollisionWallMonster(planeY, m)) {&#10;                                m.hp.value -= 2&#10;                                if (m.hp.value &lt;= 0) {&#10;                                    m.alive.value = false&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Use chest item ---&#10;    fun useChestItem(item: ChestItem) {&#10;        // Flatten all monsters from groups for ChestItemEffectsBase&#10;        val allMonsters = monsterGroups.flatMap { it.monsters }&#10;        ChestItemEffectsBase.applyItemEffect(&#10;            itemName = item.name,&#10;            monsters = allMonsters,&#10;            coins = coins,&#10;            bagCoins = bagCoins,&#10;            coroutineScope = coroutineScope,&#10;            screenHeightPx = screenHeightPx,&#10;            planeX = planeX,&#10;            onScoreUpdate = { add -&gt;&#10;                totalScore += add&#10;                currentSessionScore += add&#10;                if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;            },&#10;            onShieldToggle = { active -&gt; shieldActive = active },&#10;            onWallToggle = { active -&gt; wallActive = active },&#10;            onTimeToggle = { active -&gt; timeActive = active },&#10;            onLevelClear = { isLevelClear = true }&#10;        )&#10;        chestItems = chestItems - item&#10;        if (!playerName.isNullOrBlank()) FirebaseHelper.updateChest(playerName, chestItems)&#10;    }&#10;&#10;    // --- Drag plane ---&#10;    val dragModifier = Modifier.pointerInput(Unit) {&#10;        detectDragGestures { change, dragAmount -&gt;&#10;            planeX = (planeX + dragAmount.x).coerceIn(0f, screenWidthPx - planeWidth)&#10;            change.consume()&#10;        }&#10;    }&#10;&#10;    // --- UI ---&#10;    Box(modifier = Modifier.fillMaxSize().then(dragModifier)) {&#10;        // Background&#10;        Image(&#10;            painter = painterResource(R.drawable.nen2),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg1Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;        Image(&#10;            painter = painterResource(R.drawable.nen2),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg2Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;&#10;        // Monsters (using MonsterUI component)&#10;        monsterGroups.forEach { group -&gt;&#10;            group.monsters.forEach { m -&gt;&#10;                MonsterUI(monster = m, level = 2)&#10;            }&#10;        }&#10;&#10;        // Coins&#10;        coins.filter { !it.collected.value }.forEach { c -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.coin),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(c.x.roundToInt(), c.y.value.roundToInt()) }&#10;                    .size(40.dp)&#10;            )&#10;        }&#10;&#10;        // BagCoin animated views&#10;        bagCoins.toList().forEach { bag -&gt;&#10;            BagCoinAnimatedView(bag = bag, onFinished = { finishedBag -&gt;&#10;                bagCoins.remove(finishedBag)&#10;            })&#10;        }&#10;&#10;        // Bullets&#10;        bullets.forEach { b -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.dan2),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(b.x.roundToInt(), b.y.roundToInt()) }&#10;                    .size(30.dp)&#10;            )&#10;        }&#10;&#10;        // Plane (using PlaneUI component)&#10;        PlaneUI(&#10;            planeX = planeX,&#10;            planeY = planeY,&#10;            planeHp = planeHp,&#10;            shieldActive = shieldActive,&#10;            level = 2&#10;        )&#10;&#10;        // Wall (using WallUI component)&#10;        if (wallActive) {&#10;            WallUI(planeY = planeY)&#10;        }&#10;&#10;        // Top bar&#10;        TopBarUI(&#10;            bagCoinScore = totalScore,&#10;            chestItems = chestItems,&#10;            onBuyItem = { item, price -&gt;&#10;                if (totalScore &gt;= price) {&#10;                    totalScore -= price&#10;                    chestItems = chestItems + item&#10;                    if (!playerName.isNullOrBlank()) {&#10;                        FirebaseHelper.updateScore(playerName, totalScore)&#10;                        FirebaseHelper.updateChest(playerName, chestItems)&#10;                    }&#10;                }&#10;            },&#10;            onUseChestItem = { useChestItem(it) }&#10;        )&#10;&#10;        // --- Sound Control Button (top-right corner) ---&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp),&#10;            contentAlignment = Alignment.TopEnd&#10;        ) {&#10;            SoundControlButton()&#10;        }&#10;    }&#10;&#10;    // --- Game End Dialog ---&#10;    if (showGameEndDialog) {&#10;        GameEndDialog(&#10;            isWin = isLevelClear,&#10;            score = currentSessionScore,&#10;            level = 2,&#10;            onDismiss = {&#10;                showGameEndDialog = false&#10;            },&#10;            onReplay = {&#10;                // Reset game state to replay&#10;                showGameEndDialog = false&#10;                isGameOver = false&#10;                isLevelClear = false&#10;                planeHp = 100&#10;                currentSessionScore = 0&#10;&#10;                // Reset monsters&#10;                monsterGroups.forEach { group -&gt;&#10;                    group.centerX = Random.nextFloat() * (screenWidthPx - 300f) + 150f&#10;                    group.centerY = -300f&#10;                    group.vx = if (Random.nextBoolean()) Random.nextFloat() * 2f + 2f else -(Random.nextFloat() * 2f + 2f)&#10;                    group.vy = Random.nextFloat() * 2f + 3f&#10;                    group.angleOffset = Random.nextFloat() * 360f&#10;                    group.monsters.forEach { m -&gt;&#10;                        m.hp.value = 100&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;&#10;                // Reset respawn times&#10;                for (i in groupRespawnTimes.indices) {&#10;                    groupRespawnTimes[i] = System.currentTimeMillis() + (i * 3000L)&#10;                }&#10;&#10;                // Reset coins&#10;                coins.forEach { c -&gt;&#10;                    c.collected.value = false&#10;                    c.y.value = -Random.nextInt(100, 800).toFloat()&#10;                    c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                }&#10;&#10;                // Clear bullets&#10;                bullets.clear()&#10;            },&#10;            onNextLevel = {&#10;                // Navigate to next level handled by GameEndDialog itself&#10;                onExit() // Close this activity&#10;            },&#10;            onExit = {&#10;                // Back to main menu&#10;                onExit()&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * Rotating Monster Group - 3 monsters rotating around a center point&#10; */&#10;class RotatingMonsterGroup(&#10;    var centerX: Float,&#10;    var centerY: Float,&#10;    var radius: Float,&#10;    var angleOffset: Float,&#10;    var vx: Float, // velocity X&#10;    var vy: Float  // velocity Y&#10;) {&#10;    val monsters = List(3) { i -&gt;&#10;        val angle = angleOffset + i * 120f&#10;        val rad = Math.toRadians(angle.toDouble())&#10;        BaseMonster(&#10;            x = (centerX + cos(rad) * radius).toFloat(),&#10;            y = mutableStateOf((centerY + sin(rad) * radius).toFloat()),&#10;            speed = 0f,&#10;            hp = mutableStateOf(100)&#10;        )&#10;    }&#10;&#10;    fun updatePositions() {&#10;        val angles = listOf(0f, 120f, 240f)&#10;        monsters.forEachIndexed { i, m -&gt;&#10;            if (m.alive.value) {&#10;                val rad = Math.toRadians((angleOffset + angles[i]).toDouble())&#10;                m.x = (centerX + cos(rad) * radius).toFloat()&#10;                m.y.value = (centerY + sin(rad) * radius).toFloat()&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/game/Level3Activity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/game/Level3Activity.kt" />
              <option name="originalContent" value="package com.example.game&#10;&#10;import android.os.Bundle&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.TopBarComponent.TopBarUI&#10;import com.example.game.core.*&#10;import com.example.game.ui.PlaneUI&#10;import com.example.game.ui.WallUI&#10;import com.example.game.ui.InvisibleMonsterUI&#10;import com.example.game.ui.SoundControlButton&#10;import com.example.game.ui.BagCoinAnimatedView&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.roundToInt&#10;import kotlin.random.Random&#10;&#10;class Level3Activity : BaseGameActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        try {&#10;            initAudio()&#10;&#10;            // Initialize AI Avoidance Helper for smart bullet dodging&#10;            try {&#10;                AIAvoidanceHelper.init(this)&#10;            } catch (e: Exception) {&#10;                e.printStackTrace()&#10;                // Continue without AI if it fails&#10;            }&#10;&#10;            setContent {&#10;                val density = LocalDensity.current&#10;                val screenWidthPx = with(density) { LocalConfiguration.current.screenWidthDp.dp.toPx() }&#10;                val screenHeightPx = with(density) { LocalConfiguration.current.screenHeightDp.dp.toPx() }&#10;&#10;                Level3Game(&#10;                    screenWidthPx = screenWidthPx,&#10;                    screenHeightPx = screenHeightPx,&#10;                    soundPool = soundPool,&#10;                    shootSoundId = shootSoundId,&#10;                    hitSoundId = hitSoundId,&#10;                    onExit = { finish() }&#10;                )&#10;            }&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            finish() // Exit gracefully if something goes wrong&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        try {&#10;            AIAvoidanceHelper.release()&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Level3Game(&#10;    screenWidthPx: Float,&#10;    screenHeightPx: Float,&#10;    soundPool: android.media.SoundPool,&#10;    shootSoundId: Int,&#10;    hitSoundId: Int,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val playerName = PrefManager.getPlayerName(context)&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // --- State ---&#10;    var totalScore by remember { mutableStateOf(0) }&#10;    var currentSessionScore by remember { mutableStateOf(0) }&#10;    var planeHp by remember { mutableStateOf(100) }&#10;&#10;    var shieldActive by remember { mutableStateOf(false) }&#10;    var wallActive by remember { mutableStateOf(false) }&#10;    var timeActive by remember { mutableStateOf(false) }&#10;&#10;    var isGameOver by remember { mutableStateOf(false) }&#10;    var isLevelClear by remember { mutableStateOf(false) }&#10;    var showGameEndDialog by remember { mutableStateOf(false) }&#10;&#10;    // Show dialog when game ends&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        if (isGameOver || isLevelClear) {&#10;            delay(500)&#10;            showGameEndDialog = true&#10;        }&#10;    }&#10;&#10;    // --- Plane setup ---&#10;    var planeX by remember { mutableStateOf(screenWidthPx / 2 - 50f) }&#10;    val planeY = screenHeightPx - 250f&#10;    val planeWidth = 100f&#10;    val planeHeight = 100f&#10;&#10;    // --- Background ---&#10;    var bg1Y by remember { mutableStateOf(0f) }&#10;    var bg2Y by remember { mutableStateOf(-screenHeightPx) }&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bg1Y += 4f&#10;            bg2Y += 4f&#10;            if (bg1Y &gt;= screenHeightPx) bg1Y = bg2Y - screenHeightPx&#10;            if (bg2Y &gt;= screenHeightPx) bg2Y = bg1Y - screenHeightPx&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Invisible Monsters ---&#10;    val invisibleMonsters = remember {&#10;        List(12) {&#10;            InvisibleMonster(&#10;                x = Random.nextFloat() * (screenWidthPx - 100f),&#10;                y = mutableStateOf(-Random.nextInt(200, 3000).toFloat()),&#10;                speed = Random.nextFloat() * 1.5f + 1.5f,&#10;                hp = mutableStateOf(100),&#10;                invisibleDuration = 2000L, // Invisible for 2 seconds&#10;                visibleDuration = 1500L     // Visible for 1.5 seconds&#10;            )&#10;        }&#10;    }&#10;&#10;    // Track respawn times&#10;    val monsterRespawnTimes = remember { MutableList(invisibleMonsters.size) { 0L } }&#10;&#10;    val coins = remember {&#10;        List(6) {&#10;            BaseCoin(&#10;                x = Random.nextFloat() * (screenWidthPx - 50f),&#10;                y = mutableStateOf(-Random.nextInt(100, 600).toFloat()),&#10;                speed = Random.nextFloat() * 2f + 1f&#10;            )&#10;        }&#10;    }&#10;&#10;    val bullets = remember { mutableStateListOf&lt;Bullet&gt;() }&#10;    val bagCoins = remember { mutableStateListOf&lt;BagCoinDisplay&gt;() }&#10;    var chestItems by remember { mutableStateOf&lt;List&lt;ChestItem&gt;&gt;(emptyList()) }&#10;&#10;    // --- Load player data ---&#10;    LaunchedEffect(Unit) {&#10;        if (!playerName.isNullOrBlank()) {&#10;            FirebaseHelper.syncNewPlayer(playerName)&#10;            FirebaseHelper.getScore(playerName) { totalScore = it }&#10;            FirebaseHelper.getChestItems(playerName) { chestItems = it }&#10;        }&#10;    }&#10;&#10;    // --- Shooting ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.add(Bullet(planeX + planeWidth / 2f - 15f, planeY))&#10;            SoundManager.playSoundEffect(soundPool, shootSoundId, 0.5f)&#10;            delay(300)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.forEach { it.y -= 25f }&#10;            bullets.removeAll { it.y &lt; -50f }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Monster movement + invisible toggle ---&#10;    invisibleMonsters.forEachIndexed { index, m -&gt;&#10;        LaunchedEffect(m, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                // Check if monster needs to respawn&#10;                if (!m.alive.value &amp;&amp; System.currentTimeMillis() &gt;= monsterRespawnTimes[index]) {&#10;                    m.y.value = -Random.nextInt(200, 1500).toFloat()&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 100f)&#10;                    m.hp.value = 100&#10;                    m.alive.value = true&#10;                    m.lastToggleTime = System.currentTimeMillis()&#10;                    m.isVisible.value = Random.nextBoolean() // Random start state&#10;                }&#10;&#10;                if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp; !timeActive) {&#10;                    // AI-based evasion: monster tries to dodge bullets intelligently&#10;                    val evasion = AIAvoidanceHelper.calculateEvasion(&#10;                        monsterX = m.x,&#10;                        monsterY = m.y.value,&#10;                        monsterSize = 100f,&#10;                        bullets = bullets,&#10;                        screenWidth = screenWidthPx&#10;                    )&#10;&#10;                    // Apply AI evasion (combines with zigzag movement)&#10;                    val aiDodgeX = evasion.first&#10;&#10;                    // Toggle visibility&#10;                    val currentTime = System.currentTimeMillis()&#10;                    val elapsed = currentTime - m.lastToggleTime&#10;                    val threshold = if (m.isVisible.value) m.visibleDuration else m.invisibleDuration&#10;&#10;                    if (elapsed &gt;= threshold) {&#10;                        m.isVisible.value = !m.isVisible.value&#10;                        m.lastToggleTime = currentTime&#10;                    }&#10;&#10;                    // Wall collision check&#10;                    val wallTop = planeY - 60f&#10;                    val monsterBottom = m.y.value + 80f&#10;&#10;                    if (wallActive &amp;&amp; monsterBottom &gt;= wallTop) {&#10;                        // Stop at wall&#10;                    } else {&#10;                        // Normal movement&#10;                        m.y.value += m.speed&#10;                    }&#10;&#10;                    // Zigzag movement combined with AI evasion&#10;                    val combinedX = (m.horizontalSpeed * m.direction) + aiDodgeX&#10;                    m.x = (m.x + combinedX).coerceIn(0f, screenWidthPx - 100f)&#10;&#10;                    if (m.x &lt;= 0 || m.x &gt;= screenWidthPx - 100f) {&#10;                        m.direction *= -1&#10;                    }&#10;&#10;                    // If monster passes plane&#10;                    if (m.y.value &gt; planeY + planeHeight / 2f) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) planeHp -= 50&#10;                        monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 8000)&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;                delay(16)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Coin movement ---&#10;    coins.forEach { c -&gt;&#10;        LaunchedEffect(c, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                if (!c.collected.value &amp;&amp; !timeActive) {&#10;                    c.y.value += c.speed&#10;                    if (c.y.value &gt; screenHeightPx) {&#10;                        c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                        c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                    }&#10;                }&#10;                delay(32)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Bullet vs Monster collision (only when visible) ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            val iter = bullets.iterator()&#10;            while (iter.hasNext()) {&#10;                val b = iter.next()&#10;                invisibleMonsters.forEach { m -&gt;&#10;                    // Can only hit visible monsters&#10;                    if (m.isVisible.value &amp;&amp; CollisionUtils.checkCollisionBulletInvisibleMonster(b, m)) {&#10;                        m.hp.value -= 25&#10;                        // Play hit sound&#10;                        SoundManager.playSoundEffect(soundPool, hitSoundId, 0.3f)&#10;                        iter.remove()&#10;                        if (m.hp.value &lt;= 0) {&#10;                            m.alive.value = false&#10;                            val index = invisibleMonsters.indexOf(m)&#10;                            if (index &gt;= 0) {&#10;                                monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 8000)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Coin collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            coins.forEach { c -&gt;&#10;                if (!c.collected.value &amp;&amp; CollisionUtils.checkCollisionPlaneCoin(planeX, planeY, planeWidth, planeHeight, c)) {&#10;                    c.collected.value = true&#10;                    totalScore += 1&#10;                    currentSessionScore += 1&#10;                    val bag = BagCoinDisplay(c.x, c.y.value, 1)&#10;                    bagCoins.add(bag)&#10;                    if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Monster collision (only when visible) ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            invisibleMonsters.forEach { m -&gt;&#10;                if (m.isVisible.value &amp;&amp; CollisionUtils.checkCollisionPlaneInvisibleMonster(planeX, planeY, planeWidth, planeHeight, m)) {&#10;                    if (!shieldActive &amp;&amp; !wallActive) planeHp -= 50&#10;                    m.hp.value = 0&#10;                    m.alive.value = false&#10;                }&#10;            }&#10;            if (planeHp &lt;= 0) isGameOver = true&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Wall - Monster collision ---&#10;    LaunchedEffect(wallActive, isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            if (wallActive) {&#10;                invisibleMonsters.forEach { m -&gt;&#10;                    if (m.isVisible.value &amp;&amp; CollisionUtils.checkCollisionWallInvisibleMonster(planeY, m)) {&#10;                        m.hp.value -= 2&#10;                        if (m.hp.value &lt;= 0) {&#10;                            m.alive.value = false&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Use chest item ---&#10;    fun useChestItem(item: ChestItem) {&#10;        ChestItemEffectsBase.applyItemEffect(&#10;            itemName = item.name,&#10;            monsters = invisibleMonsters,&#10;            coins = coins,&#10;            bagCoins = bagCoins,&#10;            coroutineScope = coroutineScope,&#10;            screenHeightPx = screenHeightPx,&#10;            planeX = planeX,&#10;            onScoreUpdate = { add -&gt;&#10;                totalScore += add&#10;                currentSessionScore += add&#10;                if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;            },&#10;            onShieldToggle = { active -&gt; shieldActive = active },&#10;            onWallToggle = { active -&gt; wallActive = active },&#10;            onTimeToggle = { active -&gt; timeActive = active },&#10;            onLevelClear = { isLevelClear = true }&#10;        )&#10;        chestItems = chestItems - item&#10;        if (!playerName.isNullOrBlank()) FirebaseHelper.updateChest(playerName, chestItems)&#10;    }&#10;&#10;    // --- Drag plane ---&#10;    val dragModifier = Modifier.pointerInput(Unit) {&#10;        detectDragGestures { change, dragAmount -&gt;&#10;            planeX = (planeX + dragAmount.x).coerceIn(0f, screenWidthPx - planeWidth)&#10;            change.consume()&#10;        }&#10;    }&#10;&#10;    // --- UI ---&#10;    Box(modifier = Modifier.fillMaxSize().then(dragModifier)) {&#10;        // Background&#10;        Image(&#10;            painter = painterResource(R.drawable.vutru1),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg1Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;        Image(&#10;            painter = painterResource(R.drawable.vutru1),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg2Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;&#10;        // Invisible Monsters (only show when visible)&#10;        invisibleMonsters.forEach { m -&gt;&#10;            if (m.isVisible.value) {&#10;                InvisibleMonsterUI(monster = m)&#10;            }&#10;        }&#10;&#10;        // Coins&#10;        coins.filter { !it.collected.value }.forEach { c -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.coin),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(c.x.roundToInt(), c.y.value.roundToInt()) }&#10;                    .size(40.dp)&#10;            )&#10;        }&#10;&#10;        // BagCoin animated views&#10;        bagCoins.toList().forEach { bag -&gt;&#10;            BagCoinAnimatedView(bag = bag, onFinished = { finishedBag -&gt;&#10;                bagCoins.remove(finishedBag)&#10;            })&#10;        }&#10;&#10;        // Bullets&#10;        bullets.forEach { b -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.dan2),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(b.x.roundToInt(), b.y.roundToInt()) }&#10;                    .size(30.dp)&#10;            )&#10;        }&#10;&#10;        // Plane&#10;        PlaneUI(&#10;            planeX = planeX,&#10;            planeY = planeY,&#10;            planeHp = planeHp,&#10;            shieldActive = shieldActive&#10;        )&#10;&#10;        // Wall&#10;        if (wallActive) {&#10;            WallUI(planeY = planeY)&#10;        }&#10;&#10;        // Top bar&#10;        TopBarUI(&#10;            bagCoinScore = totalScore,&#10;            chestItems = chestItems,&#10;            onBuyItem = { item, price -&gt;&#10;                if (totalScore &gt;= price) {&#10;                    totalScore -= price&#10;                    chestItems = chestItems + item&#10;                    if (!playerName.isNullOrBlank()) {&#10;                        FirebaseHelper.updateScore(playerName, totalScore)&#10;                        FirebaseHelper.updateChest(playerName, chestItems)&#10;                    }&#10;                }&#10;            },&#10;            onUseChestItem = { useChestItem(it) }&#10;        )&#10;&#10;        // --- Sound Control Button (top-right corner) ---&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp),&#10;            contentAlignment = androidx.compose.ui.Alignment.TopEnd&#10;        ) {&#10;            SoundControlButton()&#10;        }&#10;    }&#10;&#10;    // --- Game End Dialog ---&#10;    if (showGameEndDialog) {&#10;        GameEndDialog(&#10;            isWin = isLevelClear,&#10;            score = currentSessionScore,&#10;            level = 3,&#10;            onDismiss = {&#10;                showGameEndDialog = false&#10;            },&#10;            onReplay = {&#10;                // Reset game&#10;                showGameEndDialog = false&#10;                isGameOver = false&#10;                isLevelClear = false&#10;                planeHp = 100&#10;                currentSessionScore = 0&#10;&#10;                invisibleMonsters.forEachIndexed { index, m -&gt;&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 100f)&#10;                    m.y.value = -Random.nextInt(200, 3000).toFloat()&#10;                    m.hp.value = 100&#10;                    m.alive.value = true&#10;                    m.isVisible.value = Random.nextBoolean()&#10;                    m.lastToggleTime = System.currentTimeMillis()&#10;                    monsterRespawnTimes[index] = 0L&#10;                }&#10;&#10;                coins.forEach { c -&gt;&#10;                    c.collected.value = false&#10;                    c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                    c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                }&#10;&#10;                bullets.clear()&#10;            },&#10;            onNextLevel = {&#10;                onExit()&#10;            },&#10;            onExit = {&#10;                onExit()&#10;            }&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.game&#10;&#10;import android.os.Bundle&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.TopBarComponent.TopBarUI&#10;import com.example.game.core.*&#10;import com.example.game.ui.PlaneUI&#10;import com.example.game.ui.WallUI&#10;import com.example.game.ui.InvisibleMonsterUI&#10;import com.example.game.ui.SoundControlButton&#10;import com.example.game.ui.BagCoinAnimatedView&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.roundToInt&#10;import kotlin.random.Random&#10;&#10;class Level3Activity : BaseGameActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        try {&#10;            initAudio()&#10;&#10;            // Initialize AI Avoidance Helper for smart bullet dodging&#10;            try {&#10;                AIAvoidanceHelper.init(this)&#10;            } catch (e: Exception) {&#10;                e.printStackTrace()&#10;                // Continue without AI if it fails&#10;            }&#10;&#10;            setContent {&#10;                val density = LocalDensity.current&#10;                val screenWidthPx = with(density) { LocalConfiguration.current.screenWidthDp.dp.toPx() }&#10;                val screenHeightPx = with(density) { LocalConfiguration.current.screenHeightDp.dp.toPx() }&#10;&#10;                Level3Game(&#10;                    screenWidthPx = screenWidthPx,&#10;                    screenHeightPx = screenHeightPx,&#10;                    soundPool = soundPool,&#10;                    shootSoundId = shootSoundId,&#10;                    hitSoundId = hitSoundId,&#10;                    onExit = { finish() }&#10;                )&#10;            }&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            finish() // Exit gracefully if something goes wrong&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        try {&#10;            AIAvoidanceHelper.release()&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Level3Game(&#10;    screenWidthPx: Float,&#10;    screenHeightPx: Float,&#10;    soundPool: android.media.SoundPool,&#10;    shootSoundId: Int,&#10;    hitSoundId: Int,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val playerName = PrefManager.getPlayerName(context)&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // --- State ---&#10;    var totalScore by remember { mutableStateOf(0) }&#10;    var currentSessionScore by remember { mutableStateOf(0) }&#10;    var planeHp by remember { mutableStateOf(100) }&#10;&#10;    var shieldActive by remember { mutableStateOf(false) }&#10;    var wallActive by remember { mutableStateOf(false) }&#10;    var timeActive by remember { mutableStateOf(false) }&#10;&#10;    var isGameOver by remember { mutableStateOf(false) }&#10;    var isLevelClear by remember { mutableStateOf(false) }&#10;    var showGameEndDialog by remember { mutableStateOf(false) }&#10;&#10;    // Show dialog when game ends&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        if (isGameOver || isLevelClear) {&#10;            delay(500)&#10;            showGameEndDialog = true&#10;        }&#10;    }&#10;&#10;    // --- Plane setup ---&#10;    var planeX by remember { mutableStateOf(screenWidthPx / 2 - 50f) }&#10;    val planeY = screenHeightPx - 250f&#10;    val planeWidth = 100f&#10;    val planeHeight = 100f&#10;&#10;    // --- Background ---&#10;    var bg1Y by remember { mutableStateOf(0f) }&#10;    var bg2Y by remember { mutableStateOf(-screenHeightPx) }&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bg1Y += 4f&#10;            bg2Y += 4f&#10;            if (bg1Y &gt;= screenHeightPx) bg1Y = bg2Y - screenHeightPx&#10;            if (bg2Y &gt;= screenHeightPx) bg2Y = bg1Y - screenHeightPx&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Invisible Monsters ---&#10;    val invisibleMonsters = remember {&#10;        List(12) {&#10;            InvisibleMonster(&#10;                x = Random.nextFloat() * (screenWidthPx - 100f),&#10;                y = mutableStateOf(-Random.nextInt(200, 3000).toFloat()),&#10;                speed = Random.nextFloat() * 1.5f + 1.5f,&#10;                hp = mutableStateOf(100),&#10;                invisibleDuration = 2000L, // Invisible for 2 seconds&#10;                visibleDuration = 1500L     // Visible for 1.5 seconds&#10;            )&#10;        }&#10;    }&#10;&#10;    // Track respawn times&#10;    val monsterRespawnTimes = remember { MutableList(invisibleMonsters.size) { 0L } }&#10;&#10;    val coins = remember {&#10;        List(6) {&#10;            BaseCoin(&#10;                x = Random.nextFloat() * (screenWidthPx - 50f),&#10;                y = mutableStateOf(-Random.nextInt(100, 600).toFloat()),&#10;                speed = Random.nextFloat() * 2f + 1f&#10;            )&#10;        }&#10;    }&#10;&#10;    val bullets = remember { mutableStateListOf&lt;Bullet&gt;() }&#10;    val bagCoins = remember { mutableStateListOf&lt;BagCoinDisplay&gt;() }&#10;    var chestItems by remember { mutableStateOf&lt;List&lt;ChestItem&gt;&gt;(emptyList()) }&#10;&#10;    // --- Load player data ---&#10;    LaunchedEffect(Unit) {&#10;        if (!playerName.isNullOrBlank()) {&#10;            FirebaseHelper.syncNewPlayer(playerName)&#10;            FirebaseHelper.getScore(playerName) { totalScore = it }&#10;            FirebaseHelper.getChestItems(playerName) { chestItems = it }&#10;        }&#10;    }&#10;&#10;    // --- Shooting ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.add(Bullet(planeX + planeWidth / 2f - 15f, planeY))&#10;            SoundManager.playSoundEffect(soundPool, shootSoundId, 0.5f)&#10;            delay(300)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.forEach { it.y -= 25f }&#10;            bullets.removeAll { it.y &lt; -50f }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Monster movement + invisible toggle ---&#10;    invisibleMonsters.forEachIndexed { index, m -&gt;&#10;        LaunchedEffect(m, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                // Check if monster needs to respawn&#10;                if (!m.alive.value &amp;&amp; System.currentTimeMillis() &gt;= monsterRespawnTimes[index]) {&#10;                    m.y.value = -Random.nextInt(200, 1500).toFloat()&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 100f)&#10;                    m.hp.value = 100&#10;                    m.alive.value = true&#10;                    m.lastToggleTime = System.currentTimeMillis()&#10;                    m.isVisible.value = Random.nextBoolean() // Random start state&#10;                }&#10;&#10;                if (m.alive.value &amp;&amp; m.hp.value &gt; 0 &amp;&amp; !timeActive) {&#10;                    // AI-based evasion: monster tries to dodge bullets intelligently&#10;                    val evasion = AIAvoidanceHelper.calculateEvasion(&#10;                        monsterX = m.x,&#10;                        monsterY = m.y.value,&#10;                        monsterSize = 100f,&#10;                        bullets = bullets,&#10;                        screenWidth = screenWidthPx&#10;                    )&#10;&#10;                    // Apply AI evasion (combines with zigzag movement)&#10;                    val aiDodgeX = evasion.first&#10;&#10;                    // Toggle visibility&#10;                    val currentTime = System.currentTimeMillis()&#10;                    val elapsed = currentTime - m.lastToggleTime&#10;                    val threshold = if (m.isVisible.value) m.visibleDuration else m.invisibleDuration&#10;&#10;                    if (elapsed &gt;= threshold) {&#10;                        m.isVisible.value = !m.isVisible.value&#10;                        m.lastToggleTime = currentTime&#10;                    }&#10;&#10;                    // Wall collision check&#10;                    val wallTop = planeY - 60f&#10;                    val monsterBottom = m.y.value + 80f&#10;&#10;                    if (wallActive &amp;&amp; monsterBottom &gt;= wallTop) {&#10;                        // Stop at wall&#10;                    } else {&#10;                        // Normal movement&#10;                        m.y.value += m.speed&#10;                    }&#10;&#10;                    // Zigzag movement combined with AI evasion&#10;                    val combinedX = (m.horizontalSpeed * m.direction) + aiDodgeX&#10;                    m.x = (m.x + combinedX).coerceIn(0f, screenWidthPx - 100f)&#10;&#10;                    if (m.x &lt;= 0 || m.x &gt;= screenWidthPx - 100f) {&#10;                        m.direction *= -1&#10;                    }&#10;&#10;                    // If monster passes plane&#10;                    if (m.y.value &gt; planeY + planeHeight / 2f) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) planeHp -= 50&#10;                        monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 8000)&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;                delay(16)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Coin movement ---&#10;    coins.forEach { c -&gt;&#10;        LaunchedEffect(c, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                if (!c.collected.value &amp;&amp; !timeActive) {&#10;                    c.y.value += c.speed&#10;                    if (c.y.value &gt; screenHeightPx) {&#10;                        c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                        c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                    }&#10;                }&#10;                delay(32)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Bullet vs Monster collision (only when visible) ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            val iter = bullets.iterator()&#10;            while (iter.hasNext()) {&#10;                val b = iter.next()&#10;                invisibleMonsters.forEach { m -&gt;&#10;                    // Can only hit visible monsters&#10;                    if (m.isVisible.value &amp;&amp; CollisionUtils.checkCollisionBulletInvisibleMonster(b, m)) {&#10;                        m.hp.value -= 25&#10;                        // Play hit sound&#10;                        SoundManager.playSoundEffect(soundPool, hitSoundId, 0.3f)&#10;                        iter.remove()&#10;                        if (m.hp.value &lt;= 0) {&#10;                            m.alive.value = false&#10;                            val index = invisibleMonsters.indexOf(m)&#10;                            if (index &gt;= 0) {&#10;                                monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 8000)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Coin collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            coins.forEach { c -&gt;&#10;                if (!c.collected.value &amp;&amp; CollisionUtils.checkCollisionPlaneCoin(planeX, planeY, planeWidth, planeHeight, c)) {&#10;                    c.collected.value = true&#10;                    totalScore += 1&#10;                    currentSessionScore += 1&#10;                    val bag = BagCoinDisplay(c.x, c.y.value, 1)&#10;                    bagCoins.add(bag)&#10;                    if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Monster collision (only when visible) ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            invisibleMonsters.forEach { m -&gt;&#10;                if (m.isVisible.value &amp;&amp; CollisionUtils.checkCollisionPlaneInvisibleMonster(planeX, planeY, planeWidth, planeHeight, m)) {&#10;                    if (!shieldActive &amp;&amp; !wallActive) planeHp -= 50&#10;                    m.hp.value = 0&#10;                    m.alive.value = false&#10;                }&#10;            }&#10;            if (planeHp &lt;= 0) isGameOver = true&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Wall - Monster collision ---&#10;    LaunchedEffect(wallActive, isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            if (wallActive) {&#10;                invisibleMonsters.forEach { m -&gt;&#10;                    if (m.isVisible.value &amp;&amp; CollisionUtils.checkCollisionWallInvisibleMonster(planeY, m)) {&#10;                        m.hp.value -= 2&#10;                        if (m.hp.value &lt;= 0) {&#10;                            m.alive.value = false&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Use chest item ---&#10;    fun useChestItem(item: ChestItem) {&#10;        ChestItemEffectsBase.applyItemEffect(&#10;            itemName = item.name,&#10;            monsters = invisibleMonsters,&#10;            coins = coins,&#10;            bagCoins = bagCoins,&#10;            coroutineScope = coroutineScope,&#10;            screenHeightPx = screenHeightPx,&#10;            planeX = planeX,&#10;            onScoreUpdate = { add -&gt;&#10;                totalScore += add&#10;                currentSessionScore += add&#10;                if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;            },&#10;            onShieldToggle = { active -&gt; shieldActive = active },&#10;            onWallToggle = { active -&gt; wallActive = active },&#10;            onTimeToggle = { active -&gt; timeActive = active },&#10;            onLevelClear = { isLevelClear = true }&#10;        )&#10;        chestItems = chestItems - item&#10;        if (!playerName.isNullOrBlank()) FirebaseHelper.updateChest(playerName, chestItems)&#10;    }&#10;&#10;    // --- Drag plane ---&#10;    val dragModifier = Modifier.pointerInput(Unit) {&#10;        detectDragGestures { change, dragAmount -&gt;&#10;            planeX = (planeX + dragAmount.x).coerceIn(0f, screenWidthPx - planeWidth)&#10;            change.consume()&#10;        }&#10;    }&#10;&#10;    // --- UI ---&#10;    Box(modifier = Modifier.fillMaxSize().then(dragModifier)) {&#10;        // Background&#10;        Image(&#10;            painter = painterResource(R.drawable.vutru1),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg1Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;        Image(&#10;            painter = painterResource(R.drawable.vutru1),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg2Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;&#10;        // Monsters (Level 3 uses InvisibleMonsterUI)&#10;        invisibleMonsters.forEach { m -&gt;&#10;            InvisibleMonsterUI(monster = m, level = 3)&#10;        }&#10;&#10;        // Coins&#10;        coins.filter { !it.collected.value }.forEach { c -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.coin),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(c.x.roundToInt(), c.y.value.roundToInt()) }&#10;                    .size(40.dp)&#10;            )&#10;        }&#10;&#10;        // BagCoin animated views&#10;        bagCoins.toList().forEach { bag -&gt;&#10;            BagCoinAnimatedView(bag = bag, onFinished = { finishedBag -&gt;&#10;                bagCoins.remove(finishedBag)&#10;            })&#10;        }&#10;&#10;        // Bullets&#10;        bullets.forEach { b -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.dan2),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(b.x.roundToInt(), b.y.roundToInt()) }&#10;                    .size(30.dp)&#10;            )&#10;        }&#10;&#10;        // Plane&#10;        PlaneUI(&#10;            planeX = planeX,&#10;            planeY = planeY,&#10;            planeHp = planeHp,&#10;            shieldActive = shieldActive,&#10;            level = 3&#10;        )&#10;&#10;        // Wall&#10;        if (wallActive) {&#10;            WallUI(planeY = planeY)&#10;        }&#10;&#10;        // Top bar&#10;        TopBarUI(&#10;            bagCoinScore = totalScore,&#10;            chestItems = chestItems,&#10;            onBuyItem = { item, price -&gt;&#10;                if (totalScore &gt;= price) {&#10;                    totalScore -= price&#10;                    chestItems = chestItems + item&#10;                    if (!playerName.isNullOrBlank()) {&#10;                        FirebaseHelper.updateScore(playerName, totalScore)&#10;                        FirebaseHelper.updateChest(playerName, chestItems)&#10;                    }&#10;                }&#10;            },&#10;            onUseChestItem = { useChestItem(it) }&#10;        )&#10;&#10;        // --- Sound Control Button (top-right corner) ---&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp),&#10;            contentAlignment = androidx.compose.ui.Alignment.TopEnd&#10;        ) {&#10;            SoundControlButton()&#10;        }&#10;    }&#10;&#10;    // --- Game End Dialog ---&#10;    if (showGameEndDialog) {&#10;        GameEndDialog(&#10;            isWin = isLevelClear,&#10;            score = currentSessionScore,&#10;            level = 3,&#10;            onDismiss = {&#10;                showGameEndDialog = false&#10;            },&#10;            onReplay = {&#10;                // Reset game&#10;                showGameEndDialog = false&#10;                isGameOver = false&#10;                isLevelClear = false&#10;                planeHp = 100&#10;                currentSessionScore = 0&#10;&#10;                invisibleMonsters.forEachIndexed { index, m -&gt;&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 100f)&#10;                    m.y.value = -Random.nextInt(200, 3000).toFloat()&#10;                    m.hp.value = 100&#10;                    m.alive.value = true&#10;                    m.isVisible.value = Random.nextBoolean()&#10;                    m.lastToggleTime = System.currentTimeMillis()&#10;                    monsterRespawnTimes[index] = 0L&#10;                }&#10;&#10;                coins.forEach { c -&gt;&#10;                    c.collected.value = false&#10;                    c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                    c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                }&#10;&#10;                bullets.clear()&#10;            },&#10;            onNextLevel = {&#10;                onExit()&#10;            },&#10;            onExit = {&#10;                onExit()&#10;            }&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/game/Level4Activity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/game/Level4Activity.kt" />
              <option name="originalContent" value="package com.example.game&#10;&#10;import android.os.Bundle&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.TopBarComponent.TopBarUI&#10;import com.example.game.core.*&#10;import com.example.game.ui.PlaneUI&#10;import com.example.game.ui.WallUI&#10;import com.example.game.ui.GrowingMonsterUI&#10;import com.example.game.ui.SoundControlButton&#10;import com.example.game.ui.BagCoinAnimatedView&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.roundToInt&#10;import kotlin.random.Random&#10;&#10;class Level4Activity : BaseGameActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        initAudio()&#10;&#10;        // Initialize AI Avoidance Helper for smart bullet dodging&#10;        try {&#10;            AIAvoidanceHelper.init(this)&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;Level4Activity&quot;, &quot;AI init failed: ${e.message}&quot;, e)&#10;            // Continue without AI - game will still work with basic logic&#10;        }&#10;&#10;        setContent {&#10;            val density = LocalDensity.current&#10;            val screenWidthPx = with(density) { LocalConfiguration.current.screenWidthDp.dp.toPx() }&#10;            val screenHeightPx = with(density) { LocalConfiguration.current.screenHeightDp.dp.toPx() }&#10;&#10;            Level4Game(&#10;                screenWidthPx = screenWidthPx,&#10;                screenHeightPx = screenHeightPx,&#10;                soundPool = soundPool,&#10;                shootSoundId = shootSoundId,&#10;                hitSoundId = hitSoundId,&#10;                onExit = { finish() }&#10;            )&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        try {&#10;            AIAvoidanceHelper.release()&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;Level4Activity&quot;, &quot;AI release failed: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Level4Game(&#10;    screenWidthPx: Float,&#10;    screenHeightPx: Float,&#10;    soundPool: android.media.SoundPool,&#10;    shootSoundId: Int,&#10;    hitSoundId: Int,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val playerName = PrefManager.getPlayerName(context)&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // --- State ---&#10;    var totalScore by remember { mutableStateOf(0) }&#10;    var currentSessionScore by remember { mutableStateOf(0) }&#10;    var planeHp by remember { mutableStateOf(100) }&#10;&#10;    var shieldActive by remember { mutableStateOf(false) }&#10;    var wallActive by remember { mutableStateOf(false) }&#10;    var timeActive by remember { mutableStateOf(false) }&#10;&#10;    var isGameOver by remember { mutableStateOf(false) }&#10;    var isLevelClear by remember { mutableStateOf(false) }&#10;    var showGameEndDialog by remember { mutableStateOf(false) }&#10;&#10;    // Show dialog when game ends&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        if (isGameOver || isLevelClear) {&#10;            delay(500)&#10;            showGameEndDialog = true&#10;        }&#10;    }&#10;&#10;    // --- Plane setup ---&#10;    var planeX by remember { mutableStateOf(screenWidthPx / 2 - 50f) }&#10;    val planeY = screenHeightPx - 250f&#10;    val planeWidth = 100f&#10;    val planeHeight = 100f&#10;&#10;    // --- Background ---&#10;    var bg1Y by remember { mutableStateOf(0f) }&#10;    var bg2Y by remember { mutableStateOf(-screenHeightPx) }&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bg1Y += 4f&#10;            bg2Y += 4f&#10;            if (bg1Y &gt;= screenHeightPx) bg1Y = bg2Y - screenHeightPx&#10;            if (bg2Y &gt;= screenHeightPx) bg2Y = bg1Y - screenHeightPx&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Growing Monsters ---&#10;    val growingMonsters = remember {&#10;        List(10) {&#10;            GrowingMonster(&#10;                x = Random.nextFloat() * (screenWidthPx - 200f) + 100f,&#10;                y = mutableStateOf(-Random.nextInt(200, 2500).toFloat()),&#10;                speed = Random.nextFloat() * 1.2f + 1.0f,&#10;                hp = mutableStateOf(80),&#10;                initialSize = 60f,&#10;                maxSize = 600f,&#10;                growthRate = 0.5f&#10;            )&#10;        }&#10;    }&#10;&#10;    // Track respawn times&#10;    val monsterRespawnTimes = remember { MutableList(growingMonsters.size) { 0L } }&#10;&#10;    val coins = remember {&#10;        List(6) {&#10;            BaseCoin(&#10;                x = Random.nextFloat() * (screenWidthPx - 50f),&#10;                y = mutableStateOf(-Random.nextInt(100, 600).toFloat()),&#10;                speed = Random.nextFloat() * 2f + 1f&#10;            )&#10;        }&#10;    }&#10;&#10;    val bullets = remember { mutableStateListOf&lt;Bullet&gt;() }&#10;    val bagCoins = remember { mutableStateListOf&lt;BagCoinDisplay&gt;() }&#10;    var chestItems by remember { mutableStateOf&lt;List&lt;ChestItem&gt;&gt;(emptyList()) }&#10;&#10;    // --- Load player data ---&#10;    LaunchedEffect(Unit) {&#10;        if (!playerName.isNullOrBlank()) {&#10;            FirebaseHelper.syncNewPlayer(playerName)&#10;            FirebaseHelper.getScore(playerName) { totalScore = it }&#10;            FirebaseHelper.getChestItems(playerName) { chestItems = it }&#10;        }&#10;    }&#10;&#10;    // --- Shooting ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.add(Bullet(planeX + planeWidth / 2f - 15f, planeY))&#10;            SoundManager.playSoundEffect(soundPool, shootSoundId, 0.5f)&#10;            delay(300)&#10;        }&#10;    }&#10;&#10;    // --- Bullet movement ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.forEach { it.y -= 25f }&#10;            bullets.removeAll { it.y &lt; -50f }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Monster movement + growing + AI evasion ---&#10;    growingMonsters.forEachIndexed { index, m -&gt;&#10;        LaunchedEffect(m, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                // Check if monster needs to respawn&#10;                if (!m.alive.value &amp;&amp; System.currentTimeMillis() &gt;= monsterRespawnTimes[index]) {&#10;                    m.y.value = -Random.nextInt(200, 1500).toFloat()&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 200f) + 100f&#10;                    m.hp.value = 80&#10;                    m.maxHp = 80&#10;                    m.currentMaxHp.value = 80&#10;                    m.currentSize.value = m.initialSize&#10;                    m.alive.value = true&#10;                }&#10;&#10;                if (m.alive.value) {&#10;                    // AI-based evasion: monster tries to dodge bullets intelligently&#10;                    val evasion = AIAvoidanceHelper.calculateEvasion(&#10;                        monsterX = m.x,&#10;                        monsterY = m.y.value,&#10;                        monsterSize = m.currentSize.value,&#10;                        bullets = bullets,&#10;                        screenWidth = screenWidthPx&#10;                    )&#10;&#10;                    // Apply evasion movement (horizontal dodge)&#10;                    m.x = (m.x + evasion.first).coerceIn(0f, screenWidthPx - m.currentSize.value)&#10;&#10;                    // Grow over time&#10;                    m.grow()&#10;&#10;                    // Wall collision check&#10;                    val wallTop = planeY - 60f&#10;                    val monsterBottom = m.y.value + m.currentSize.value&#10;&#10;                    if (wallActive &amp;&amp; monsterBottom &gt;= wallTop) {&#10;                        // Stop at wall&#10;                    } else {&#10;                        // Normal downward movement&#10;                        m.y.value += m.speed&#10;                    }&#10;&#10;                    // If monster passes plane&#10;                    if (m.y.value &gt; planeY + planeHeight / 2f) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) {&#10;                            // Damage scales with monster size&#10;                            val damage = (30 * (m.currentSize.value / m.initialSize)).toInt()&#10;                            planeHp -= damage&#10;                        }&#10;                        monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 8000)&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;                delay(16)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Coin movement ---&#10;    coins.forEach { c -&gt;&#10;        LaunchedEffect(c, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                if (!c.collected.value &amp;&amp; !timeActive) {&#10;                    c.y.value += c.speed&#10;                    if (c.y.value &gt; screenHeightPx) {&#10;                        c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                        c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                    }&#10;                }&#10;                delay(32)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Bullet - Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            growingMonsters.forEach { m -&gt;&#10;                if (m.alive.value) {&#10;                    val iter = bullets.iterator()&#10;                    while (iter.hasNext()) {&#10;                        val b = iter.next()&#10;                        if (CollisionUtils.checkCollisionBulletMonster(b, m)) {&#10;                            m.hp.value -= 20&#10;                            SoundManager.playSoundEffect(soundPool, hitSoundId, 0.3f)&#10;                            iter.remove()&#10;                            if (m.hp.value &lt;= 0) {&#10;                                m.alive.value = false&#10;                                val index = growingMonsters.indexOf(m)&#10;                                if (index &gt;= 0) {&#10;                                    monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(3000, 8000)&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Coin collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            coins.forEach { c -&gt;&#10;                if (!c.collected.value &amp;&amp; CollisionUtils.checkCollisionPlaneCoin(planeX, planeY, planeWidth, planeHeight, c)) {&#10;                    c.collected.value = true&#10;                    totalScore += 1&#10;                    currentSessionScore += 1&#10;                    val bag = BagCoinDisplay(c.x, c.y.value, 1)&#10;                    bagCoins.add(bag)&#10;                    if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            growingMonsters.forEach { m -&gt;&#10;                if (m.alive.value &amp;&amp; CollisionUtils.checkCollisionPlaneMonster(planeX, planeY, planeWidth, planeHeight, m)) {&#10;                    if (!shieldActive) {&#10;                        val damage = (30 * (m.currentSize.value / m.initialSize)).toInt()&#10;                        planeHp -= damage&#10;                    }&#10;                    m.hp.value = 0&#10;                    m.alive.value = false&#10;                }&#10;            }&#10;            if (planeHp &lt;= 0) isGameOver = true&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Wall - Monster collision ---&#10;    LaunchedEffect(wallActive, isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            if (wallActive) {&#10;                growingMonsters.forEach { m -&gt;&#10;                    if (m.alive.value) {&#10;                        val wallTop = planeY - 60f&#10;                        val monsterBottom = m.y.value + m.currentSize.value&#10;                        if (monsterBottom &gt;= wallTop) {&#10;                            m.hp.value -= 2&#10;                            if (m.hp.value &lt;= 0) {&#10;                                m.alive.value = false&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Use chest item ---&#10;    fun useChestItem(item: ChestItem) {&#10;        ChestItemEffectsBase.applyItemEffect(&#10;            itemName = item.name,&#10;            monsters = growingMonsters,&#10;            coins = coins,&#10;            bagCoins = bagCoins,&#10;            coroutineScope = coroutineScope,&#10;            screenHeightPx = screenHeightPx,&#10;            planeX = planeX,&#10;            onScoreUpdate = { add -&gt;&#10;                totalScore += add&#10;                currentSessionScore += add&#10;                if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;            },&#10;            onShieldToggle = { active -&gt; shieldActive = active },&#10;            onWallToggle = { active -&gt; wallActive = active },&#10;            onTimeToggle = { active -&gt; timeActive = active },&#10;            onLevelClear = { isLevelClear = true }&#10;        )&#10;        chestItems = chestItems - item&#10;        if (!playerName.isNullOrBlank()) FirebaseHelper.updateChest(playerName, chestItems)&#10;    }&#10;&#10;    // --- Drag plane ---&#10;    val dragModifier = Modifier.pointerInput(Unit) {&#10;        detectDragGestures { change, dragAmount -&gt;&#10;            planeX = (planeX + dragAmount.x).coerceIn(0f, screenWidthPx - planeWidth)&#10;            change.consume()&#10;        }&#10;    }&#10;&#10;    // --- UI ---&#10;    Box(modifier = Modifier.fillMaxSize().then(dragModifier)) {&#10;        // Background&#10;        Image(&#10;            painter = painterResource(R.drawable.vutru1),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg1Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;        Image(&#10;            painter = painterResource(R.drawable.vutru1),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg2Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;&#10;        // Growing Monsters&#10;        growingMonsters.forEach { m -&gt;&#10;            GrowingMonsterUI(monster = m)&#10;        }&#10;&#10;        // Coins&#10;        coins.filter { !it.collected.value }.forEach { c -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.coin),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(c.x.roundToInt(), c.y.value.roundToInt()) }&#10;                    .size(40.dp)&#10;            )&#10;        }&#10;&#10;        // BagCoin animated views&#10;        bagCoins.toList().forEach { bag -&gt;&#10;            BagCoinAnimatedView(bag = bag, onFinished = { finishedBag -&gt;&#10;                bagCoins.remove(finishedBag)&#10;            })&#10;        }&#10;&#10;        // Bullets&#10;        bullets.forEach { b -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.dan2),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(b.x.roundToInt(), b.y.roundToInt()) }&#10;                    .size(30.dp)&#10;            )&#10;        }&#10;&#10;        // Plane&#10;        PlaneUI(&#10;            planeX = planeX,&#10;            planeY = planeY,&#10;            planeHp = planeHp,&#10;            shieldActive = shieldActive&#10;        )&#10;&#10;        // Wall&#10;        if (wallActive) {&#10;            WallUI(planeY = planeY)&#10;        }&#10;&#10;        // Top bar&#10;        TopBarUI(&#10;            bagCoinScore = totalScore,&#10;            chestItems = chestItems,&#10;            onBuyItem = { item, price -&gt;&#10;                if (totalScore &gt;= price) {&#10;                    totalScore -= price&#10;                    chestItems = chestItems + item&#10;                    if (!playerName.isNullOrBlank()) {&#10;                        FirebaseHelper.updateScore(playerName, totalScore)&#10;                        FirebaseHelper.updateChest(playerName, chestItems)&#10;                    }&#10;                }&#10;            },&#10;            onUseChestItem = { useChestItem(it) }&#10;        )&#10;&#10;        // --- Sound Control Button (top-right corner) ---&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp),&#10;            contentAlignment = androidx.compose.ui.Alignment.TopEnd&#10;        ) {&#10;            SoundControlButton()&#10;        }&#10;    }&#10;&#10;    // --- Game End Dialog ---&#10;    if (showGameEndDialog) {&#10;        GameEndDialog(&#10;            isWin = isLevelClear,&#10;            score = currentSessionScore,&#10;            level = 4,&#10;            onDismiss = {&#10;                showGameEndDialog = false&#10;            },&#10;            onReplay = {&#10;                // Reset game&#10;                showGameEndDialog = false&#10;                isGameOver = false&#10;                isLevelClear = false&#10;                planeHp = 100&#10;                currentSessionScore = 0&#10;&#10;                growingMonsters.forEachIndexed { index, m -&gt;&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 200f) + 100f&#10;                    m.y.value = -Random.nextInt(200, 2500).toFloat()&#10;                    m.hp.value = 80&#10;                    m.maxHp = 80&#10;                    m.currentMaxHp.value = 80&#10;                    m.currentSize.value = m.initialSize&#10;                    m.alive.value = true&#10;                    monsterRespawnTimes[index] = 0L&#10;                }&#10;&#10;                coins.forEach { c -&gt;&#10;                    c.collected.value = false&#10;                    c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                    c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                }&#10;&#10;                bullets.clear()&#10;            },&#10;            onNextLevel = {&#10;                onExit()&#10;            },&#10;            onExit = {&#10;                onExit()&#10;            }&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.game&#10;&#10;import android.os.Bundle&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.TopBarComponent.TopBarUI&#10;import com.example.game.core.*&#10;import com.example.game.ui.PlaneUI&#10;import com.example.game.ui.WallUI&#10;import com.example.game.ui.GrowingMonsterUI&#10;import com.example.game.ui.SoundControlButton&#10;import com.example.game.ui.BagCoinAnimatedView&#10;import kotlinx.coroutines.delay&#10;import kotlin.math.roundToInt&#10;import kotlin.random.Random&#10;&#10;class Level4Activity : BaseGameActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        initAudio()&#10;&#10;        // Initialize AI Avoidance Helper for smart bullet dodging&#10;        try {&#10;            AIAvoidanceHelper.init(this)&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;Level4Activity&quot;, &quot;AI init failed: ${e.message}&quot;, e)&#10;            // Continue without AI - game will still work with basic logic&#10;        }&#10;&#10;        setContent {&#10;            val density = LocalDensity.current&#10;            val screenWidthPx = with(density) { LocalConfiguration.current.screenWidthDp.dp.toPx() }&#10;            val screenHeightPx = with(density) { LocalConfiguration.current.screenHeightDp.dp.toPx() }&#10;&#10;            Level4Game(&#10;                screenWidthPx = screenWidthPx,&#10;                screenHeightPx = screenHeightPx,&#10;                soundPool = soundPool,&#10;                shootSoundId = shootSoundId,&#10;                hitSoundId = hitSoundId,&#10;                onExit = { finish() }&#10;            )&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        try {&#10;            AIAvoidanceHelper.release()&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;Level4Activity&quot;, &quot;AI release failed: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Level4Game(&#10;    screenWidthPx: Float,&#10;    screenHeightPx: Float,&#10;    soundPool: android.media.SoundPool,&#10;    shootSoundId: Int,&#10;    hitSoundId: Int,&#10;    onExit: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val playerName = PrefManager.getPlayerName(context)&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // --- State ---&#10;    var totalScore by remember { mutableStateOf(0) }&#10;    var currentSessionScore by remember { mutableStateOf(0) }&#10;    var planeHp by remember { mutableStateOf(100) }&#10;&#10;    var shieldActive by remember { mutableStateOf(false) }&#10;    var wallActive by remember { mutableStateOf(false) }&#10;    var timeActive by remember { mutableStateOf(false) }&#10;&#10;    var isGameOver by remember { mutableStateOf(false) }&#10;    var isLevelClear by remember { mutableStateOf(false) }&#10;    var showGameEndDialog by remember { mutableStateOf(false) }&#10;&#10;    // Show dialog when game ends&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        if (isGameOver || isLevelClear) {&#10;            delay(500)&#10;            showGameEndDialog = true&#10;        }&#10;    }&#10;&#10;    // --- Plane setup ---&#10;    var planeX by remember { mutableStateOf(screenWidthPx / 2 - 50f) }&#10;    val planeY = screenHeightPx - 250f&#10;    val planeWidth = 100f&#10;    val planeHeight = 100f&#10;&#10;    // --- Background ---&#10;    var bg1Y by remember { mutableStateOf(0f) }&#10;    var bg2Y by remember { mutableStateOf(-screenHeightPx) }&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bg1Y += 4f&#10;            bg2Y += 4f&#10;            if (bg1Y &gt;= screenHeightPx) bg1Y = bg2Y - screenHeightPx&#10;            if (bg2Y &gt;= screenHeightPx) bg2Y = bg1Y - screenHeightPx&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Growing Monsters ---&#10;    val growingMonsters = remember {&#10;        List(10) {&#10;            GrowingMonster(&#10;                x = Random.nextFloat() * (screenWidthPx - 200f) + 100f,&#10;                y = mutableStateOf(-Random.nextInt(200, 1500).toFloat()),&#10;                speed = Random.nextFloat() * 1.2f + 1.0f,&#10;                hp = mutableStateOf(50),  // Giảm HP từ 80 xuống 50&#10;                initialSize = 60f,&#10;                maxSize = 200f,  // Giảm max size từ 600f xuống 200f&#10;                growthRate = 0.3f  // Giảm tốc độ lớn từ 0.5f xuống 0.3f&#10;            )&#10;        }&#10;    }&#10;&#10;    // Track respawn times&#10;    val monsterRespawnTimes = remember { MutableList(growingMonsters.size) { 0L } }&#10;&#10;    val coins = remember {&#10;        List(6) {&#10;            BaseCoin(&#10;                x = Random.nextFloat() * (screenWidthPx - 50f),&#10;                y = mutableStateOf(-Random.nextInt(100, 600).toFloat()),&#10;                speed = Random.nextFloat() * 2f + 1f&#10;            )&#10;        }&#10;    }&#10;&#10;    val bullets = remember { mutableStateListOf&lt;Bullet&gt;() }&#10;    val bagCoins = remember { mutableStateListOf&lt;BagCoinDisplay&gt;() }&#10;    var chestItems by remember { mutableStateOf&lt;List&lt;ChestItem&gt;&gt;(emptyList()) }&#10;&#10;    // --- Load player data ---&#10;    LaunchedEffect(Unit) {&#10;        if (!playerName.isNullOrBlank()) {&#10;            FirebaseHelper.syncNewPlayer(playerName)&#10;            FirebaseHelper.getScore(playerName) { totalScore = it }&#10;            FirebaseHelper.getChestItems(playerName) { chestItems = it }&#10;        }&#10;    }&#10;&#10;    // --- Shooting ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.add(Bullet(planeX + planeWidth / 2f - 15f, planeY))&#10;            SoundManager.playSoundEffect(soundPool, shootSoundId, 0.5f)&#10;            delay(300)&#10;        }&#10;    }&#10;&#10;    // --- Bullet movement ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            bullets.forEach { it.y -= 25f }&#10;            bullets.removeAll { it.y &lt; -50f }&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Monster movement + growing + AI evasion ---&#10;    growingMonsters.forEachIndexed { index, m -&gt;&#10;        LaunchedEffect(m, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                // Check if monster needs to respawn&#10;                if (!m.alive.value &amp;&amp; System.currentTimeMillis() &gt;= monsterRespawnTimes[index]) {&#10;                    m.y.value = -Random.nextInt(200, 1500).toFloat()&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 200f) + 100f&#10;                    m.hp.value = 80&#10;                    m.maxHp = 80&#10;                    m.currentMaxHp.value = 80&#10;                    m.currentSize.value = m.initialSize&#10;                    m.alive.value = true&#10;                }&#10;&#10;                if (m.alive.value) {&#10;                    // AI-based evasion: monster tries to dodge bullets intelligently&#10;                    val evasion = AIAvoidanceHelper.calculateEvasion(&#10;                        monsterX = m.x,&#10;                        monsterY = m.y.value,&#10;                        monsterSize = m.currentSize.value,&#10;                        bullets = bullets,&#10;                        screenWidth = screenWidthPx&#10;                    )&#10;&#10;                    // Apply evasion movement (horizontal dodge)&#10;                    m.x = (m.x + evasion.first).coerceIn(0f, screenWidthPx - m.currentSize.value)&#10;&#10;                    // Grow over time&#10;                    m.grow()&#10;&#10;                    // Wall collision check&#10;                    val wallTop = planeY - 60f&#10;                    val monsterBottom = m.y.value + m.currentSize.value&#10;&#10;                    if (wallActive &amp;&amp; monsterBottom &gt;= wallTop) {&#10;                        // Stop at wall&#10;                    } else {&#10;                        // Normal downward movement&#10;                        m.y.value += m.speed&#10;                    }&#10;&#10;                    // If monster passes plane&#10;                    if (m.y.value &gt; planeY + planeHeight / 2f) {&#10;                        if (!shieldActive &amp;&amp; !wallActive) {&#10;                            // Damage scales with monster size&#10;                            val damage = (30 * (m.currentSize.value / m.initialSize)).toInt()&#10;                            planeHp -= damage&#10;                        }&#10;                        monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(500, 1500)  // Giảm thời gian respawn từ 1000-2500 xuống 500-1500&#10;                        m.alive.value = false&#10;                    }&#10;                }&#10;                delay(16)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Coin movement ---&#10;    coins.forEach { c -&gt;&#10;        LaunchedEffect(c, isGameOver, isLevelClear) {&#10;            while (!isGameOver &amp;&amp; !isLevelClear) {&#10;                if (!c.collected.value &amp;&amp; !timeActive) {&#10;                    c.y.value += c.speed&#10;                    if (c.y.value &gt; screenHeightPx) {&#10;                        c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                        c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                    }&#10;                }&#10;                delay(32)&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Bullet - Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            val toRemove = mutableSetOf&lt;Bullet&gt;()&#10;            bullets.toList().forEach { b -&gt;&#10;                var shouldRemove = false&#10;                growingMonsters.forEach { m -&gt;&#10;                    if (m.alive.value &amp;&amp; !shouldRemove) {&#10;                        if (CollisionUtils.checkCollisionBulletMonster(b, m)) {&#10;                            m.hp.value -= 20&#10;                            SoundManager.playSoundEffect(soundPool, hitSoundId, 0.3f)&#10;                            shouldRemove = true&#10;                            if (m.hp.value &lt;= 0) {&#10;                                m.alive.value = false&#10;                                val index = growingMonsters.indexOf(m)&#10;                                if (index &gt;= 0) {&#10;                                    monsterRespawnTimes[index] = System.currentTimeMillis() + Random.nextLong(500, 1500)&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;                if (shouldRemove) {&#10;                    toRemove.add(b)&#10;                }&#10;            }&#10;            bullets.removeAll(toRemove)&#10;            delay(16)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Coin collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            coins.forEach { c -&gt;&#10;                if (!c.collected.value &amp;&amp; CollisionUtils.checkCollisionPlaneCoin(planeX, planeY, planeWidth, planeHeight, c)) {&#10;                    c.collected.value = true&#10;                    totalScore += 1&#10;                    currentSessionScore += 1&#10;                    val bag = BagCoinDisplay(c.x, c.y.value, 1)&#10;                    bagCoins.add(bag)&#10;                    if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Plane - Monster collision ---&#10;    LaunchedEffect(isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            growingMonsters.forEach { m -&gt;&#10;                if (m.alive.value &amp;&amp; CollisionUtils.checkCollisionPlaneMonster(planeX, planeY, planeWidth, planeHeight, m)) {&#10;                    if (!shieldActive) {&#10;                        val damage = (30 * (m.currentSize.value / m.initialSize)).toInt()&#10;                        planeHp -= damage&#10;                    }&#10;                    m.hp.value = 0&#10;                    m.alive.value = false&#10;                }&#10;            }&#10;            if (planeHp &lt;= 0) isGameOver = true&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Wall - Monster collision ---&#10;    LaunchedEffect(wallActive, isGameOver, isLevelClear) {&#10;        while (!isGameOver &amp;&amp; !isLevelClear) {&#10;            if (wallActive) {&#10;                growingMonsters.forEach { m -&gt;&#10;                    if (m.alive.value) {&#10;                        val wallTop = planeY - 60f&#10;                        val monsterBottom = m.y.value + m.currentSize.value&#10;                        if (monsterBottom &gt;= wallTop) {&#10;                            m.hp.value -= 2&#10;                            if (m.hp.value &lt;= 0) {&#10;                                m.alive.value = false&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            delay(50)&#10;        }&#10;    }&#10;&#10;    // --- Use chest item ---&#10;    fun useChestItem(item: ChestItem) {&#10;        ChestItemEffectsBase.applyItemEffect(&#10;            itemName = item.name,&#10;            monsters = growingMonsters,&#10;            coins = coins,&#10;            bagCoins = bagCoins,&#10;            coroutineScope = coroutineScope,&#10;            screenHeightPx = screenHeightPx,&#10;            planeX = planeX,&#10;            onScoreUpdate = { add -&gt;&#10;                totalScore += add&#10;                currentSessionScore += add&#10;                if (!playerName.isNullOrBlank()) FirebaseHelper.updateScore(playerName, totalScore)&#10;            },&#10;            onShieldToggle = { active -&gt; shieldActive = active },&#10;            onWallToggle = { active -&gt; wallActive = active },&#10;            onTimeToggle = { active -&gt; timeActive = active },&#10;            onLevelClear = { isLevelClear = true }&#10;        )&#10;        chestItems = chestItems - item&#10;        if (!playerName.isNullOrBlank()) FirebaseHelper.updateChest(playerName, chestItems)&#10;    }&#10;&#10;    // --- Drag plane ---&#10;    val dragModifier = Modifier.pointerInput(Unit) {&#10;        detectDragGestures { change, dragAmount -&gt;&#10;            planeX = (planeX + dragAmount.x).coerceIn(0f, screenWidthPx - planeWidth)&#10;            change.consume()&#10;        }&#10;    }&#10;&#10;    // --- UI ---&#10;    Box(modifier = Modifier.fillMaxSize().then(dragModifier)) {&#10;        // Background&#10;        Image(&#10;            painter = painterResource(R.drawable.vutru1),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg1Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;        Image(&#10;            painter = painterResource(R.drawable.vutru1),&#10;            contentDescription = null,&#10;            modifier = Modifier.absoluteOffset { IntOffset(0, bg2Y.roundToInt()) }.fillMaxSize()&#10;        )&#10;&#10;        // Growing Monsters&#10;        growingMonsters.forEach { m -&gt;&#10;            GrowingMonsterUI(monster = m, level = 4)&#10;        }&#10;&#10;        // Coins&#10;        coins.filter { !it.collected.value }.forEach { c -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.coin),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(c.x.roundToInt(), c.y.value.roundToInt()) }&#10;                    .size(40.dp)&#10;            )&#10;        }&#10;&#10;        // BagCoin animated views&#10;        bagCoins.toList().forEach { bag -&gt;&#10;            BagCoinAnimatedView(bag = bag, onFinished = { finishedBag -&gt;&#10;                bagCoins.remove(finishedBag)&#10;            })&#10;        }&#10;&#10;        // Bullets&#10;        bullets.forEach { b -&gt;&#10;            Image(&#10;                painter = painterResource(R.drawable.dan2),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .absoluteOffset { IntOffset(b.x.roundToInt(), b.y.roundToInt()) }&#10;                    .size(30.dp)&#10;            )&#10;        }&#10;&#10;        // Plane&#10;        PlaneUI(&#10;            planeX = planeX,&#10;            planeY = planeY,&#10;            planeHp = planeHp,&#10;            shieldActive = shieldActive,&#10;            level = 4&#10;        )&#10;&#10;        // Wall&#10;        if (wallActive) {&#10;            WallUI(planeY = planeY)&#10;        }&#10;&#10;        // Top bar&#10;        TopBarUI(&#10;            bagCoinScore = totalScore,&#10;            chestItems = chestItems,&#10;            onBuyItem = { item, price -&gt;&#10;                if (totalScore &gt;= price) {&#10;                    totalScore -= price&#10;                    chestItems = chestItems + item&#10;                    if (!playerName.isNullOrBlank()) {&#10;                        FirebaseHelper.updateScore(playerName, totalScore)&#10;                        FirebaseHelper.updateChest(playerName, chestItems)&#10;                    }&#10;                }&#10;            },&#10;            onUseChestItem = { useChestItem(it) }&#10;        )&#10;&#10;        // --- Sound Control Button (top-right corner) ---&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp),&#10;            contentAlignment = androidx.compose.ui.Alignment.TopEnd&#10;        ) {&#10;            SoundControlButton()&#10;        }&#10;    }&#10;&#10;    // --- Game End Dialog ---&#10;    if (showGameEndDialog) {&#10;        GameEndDialog(&#10;            isWin = isLevelClear,&#10;            score = currentSessionScore,&#10;            level = 4,&#10;            onDismiss = {&#10;                showGameEndDialog = false&#10;            },&#10;            onReplay = {&#10;                // Reset game&#10;                showGameEndDialog = false&#10;                isGameOver = false&#10;                isLevelClear = false&#10;                planeHp = 100&#10;                currentSessionScore = 0&#10;&#10;                growingMonsters.forEachIndexed { index, m -&gt;&#10;                    m.x = Random.nextFloat() * (screenWidthPx - 200f) + 100f&#10;                    m.y.value = -Random.nextInt(200, 2500).toFloat()&#10;                    m.hp.value = 80&#10;                    m.maxHp = 80&#10;                    m.currentMaxHp.value = 80&#10;                    m.currentSize.value = m.initialSize&#10;                    m.alive.value = true&#10;                    monsterRespawnTimes[index] = 0L&#10;                }&#10;&#10;                coins.forEach { c -&gt;&#10;                    c.collected.value = false&#10;                    c.y.value = -Random.nextInt(100, 600).toFloat()&#10;                    c.x = Random.nextFloat() * (screenWidthPx - 50f)&#10;                }&#10;&#10;                bullets.clear()&#10;            },&#10;            onNextLevel = {&#10;                onExit()&#10;            },&#10;            onExit = {&#10;                onExit()&#10;            }&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/game/ui/theme/GrowingMonsterUI.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/game/ui/theme/GrowingMonsterUI.kt" />
              <option name="originalContent" value="package com.example.game.ui&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.layout.absoluteOffset&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.R&#10;import com.example.game.core.GrowingMonster&#10;import kotlin.math.roundToInt&#10;&#10;/**&#10; * UI for Growing Monster with dynamic size and HP bar&#10; */&#10;@Composable&#10;fun GrowingMonsterUI(monster: GrowingMonster) {&#10;    if (monster.alive.value &amp;&amp; monster.hp.value &gt; 0) {&#10;        val density = LocalDensity.current&#10;        val sizeDp = with(density) { monster.currentSize.value.toDp() }&#10;&#10;        Image(&#10;            painter = painterResource(R.drawable.quaivat1),&#10;            contentDescription = null,&#10;            modifier = Modifier&#10;                .absoluteOffset {&#10;                    IntOffset(&#10;                        (monster.x - (monster.currentSize.value - 80f) / 2).roundToInt(),&#10;                        monster.y.value.roundToInt()&#10;                    )&#10;                }&#10;                .size(sizeDp)&#10;        )&#10;&#10;        // HP bar (scales with monster size)&#10;        val hpBarWidth = monster.currentSize.value&#10;        Canvas(&#10;            modifier = Modifier&#10;                .absoluteOffset {&#10;                    IntOffset(&#10;                        (monster.x - (monster.currentSize.value - 80f) / 2).roundToInt(),&#10;                        (monster.y.value - 20).roundToInt()&#10;                    )&#10;                }&#10;                .size(width = with(density) { hpBarWidth.toDp() }, height = 6.dp)&#10;        ) {&#10;            drawRect(color = Color.DarkGray, size = Size(size.width, size.height))&#10;            // Use currentMaxHp from monster instead of calculating&#10;            val hpPercent = if (monster.currentMaxHp.value &gt; 0) {&#10;                (monster.hp.value.toFloat() / monster.currentMaxHp.value.toFloat()).coerceIn(0f, 1f)&#10;            } else {&#10;                0f&#10;            }&#10;            drawRect(color = Color.Red, size = Size(size.width * hpPercent, size.height))&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.game.ui&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.layout.absoluteOffset&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.R&#10;import com.example.game.core.GrowingMonster&#10;import kotlin.math.roundToInt&#10;&#10;/**&#10; * UI for Growing Monster with dynamic size and HP bar&#10; */&#10;@Composable&#10;fun GrowingMonsterUI(monster: GrowingMonster, level: Int = 4) {&#10;    if (monster.alive.value &amp;&amp; monster.hp.value &gt; 0) {&#10;        val density = LocalDensity.current&#10;        val sizeDp = with(density) { monster.currentSize.value.toDp() }&#10;&#10;        val monsterDrawable = when(level) {&#10;            4 -&gt; R.drawable.quaivat1&#10;            else -&gt; R.drawable.quaivat1&#10;        }&#10;&#10;        Image(&#10;            painter = painterResource(monsterDrawable),&#10;            contentDescription = null,&#10;            modifier = Modifier&#10;                .absoluteOffset {&#10;                    IntOffset(&#10;                        (monster.x - (monster.currentSize.value - 80f) / 2).roundToInt(),&#10;                        monster.y.value.roundToInt()&#10;                    )&#10;                }&#10;                .size(sizeDp)&#10;        )&#10;&#10;        // HP bar (scales with monster size)&#10;        val hpBarWidth = monster.currentSize.value&#10;        Canvas(&#10;            modifier = Modifier&#10;                .absoluteOffset {&#10;                    IntOffset(&#10;                        (monster.x - (monster.currentSize.value - 80f) / 2).roundToInt(),&#10;                        (monster.y.value - 20).roundToInt()&#10;                    )&#10;                }&#10;                .size(width = with(density) { hpBarWidth.toDp() }, height = 6.dp)&#10;        ) {&#10;            drawRect(color = Color.DarkGray, size = Size(size.width, size.height))&#10;            // Use currentMaxHp from monster instead of calculating&#10;            val hpPercent = if (monster.currentMaxHp.value &gt; 0) {&#10;                (monster.hp.value.toFloat() / monster.currentMaxHp.value.toFloat()).coerceIn(0f, 1f)&#10;            } else {&#10;                0f&#10;            }&#10;            drawRect(color = Color.Red, size = Size(size.width * hpPercent, size.height))&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/game/ui/theme/InvisibleMonsterUI.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/game/ui/theme/InvisibleMonsterUI.kt" />
              <option name="originalContent" value="package com.example.game.ui&#10;&#10;import androidx.compose.animation.core.Animatable&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.layout.absoluteOffset&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.R&#10;import com.example.game.core.InvisibleMonster&#10;import kotlin.math.roundToInt&#10;&#10;/**&#10; * UI for Invisible Monster with fade effect&#10; */&#10;@Composable&#10;fun InvisibleMonsterUI(monster: InvisibleMonster) {&#10;    if (monster.alive.value &amp;&amp; monster.hp.value &gt; 0) {&#10;        // Fade effect when appearing/disappearing&#10;        val alpha = remember(monster.isVisible.value) {&#10;            Animatable(if (monster.isVisible.value) 1f else 0.3f)&#10;        }&#10;&#10;        LaunchedEffect(monster.isVisible.value) {&#10;            alpha.animateTo(&#10;                targetValue = if (monster.isVisible.value) 1f else 0.3f,&#10;                animationSpec = tween(300)&#10;            )&#10;        }&#10;&#10;        Image(&#10;            painter = painterResource(R.drawable.quaivat1),&#10;            contentDescription = null,&#10;            modifier = Modifier&#10;                .absoluteOffset { IntOffset(monster.x.roundToInt(), monster.y.value.roundToInt()) }&#10;                .size(80.dp)&#10;                .graphicsLayer { this.alpha = alpha.value }&#10;        )&#10;&#10;        // HP bar (only when visible)&#10;        if (monster.isVisible.value) {&#10;            Canvas(&#10;                modifier = Modifier&#10;                    .absoluteOffset {&#10;                        IntOffset(monster.x.roundToInt(), (monster.y.value - 20).roundToInt())&#10;                    }&#10;                    .size(width = 80.dp, height = 6.dp)&#10;            ) {&#10;                drawRect(color = Color.DarkGray, size = Size(size.width, size.height))&#10;                val hpPercent = (monster.hp.value / 100f).coerceIn(0f, 1f)&#10;                drawRect(color = Color.Red, size = Size(size.width * hpPercent, size.height))&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.example.game.ui&#10;&#10;import androidx.compose.animation.core.Animatable&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.layout.absoluteOffset&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.R&#10;import com.example.game.core.InvisibleMonster&#10;import kotlin.math.roundToInt&#10;&#10;/**&#10; * UI for Invisible Monster with fade effect&#10; */&#10;@Composable&#10;fun InvisibleMonsterUI(monster: InvisibleMonster, level: Int = 3) {&#10;    if (monster.alive.value &amp;&amp; monster.hp.value &gt; 0) {&#10;        // Fade effect when appearing/disappearing&#10;        val alpha = remember(monster.isVisible.value) {&#10;            Animatable(if (monster.isVisible.value) 1f else 0f)  // Thay đổi từ 0.3f thành 0f để tàng hình hoàn toàn&#10;        }&#10;&#10;        LaunchedEffect(monster.isVisible.value) {&#10;            alpha.animateTo(&#10;                targetValue = if (monster.isVisible.value) 1f else 0f,  // Thay đổi từ 0.3f thành 0f&#10;                animationSpec = tween(300)&#10;            )&#10;        }&#10;&#10;        val monsterDrawable = when(level) {&#10;            3 -&gt; R.drawable.monster3&#10;            else -&gt; R.drawable.quaivat1&#10;        }&#10;&#10;        Image(&#10;            painter = painterResource(monsterDrawable),&#10;            contentDescription = null,&#10;            modifier = Modifier&#10;                .absoluteOffset { IntOffset(monster.x.roundToInt(), monster.y.value.roundToInt()) }&#10;                .size(80.dp)&#10;                .graphicsLayer { this.alpha = alpha.value }&#10;        )&#10;&#10;        // HP bar (only when visible)&#10;        if (monster.isVisible.value) {&#10;            Canvas(&#10;                modifier = Modifier&#10;                    .absoluteOffset {&#10;                        IntOffset(monster.x.roundToInt(), (monster.y.value - 20).roundToInt())&#10;                    }&#10;                    .size(width = 80.dp, height = 6.dp)&#10;            ) {&#10;                drawRect(color = Color.DarkGray, size = Size(size.width, size.height))&#10;                val hpPercent = (monster.hp.value / 100f).coerceIn(0f, 1f)&#10;                drawRect(color = Color.Red, size = Size(size.width * hpPercent, size.height))&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/game/ui/theme/MonsterUI.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/game/ui/theme/MonsterUI.kt" />
              <option name="originalContent" value="package com.example.game.ui&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.layout.absoluteOffset&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.R&#10;import com.example.game.core.BaseMonster&#10;import kotlin.math.roundToInt&#10;&#10;@Composable&#10;fun MonsterUI(monster: BaseMonster) {&#10;    if (monster.alive.value &amp;&amp; monster.hp.value &gt; 0) {&#10;        Image(&#10;            painter = painterResource(R.drawable.quaivat1),&#10;            contentDescription = null,&#10;            modifier = Modifier&#10;                .absoluteOffset { IntOffset(monster.x.roundToInt(), monster.y.value.roundToInt()) }&#10;                .size(80.dp)&#10;        )&#10;&#10;        // HP bar&#10;        Canvas(&#10;            modifier = Modifier&#10;                .absoluteOffset {&#10;                    IntOffset(monster.x.roundToInt(), (monster.y.value - 20).roundToInt())&#10;                }&#10;                .size(width = 80.dp, height = 6.dp)&#10;        ) {&#10;            drawRect(color = Color.DarkGray, size = Size(size.width, size.height))&#10;            val hpPercent = (monster.hp.value / 100f).coerceIn(0f, 1f)&#10;            drawRect(color = Color.Red, size = Size(size.width * hpPercent, size.height))&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.game.ui&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.layout.absoluteOffset&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.R&#10;import com.example.game.core.BaseMonster&#10;import kotlin.math.roundToInt&#10;&#10;@Composable&#10;fun MonsterUI(monster: BaseMonster, level: Int = 1) {&#10;    if (monster.alive.value &amp;&amp; monster.hp.value &gt; 0) {&#10;        val monsterDrawable = when(level) {&#10;            2 -&gt; R.drawable.monster2&#10;            3 -&gt; R.drawable.monster3&#10;            else -&gt; R.drawable.quaivat1&#10;        }&#10;        &#10;        Image(&#10;            painter = painterResource(monsterDrawable),&#10;            contentDescription = null,&#10;            modifier = Modifier&#10;                .absoluteOffset { IntOffset(monster.x.roundToInt(), monster.y.value.roundToInt()) }&#10;                .size(80.dp)&#10;        )&#10;&#10;        // HP bar&#10;        Canvas(&#10;            modifier = Modifier&#10;                .absoluteOffset {&#10;                    IntOffset(monster.x.roundToInt(), (monster.y.value - 20).roundToInt())&#10;                }&#10;                .size(width = 80.dp, height = 6.dp)&#10;        ) {&#10;            drawRect(color = Color.DarkGray, size = Size(size.width, size.height))&#10;            val hpPercent = (monster.hp.value / 100f).coerceIn(0f, 1f)&#10;            drawRect(color = Color.Red, size = Size(size.width * hpPercent, size.height))&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/game/ui/theme/PlaneUI.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/game/ui/theme/PlaneUI.kt" />
              <option name="originalContent" value="package com.example.game.ui&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.layout.absoluteOffset&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.R&#10;import kotlin.math.roundToInt&#10;&#10;@Composable&#10;fun PlaneUI(&#10;    planeX: Float,&#10;    planeY: Float,&#10;    planeHp: Int,&#10;    shieldActive: Boolean&#10;) {&#10;    // Plane&#10;    Image(&#10;        painter = painterResource(R.drawable.maybay1),&#10;        contentDescription = null,&#10;        modifier = Modifier&#10;            .absoluteOffset { IntOffset(planeX.roundToInt(), planeY.roundToInt()) }&#10;            .size(100.dp)&#10;    )&#10;&#10;    // HP bar&#10;    Canvas(&#10;        modifier = Modifier&#10;            .absoluteOffset {&#10;                IntOffset(planeX.roundToInt(), (planeY - 20).roundToInt())&#10;            }&#10;            .size(width = 100.dp, height = 8.dp)&#10;    ) {&#10;        drawRect(color = Color.DarkGray, size = Size(size.width, size.height))&#10;        val ratio = planeHp.coerceIn(0, 100) / 100f&#10;        drawRect(color = Color.Green, size = Size(size.width * ratio, size.height))&#10;    }&#10;&#10;    // Shield&#10;    if (shieldActive) {&#10;        Canvas(&#10;            modifier = Modifier&#10;                .absoluteOffset { IntOffset((planeX - 10).roundToInt(), (planeY - 10).roundToInt()) }&#10;                .size(120.dp)&#10;        ) {&#10;            drawCircle(color = Color.Cyan.copy(alpha = 0.35f))&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.game.ui&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.layout.absoluteOffset&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.example.game.R&#10;import kotlin.math.roundToInt&#10;&#10;@Composable&#10;fun PlaneUI(&#10;    planeX: Float,&#10;    planeY: Float,&#10;    planeHp: Int,&#10;    shieldActive: Boolean,&#10;    level: Int = 1&#10;) {&#10;    val planeDrawable = when(level) {&#10;        2 -&gt; R.drawable.plane2&#10;        3 -&gt; R.drawable.plane3&#10;        else -&gt; R.drawable.maybay1&#10;    }&#10;    &#10;    // Plane&#10;    Image(&#10;        painter = painterResource(planeDrawable),&#10;        contentDescription = null,&#10;        modifier = Modifier&#10;            .absoluteOffset { IntOffset(planeX.roundToInt(), planeY.roundToInt()) }&#10;            .size(100.dp)&#10;    )&#10;&#10;    // HP bar&#10;    Canvas(&#10;        modifier = Modifier&#10;            .absoluteOffset {&#10;                IntOffset(planeX.roundToInt(), (planeY - 20).roundToInt())&#10;            }&#10;            .size(width = 100.dp, height = 8.dp)&#10;    ) {&#10;        drawRect(color = Color.DarkGray, size = Size(size.width, size.height))&#10;        val ratio = planeHp.coerceIn(0, 100) / 100f&#10;        drawRect(color = Color.Green, size = Size(size.width * ratio, size.height))&#10;    }&#10;&#10;    // Shield&#10;    if (shieldActive) {&#10;        Canvas(&#10;            modifier = Modifier&#10;                .absoluteOffset { IntOffset((planeX - 10).roundToInt(), (planeY - 10).roundToInt()) }&#10;                .size(120.dp)&#10;        ) {&#10;            drawCircle(color = Color.Cyan.copy(alpha = 0.35f))&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>